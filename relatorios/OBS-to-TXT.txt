
=== DIRETÓRIO: OBS-to-TXT ===

--- ARQUIVO: OBS-to-TXT\01Analize.ipynb (sem output) ---
{
  "cells": [
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "import pandas as pd\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "df = pd.read_csv(r\"C:\\Users\\jonat\\Documents\\GitHub\\OBS-to-TXT\\dflimpo.csv\")\n",
        "df.describe()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": []
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "plt.hist(df['Contagem de Palavras'])"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "plt.hist(df['Links'])"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "file_extension": ".py",
      "mimetype": "text/x-python",
      "name": "python",
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "version": "3.12.5"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 2
}

--- ARQUIVO: OBS-to-TXT\02cleaning.ipynb (sem output) ---
{
  "cells": [
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "import pandas as pd\n",
        "import numpy as np\n",
        "df = pd.read_csv(r'C:\\Users\\jonat\\Documents\\GitHub\\OBS-to-TXT\\notas_organizadas.csv')\n",
        "df.info()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "df.describe()"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "transformar as tabelas de data para o tipo data."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "df['Data da Última Modificação'] = pd.to_datetime(df['Data da Última Modificação']).dt.date\n",
        "df['Data da Última Modificação'] = pd.to_datetime(df['Data da Última Modificação'], errors='coerce') \n",
        "df['Data da Nota'] = pd.to_datetime(df['Data da Nota'], errors='coerce')\n",
        "df.info()\n",
        "df.sample(10)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "df"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Mudar o tipo de data e hora para o brasileiro. "
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# df['Data da Última Modificação_Data'] = df['Data da Última Modificação'].dt.strftime('%d/%m/%y')\n",
        "# df['Data da Nota_Data'] = df['Data da Nota'].dt.strftime('%d/%m/%y')\n",
        "df.info()\n",
        "df"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Corrigir o as tags"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "df['Tags'] = df['Tags'].apply(lambda x: np.nan if isinstance(x, str) and x.startswith('data:') else x)\n",
        "df['Tags'] = df['Tags'].str.replace(r'#', '', regex=True)\n",
        "df['Tags'] = df['Tags'].str.replace(r'\"', '', regex=True)\n",
        "df.sample(20)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"Tags\"].unique()"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Separar todas as tags em uma lista. "
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "df['Tags'] = df['Tags'].apply(lambda x: [tag.strip() for tag in str(x).split()] if pd.notna(x) else [])\n",
        "df.sample(20)\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "df.info()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "def obter_valores_lista(df, coluna):\n",
        "    valores = []\n",
        "    for lista in df[coluna]:\n",
        "        valores.extend(lista)  # Adiciona todos os valores da lista à lista 'valores'\n",
        "    return valores\n",
        "\n",
        "# Chamando a função e exibindo o resultado\n",
        "todos_valores = obter_valores_lista(df, 'Tags')\n",
        "list(set(todos_valores))"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "df"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "df.to_csv('dflimpo.csv', index=False, encoding='utf-8')"
      ]
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "file_extension": ".py",
      "mimetype": "text/x-python",
      "name": "python",
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "version": "3.12.5"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 2
}

--- ARQUIVO: OBS-to-TXT\03Engenharia_de_características.ipynb (sem output) ---
{
  "cells": [
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "import pandas as pd\n",
        "import numpy as np"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "df = pd.read_csv(r\"C:\\Users\\jonat\\Documents\\GitHub\\OBS-to-TXT\\dflimpo.csv\")\n",
        "df"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Aplicando a função na coluna \"Contagem de Palavras\"\n",
        "df['Palavras/Link'] = df['Contagem de Palavras'].rank(method='average', ascending=False)/df['Links'].rank(method='average', ascending=False)\n",
        "df.head(10)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "df.sort_values(\"Palavras/Link\").head(10)\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "import ast\n",
        "df['cont_tags'] = df['Tags'].apply(lambda x: ast.literal_eval(x)).apply(len)\n",
        "df"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "df['quão_escondido'] = df['Caminho da Nota'].str.count(r\"\\\\\")\n",
        "df"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "df.to_csv('dflimpo.csv', index=False, encoding='utf-8')"
      ]
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "file_extension": ".py",
      "mimetype": "text/x-python",
      "name": "python",
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "version": "3.12.5"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 2
}

--- ARQUIVO: OBS-to-TXT\README.MD ---
# OBS-to-TXT: Ferramentas de Análise e Organização de Notas do Obsidian

Este repositório contém um conjunto de scripts e notebooks Jupyter projetados para analisar, organizar e extrair informações de notas do Obsidian. A principal funcionalidade é converter e processar arquivos Markdown (.md) do Obsidian em formatos mais estruturados, como CSV, facilitando a análise de dados e a geração de relatórios.

## Funcionalidades Principais

- **Conversão de Notas do Obsidian:** Scripts que extraem dados de arquivos Markdown do Obsidian, incluindo:
    - Nome da nota
    - Data da última modificação
    - Data da nota (se presente no conteúdo)
    - Tags (corrigindo o problema de detecção)
    - Contagem de palavras
    - Número de links internos (wiki-links `[[...]]`)
    - Caminho relativo da nota
- **Organização e Limpeza de Dados:** Notebooks Jupyter para limpar e preparar os dados extraídos, incluindo:
    - Conversão de strings de data para o tipo datetime.
    - Correção e padronização de tags.
    - Separação de tags em listas.
    - Criação de novas features (características) a partir dos dados existentes (ex: proporção palavras/links, contagem de tags, nível de profundidade no sistema de arquivos).
- **Análise Exploratória:** Notebooks para análise exploratória básica dos dados, com geração de estatísticas descritivas e visualizações (histogramas).

## Estrutura do Repositório
OBS-to-TXT/
├── 01Analize.ipynb # Notebook: Análise inicial dos dados limpos (sem output).
├── 02cleaning.ipynb # Notebook: Limpeza e pré-processamento dos dados (sem output).
├── 03Engenharia_de_características.ipynb # Notebook: Criação de novas features (sem output).
├── README.MD # Este arquivo.
├── app.py # Script Python (legado): Junta notas em um único arquivo .txt.
├── nome/
│ ├── app2.py # Script Python: Processamento de arquivos Markdown e extração de dados para CSV.
│ └── notas_consolidadas.txt # Exemplo de saída do script app2.py (notas concatenadas).
├── notas_consolidadas.txt # Exemplo de saída do script app.py (notas concatenadas).
└── teste.py # Script Python aprimorado: Processa arquivos MD e gera CSV (versão atualizada).

## Scripts Python

- **`app.py` (Legado):** Este script original junta todas as notas Markdown (.md) de uma pasta especificada em um único arquivo de texto (`notas_consolidadas.txt`).  Ele inclui o caminho completo do arquivo e a data da última modificação no arquivo de saída.  *Este script é considerado legado e foi substituído por `nome/app2.py` e `teste.py`.*

- **`nome/app2.py` (Versão anterior):** Uma versão aprimorada que extrai mais metadados dos arquivos Markdown e salva os resultados em um arquivo CSV (`notas_organizadas.csv`).  Extrai nome da nota, data de última modificação, data da nota (se presente no conteúdo), tags e contagem de palavras.  *Este script foi substituído por `teste.py`.*

- **`teste.py` (Versão Atual):** A versão mais recente e recomendada do script.  Ele *corrige problemas* encontrados em `nome/app2.py`, principalmente relacionados à extração de tags. Além das informações extraídas por `app2.py`, este script também inclui a contagem de links internos ([[...]]) e o caminho relativo do arquivo.

## Notebooks Jupyter (Sem Output)

Os notebooks Jupyter (`.ipynb`) na pasta raiz *não incluem as saídas das células de código*. Isso foi feito intencionalmente para manter o repositório limpo e permitir que você execute os notebooks e veja os resultados por si mesmo.

- **`01Analize.ipynb`:**  Análise exploratória inicial dos dados limpos. Inclui histogramas para contagem de palavras e links.

- **`02cleaning.ipynb`:**  Limpeza e pré-processamento dos dados. Inclui a conversão de datas, correção de tags (remoção de caracteres indesejados, separação em listas), e tratamento de valores ausentes.

- **`03Engenharia_de_características.ipynb`:** Criação de novas características (features) a partir dos dados existentes, como a proporção entre palavras e links, contagem de tags, e nível de profundidade da nota no sistema de arquivos (número de subpastas).

## Como Usar

1.  **Clone o repositório:**
    ```bash
    git clone https://github.com/sua-conta/OBS-to-TXT.git
    cd OBS-to-TXT
    ```

2.  **Execute o script `teste.py`:**  
    Altere o caminho `pasta_inicial` no script `teste.py` para apontar para a pasta raiz do seu cofre do Obsidian (vault).  Execute o script:

    ```bash
    python teste.py
    ```
    Isso gerará um arquivo CSV (`notas_organizadas.csv`) com os dados extraídos dos seus arquivos Markdown.

3.  **Explore os notebooks Jupyter:**  
    Abra os notebooks (`01Analize.ipynb`, `02cleaning.ipynb`, `03Engenharia_de_características.ipynb`) com o Jupyter Notebook ou JupyterLab para explorar a análise, limpeza e criação de novas features.  Execute as células dos notebooks para ver os resultados.

## Notas Importantes

-   O script `teste.py` é a versão *mais atualizada* e *recomendada* para extrair dados dos seus arquivos Markdown do Obsidian. Os scripts `app.py` e `nome/app2.py` são versões anteriores e são mantidos para fins de histórico/referência.
-   Os notebooks Jupyter são fornecidos *sem as saídas*. Você precisará executá-los para ver os resultados.
-   O caminho para o seu cofre do Obsidian (variável `pasta_inicial` no script `teste.py`) *deve ser ajustado* antes de executar o script.

## Contribuições

Contribuições são bem-vindas! Se você encontrar bugs, tiver sugestões de melhorias ou quiser adicionar novas funcionalidades, sinta-se à vontade para criar um _pull request_.


--- ARQUIVO: OBS-to-TXT\app.py ---
import os
from datetime import datetime

def juntar_notas_em_txt(pasta_inicial, arquivo_saida):
    with open(arquivo_saida, 'w', encoding='utf-8') as arquivo_txt:
        for root, dirs, files in os.walk(pasta_inicial):
            for file in files:
                if file.endswith(".md"):
                    caminho_completo = os.path.join(root, file)
                    
                    # Obtém a data de última modificação
                    ultima_modificacao = os.path.getmtime(caminho_completo)
                    data_formatada = datetime.fromtimestamp(ultima_modificacao).strftime('%Y-%m-%d %H:%M:%S')

                    # Adiciona o caminho do arquivo e a data de edição no txt
                    arquivo_txt.write(f"\n\n### Caminho: {caminho_completo}\n")
                    arquivo_txt.write(f"### Última modificação: {data_formatada}\n\n")

                    # Lê o conteúdo do arquivo .md
                    with open(caminho_completo, 'r', encoding='utf-8') as arquivo_md:
                        conteudo = arquivo_md.read()
                        arquivo_txt.write(conteudo)

    print(f"Arquivo consolidado criado: {arquivo_saida}")

# Caminho da pasta onde estão suas notas em .md
pasta_inicial = r"C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst"
# Arquivo onde todas as notas serão concatenadas
arquivo_saida = "notas_consolidadas.txt"

juntar_notas_em_txt(pasta_inicial, arquivo_saida)





=== DIRETÓRIO: OBS-to-TXT\nome ===

--- ARQUIVO: OBS-to-TXT\nome\app2.py ---
import os
import re
from datetime import datetime
import csv

def process_markdown_files(pasta_inicial, arquivo_saida):
    """
    Processa arquivos Markdown em uma pasta, extraindo informações como título, tags, data e contagem de palavras,
    e salva os resultados em um arquivo CSV.
    
    Args:
        pasta_inicial (str): O caminho para a pasta que contém os arquivos Markdown.
        arquivo_saida (str): O caminho para o arquivo CSV de saída.
    """
    with open(arquivo_saida, 'w', encoding='utf-8', newline='') as arquivo_csv:
        writer = csv.writer(arquivo_csv)
        writer.writerow(['Nome da Nota', 'Data da Última Modificação', 'Data da Nota', 'Tags', 'Contagem de Palavras'])
        
        for root, dirs, files in os.walk(pasta_inicial):
            for file in files:
                if file.endswith(".md"):
                    caminho_completo = os.path.join(root, file)
                    
                    # Obtém a data de última modificação
                    ultima_modificacao = os.path.getmtime(caminho_completo)
                    data_formatada = datetime.fromtimestamp(ultima_modificacao).strftime('%Y-%m-%d %H:%M:%S')
                    
                    try:
                        with open(caminho_completo, 'r', encoding='utf-8') as arquivo_md:
                            conteudo = arquivo_md.read()

                            # Extrai o nome do arquivo (sem extensão) como nome da nota
                            nome_nota = os.path.splitext(file)[0]
                            
                            # Busca a data dentro do conteúdo do arquivo
                            data_match = re.search(r'data: (\d{4}-\d{2}-\d{2})', conteudo)
                            data_nota = data_match.group(1) if data_match else ""

                            # Busca as tags no arquivo
                            tags_match = re.search(r'tags:\s*(\n\s*-\s*[\w\s]+)+', conteudo)
                            tags = ""
                            if tags_match:
                                tag_list = re.findall(r'- ([\w\s]+)', tags_match.group(0))
                                tags = ", ".join([tag.strip() for tag in tag_list])
                            
                            # Conta o número de palavras do conteúdo
                            palavras = re.findall(r'\b\w+\b', conteudo)
                            contagem_palavras = len(palavras)

                            # Escreve os resultados no CSV
                            writer.writerow([nome_nota, data_formatada, data_nota, tags, contagem_palavras])
                    except Exception as e:
                        print(f"Erro ao processar {file}: {e}")

    print(f"Arquivo CSV criado: {arquivo_saida}")

# Caminho da pasta onde estão suas notas em .md
pasta_inicial = r"C:\Users\jonat\Dropbox\Obsidian\obsidian"
# Arquivo onde todas as notas serão concatenadas
arquivo_saida = "notas_organizadas.csv"

process_markdown_files(pasta_inicial, arquivo_saida)

--- ARQUIVO: OBS-to-TXT\nome\notas_consolidadas.txt ---


--- ARQUIVO: OBS-to-TXT\notas_consolidadas.txt ---


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Freela.md
### Última modificação: 2024-12-02 21:00:47

---
tags: 
data: 2024-12-02
---
# Nicho de atuação
workana


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\mineração de dado.md
### Última modificação: 2024-10-01 19:09:14

---
tags:
  - DataAnalyst
  - Datascience
data: 2024-10-01
---

Mineração de dados é como procurar ouro em um rio, mas em vez de ouro, buscamos **informações valiosas** escondidas em **montanhas de dados**. Usamos ferramentas e técnicas especiais para **descobrir padrões, tendências e relações ocultas**, que podem ser usadas para tomar **melhores decisões**, fazer **previsões** e **resolver problemas**. ⛏️🔍📈



### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Sites.md
### Última modificação: 2024-08-24 00:29:46

---
tags: 
data: 2024-08-24
nivel:
---
# Reds
[[midium]]
[[ANALITYCSVIDHYA]]


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\0 Oque fazer\Geral.md
### Última modificação: 2024-08-31 01:17:01

---
tags:
  - Datascience
  - Python
  - Pandas
  - Programação
data: 2024-08-05
nivel:
---
baixar python
[[linkedin]]
# Passos
## [[Python]]:
- [x] Rever oque aprendi
- [x] Básico do [[Jupyter]]
- [ ] inline
- [ ] [[Pip]]
- [x] [[Classes]] e [[Objetos]]
- [x] [[Encapsulamento]]
- [x] [[Herança]]
- [x] [[Polimorfismo]]
- [ ] [[Exceções]]
- [ ] erros
- [ ] testes
 [[Pandas]]:
 - [x] Como instalar
 - [ ] Ler e escrever arquivos em arquivos: [[Excel]] e [[CSV]]
	 - [ ] Valores ausentes
	 - [ ] Agrupar por
	 - [ ] Concatenar e mesclar
[[Numpy]]:
[[Matplotlib]]:
[[Seaborn]]:
Data science influencers:
[[Projetos]]
# Programação avançado 
- [ ] meta programação
- [ ] arquitetura de atores
- [ ] event loop
- [ ] couroutine(fiber, generator)
- [ ] tread pool
- [ ] Fila de Tarefas e Workers
- [ ] green tread











### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Conceitos\Análise inicial do DF.md
### Última modificação: 2024-12-21 19:43:52

---
tags: 
data: 2024-12-21
---
Analisar as primeiras linhas ou aleatoriamente.
Analisar a informação de cada coluna, o tipo da coluna a quantidade de valores nulos, nome das colunas
Analisar as primeiras linhas ou aleatoriamente.


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Conceitos\churn.md
### Última modificação: 2024-11-11 21:35:40

---
tags:
  - DataAnalyst
  - Conceito
data: 2024-11-11
---
Rotatividade (do inglês para o português é "agitar", "bater" ou "revolver") é a porcentagem de clientes que cancelam sua assinatura ou param de usar um serviço durante um determinado período (geralmente mensal, trimestral ou anual).

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Conceitos\Coeficiente de correlação linear.md
### Última modificação: 2024-12-18 00:36:32

---
tags:
  - Gráfico
  - Conceito
data: 2024-12-18
Link: https://www.youtube.com/watch?v=ayAxTRN4aVg
---
O coeficiente de correlação é uma medida estatística que indica a força e a direção da relação entre duas variáveis. Ele varia entre -1 e 1, onde um valor de 1 significa uma correlação positiva perfeita (quando uma variável aumenta, a outra também aumenta), -1 indica uma correlação negativa perfeita (quando uma variável aumenta, a outra diminui), e 0 significa que não há correlação linear entre as variáveis. O coeficiente de correlação é frequentemente usado para entender o grau de associação entre duas variáveis numéricas em um conjunto de dados.![[dcvv.gif|200]]

Se pegar o modulo do coeficiente de correlação dara a  medida da **força** da correlação entre duas variáveis.

# Math da coisa  
$r = \frac{n \sum{xy} - \sum{x} \sum{y}}{\sqrt{[n \sum{x^2} - (\sum{x})^2][n \sum{y^2} - (\sum{y})^2]}}​$

| x        | y        | x²       | y²       | xy       |
| -------- | -------- | -------- | -------- | -------- |
| 3        | 7        | 9        | 49       | 21       |
| 2        | 5        | 4        | 25       | 10       |
| -1       | -1       | 1        | 1        | 1        |
| 4        | 9        | 16       | 81       | 36       |
| **Soma** | **Soma** | **Soma** | **Soma** | **Soma** |
| 8        | 20       | 30       | 156      | 68       |
1. **n** = 4 (número de pares de dados).
2. **Σx** = 8 (soma dos valores de x).
3. **Σy** = 20 (soma dos valores de y).
4. **Σx²** = 30 (soma dos valores de x²).
5. **Σy²** = 156 (soma dos valores de y²).
6. **Σxy** = 68 (soma dos valores de xy).
$r = \frac{4 \times 68 - 8 \times 20}{\sqrt{[4 \times 30 - (8)^2][4 \times 156 - (20)^2]}}$
$r = 1$

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Conceitos\Engenharia de características.md
### Última modificação: 2024-12-28 15:51:57

---
tags:
  - Conceito
data: 2024-12-27
---
É a criação de novas variáveis a partir das existentes.

[[,fillna]], [[,dropna]], [[,astype]], pd.[[,to_datetime]], pd.get_dummies(), map(), [[,apply]], [[,groupby]], [[,corr]], fit_transform(), transform(), LabelEncoder(), MinMaxScaler(), StandardScaler(), VarianceThreshold(), KMeans(), PCA(), FastICA().

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Conceitos\Importância do grafico.md
### Última modificação: 2024-12-05 18:58:41

---
tags: 
data: 2024-12-05
---
As descrições numéricas dizem muito sobre o conjunto de dados mas não diz tudo, é importante ver o gráfico também.
[Datasaurus Dozen](https://cran.r-project.org/web/packages/datasauRus/vignettes/Datasaurus.html)
![[image.gif]]


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Conceitos\Outliers.md
### Última modificação: 2024-12-21 19:36:55

---
tags:
  - Estatística
  - Conceito
data: 2024-12-21
---
Outliers são valores extremos que se distanciam significativamente da maioria dos dados em um conjunto, podendo influenciar análises estatísticas.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Conceitos\Rotatividade.md
### Última modificação: 2024-11-11 21:23:20

---
tags:
  - DataAnalyst
  - Conceito
data: 2024-11-11
---
"Rotatividade" em Data Analytics (DA) ou Ciência de Dados geralmente se refere à **rotatividade de clientes**, também conhecida como [[churn]]. 

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Excel\Avaliar fórmula.md
### Última modificação: 2024-12-31 01:27:20

---
tags:
  - DataAnalyst
data: 2024-09-06
nivel:
---
O avaliar fórmula no Excel é o debug para a programação

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Excel\DADADIF.md
### Última modificação: 2024-08-25 23:37:47

---
tags:
  - DataAnalyst
data: 2024-08-25
nivel:
---
Retorna a diferença das datas, em vários formatos
![[Pasted image 20240825233423.png]]
data_de_inicio a data que começa o período
      -
data_de_termino a data que termina o período
	  =
unidade como será representada a diferença.

| Elementos | Significado dos elementos                                  |
| --------- | ---------------------------------------------------------- |
| “d”       | Representa diferença, em dias, sobre duas datas.           |
| “m”       | Representa diferença, em meses, sobre duas datas.          |
| “y”       | Representa diferença, em anos, sobre duas datas.           |
| “md”      | Representa diferença, em dias, mas ignorando meses e anos. |
| “yd”      | Representa diferença, em dias, mas ignorando anos.         |
| “ym”      | Representa diferença, em mes, mas ignorando dias e anos.   |

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Excel\F4.md
### Última modificação: 2024-11-04 16:43:18

---
tags:
  - Comando
data: 2024-11-04
---
[[Referência absoluta]]
- `$B$1` — Fixa o endereço completo. Pressione `F4` uma vez.
- `B$1` — Fixa apenas o número de linha. Pressione `F4` duas vezes.
- `$B1` — Fixa apenas o nome de coluna. Pressione `F4` três vezes.

Se $ estiver antes de uma letra, então a letra não muda.
Se $ estiver antes de um número, o número não será alterado.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Excel\Função TEXTO.md
### Última modificação: 2024-12-31 01:28:07

---
tags:
  - DataAnalyst
data: 2024-09-06
nivel:
---
![[Pasted image 20240906004947.png]]

|**Fórmula**|**Descrição**|
|---|---|
|=TEXTO(1234,567;**"$#;##0,00"**)|Moeda com separador de milhares e duas casas decimais, como R$ 1.234,57. Observe que o Excel arredonda o valor para duas casas decimais.|
|=TEXTO(HOJE();**"DD/MM/AA"**)|Data de hoje no formato DD/MM/AA, como 14/03/12|
|=TEXTO(HOJE();**"DDDD"**)|Dia da semana hoje, como segunda-feira|
|=TEXTO(AGORA();**"HH:MM"**)|Hora atual, como 13:29|
|=TEXTO(0,285;**"0,0%"**)|Porcentagem, como 28,5%|
|=TEXTO(4,34 ,**"# ?/?"**)|Fração, como 4 1/3|
|=ARRUMAR(TEXTO(0,34;**"#? /?"** ))|Fração, como 1/3. Observe que a função ARRUMAR é usada para remover os espaços à esquerda em um valor decimal.|
|=TEXTO(12200000;**"0,00E+00"**)|Notação científica, como 1,22E+07|
|=TEXTO(2125727898,**"[<=9999999]####-####;(##)>**)|Números especiais (número de telefone), como (21) 2572-7898|
|=TEXTO(1234;**"0000000"**)|Adiciona zeros (0), como 0001234|
|=TEXTO(123456;**"##0° 00' 00''"**)|Personalizado – Latitude/Longitude|

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Excel\Função.excel.md
### Última modificação: 2024-12-31 01:28:12

---
tags:
  - DataAnalyst
data: 2024-08-25
nivel:
---

| Comando   | Serve para                |
| --------- | ------------------------- |
| F4        | por como referencia($B$1) |
| ALT+ENTER | pular linha na celula     |

| Nome                         | Uso                                                                                                | Serve para                                                                                           |
| ---------------------------- | -------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------- |
| [[Média Aritmética\| média]] | MÉDIA(núm1; núm2;...)                                                                              | calcular a média de n [[Células]]                                                                    |
| [[Mediana Simples\|mediana]] | MED(núm1; núm2;...)                                                                                | calcular a mediana de n células                                                                      |
| [[Moda\|modo]]               | MODO(núm1; núm2;...)                                                                               | calcula a moda de n células                                                                          |
| mínimo                       | MÍNIMO(núm1; núm2;...)                                                                             | retorna o mínimo de n células                                                                        |
| máximo                       | MÁXIMO(núm1; núm2;...)                                                                             | retorna o máximo de n células                                                                        |
| hoje                         | =HOJE()                                                                                            | retorna o dia atual([[Data no excel\|data]])                                                         |
| agora                        | =AGORA()                                                                                           | retorna a hora atual                                                                                 |
| data                         | DATA(ano; mês; dia)                                                                                | retorna a data na [[Data no exce\|formatação do excel]]                                              |
| [[Função TEXTO\|testo]]      | TEXTO(valor; formato_texto)                                                                        | muda a visualização do numero                                                                        |
| **Procura Valo**             | =PROCV(valor_procurado; matriz_tabela; procurar_intervalo)                                         | procura valor na linha do valor_procurado                                                            |
| se erro                      | =SEERRO(valor; valor_se_erro)                                                                      | Se ocorrer um erro; faz algo[[SEERRO\|.]]                                                            |
| correspondência              | =CORRESP(valor_procurado; Matriz_procurada; tipo_correspondência)                                  | Acha o local de um valor procurado em uma tabela.                                                    |
| soma se                      | =SOMASE(intervalo; critérios; intervalo_soma)                                                      | Soma todos que passam no critério.                                                                   |
| soma se se..                 | =SOMASES(intervalo_soma; intervalo_critérios1; critérios1; intervalo_critérios2; critérios2;...)   | Como o de cima porém por vários critérios                                                            |
| conta se                     | =CONTASE(intervalo;critério)                                                                       | Conta os a quantidade de células a partir de 1 critério.                                             |
| conta se se                  | =CONTASES(intervalo_critérios; critérios; intervalo_critérios1; critérios1;...)                    | Como o de cima porém com mais critérios.                                                             |
| média se                     | =intervalo; critérios; intervalo_média)                                                            | Faz a media com critério                                                                             |
| média se se                  | =MÉDIASES(intervalo_média; intervalo_critérios; critérios; intervalo_critérios1; critérios1;...)   | Como o de cima porém com mais critérios.                                                             |
| máximo se se                 | =MÁXIMOSES(intervalo_máximo; intervalo_critérios; critérios; intervalo_critérios1; critérios1;...) | Diz o valor máximo com critérios.                                                                    |
| mínimo se se                 | =MÍNIMOSES(intervalo_mínimo; intervalo_critérios; critérios; intervalo_critérios1; critérios1;...) | Diz o valor mínimo com critérios.                                                                    |
| PROCV(vlookup)               | =PROCV(valor_procurado; intervalo_tabela; número_coluna; procurar_intervalo)                       | Procura um valor em uma **coluna** à esquerda e retorna um valor de uma coluna específica à direita. |
| PROCH(hlookup)               | =PROCH(valor_procurado; intervalo_tabela; número_linha; procurar_intervalo)                        | Procura um valor em uma **linha** superior e retorna um valor de uma linha específica abaixo.        |
| [[SE]]                       |                                                                                                    |                                                                                                      |

[[Variáveis no excel]] 
[[Tabelas dinâmicas]]
[[Lista suspensa]]
[[Avaliar fórmula]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Excel\hlookup.md
### Última modificação: 2024-08-25 23:36:37



### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Excel\SE.md
### Última modificação: 2024-09-07 21:02:06

---
tags:
  - DataAnalyst
data: 2024-08-25
nivel:
---
![[Pasted image 20240825230321.png]]
teste_lógico é um algoritmo que retornara um [[Bool|booleano]] 
	Caso `True` executa o valor_se_verdadeiro
	Caso `False` executa o valor_se_falso
### Operador

| comando | Significado      | Exemplo  |
| ------- | ---------------- | -------- |
| =       | igual a          | A1 = B1  |
| >       | maior que        | A1 > B1  |
| <       | menor que        | A1 < B1  |
| >=      | maior ou igual a | A1 >= B1 |
| <=      | menor ou igual a | A1 <= B1 |
| <>      | diferente de     | A1 <> B1 |



### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Excel\SEERRO.md
### Última modificação: 2024-12-31 01:29:57

---
tags:
  - DataAnalyst
data: 2024-09-06
nivel:
---
**SEERRO(valor, valor_se_erro)**

A sintaxe da função SEERRO tem os seguintes argumentos:

- **valor**    Obrigatório. O argumento verificado quanto ao erro.
    
- **value_if_error**    Obrigatório. O valor a ser retornado se a fórmula for avaliada como um erro. Os seguintes tipos de erro são avaliados: `#N/A, #VALUE!, #REF!, #DIV/0!, #NUM!, #NAME?, ou #NULL`!.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Excel\Tabelas dinâmicas.md
### Última modificação: 2024-12-31 01:30:25

---
tags:
  - DataAnalyst
data: 2024-09-07
nivel:
---
Coluna = campo
![[Pasted image 20240907001733.png]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Excel\Variáveis no excel.md
### Última modificação: 2024-12-31 01:30:46

---
tags:
  - DataAnalyst
data: 2024-09-06
nivel:
---
![[Pasted image 20240906010556.png]] Pode ser uma constante.
![[Pasted image 20240906010833.png]] esta referenciando uma célula
Como uma [[Variável|variável]] em programação


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Excel\vlookup.md
### Última modificação: 2024-08-25 23:36:28



### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Graficos\Acercamento.md
### Última modificação: 2024-09-12 16:09:15

---
tags: 
data: 2024-09-12
nivel:
---
![[Storytelling com dados.pdf#page=83&rect=67,592,433,723|(...)]]
Separa por meio externos também dão a sensação de unidade. 
![[Storytelling com dados.pdf#page=83&rect=69,370,226,523|(...)]]
Assim como para classificar. 

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Graficos\Barras horizontais empilhadas.md
### Última modificação: 2024-12-31 01:27:39

---
tags:
  - DataAnalyst
data: 2024-09-11
nivel:
---
![[Storytelling com dados.pdf#page=68&rect=67,469,500,727|(...)]]


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Graficos\Barras horizontais.md
### Última modificação: 2024-12-31 01:27:36

---
tags:
  - DataAnalyst
data: 2024-09-11
nivel:
---
Ótimo  para [[dados categóricos]]
![[Storytelling com dados.pdf#page=66&rect=69,100,542,240|(...)]]




### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Graficos\Barras verticais empilhadas.md
### Última modificação: 2024-12-31 01:27:47

---
tags:
  - DataAnalyst
data: 2024-09-10
nivel:
---
Quanto mais empilhada mais difícil de interpretar as pilhas acima da primeira. ![[Storytelling com dados.pdf#page=64&rect=70,319,539,483|(...)]]a diferença das barras com cada coluna 100%.
![[Pasted image 20240910170134.png]]
![[Pasted image 20240910170148.png]]

Pode ser usado para comparar quantidades diferentes, levando em conta apenas as proporções. 

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Graficos\Barras verticais.md
### Última modificação: 2024-12-31 01:27:43

---
tags:
  - DataAnalyst
data: 2024-09-10
nivel:
---
Tome cuidado com muitas séries de barras.
![[Storytelling com dados.pdf#page=63&rect=70,79,544,229|(...)]]


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Graficos\Barras.md
### Última modificação: 2024-12-31 01:27:27

---
tags:
  - DataAnalyst
data: 2024-09-10
nivel:
---
# pontos importantes 
É importante que os gráficos de barras sempre tenham uma linha de base zero [[Storytelling com dados.pdf#page=60&selection=6,12,7,13|(...)]] Caso contrário daria uma falsa impressão. 
 
![[Storytelling com dados.pdf#page=60&rect=70,307,338,511|(...)]]
Note que o número inferior no eixo vertical (mostrado na extremidade direita) não é zero, mas 34. Isso significa que as barras, teoricamente, devem continuar para baixo até a parte inferior da página. De fato, do modo como isso está representado, o aumento visual é de 460% (as alturas das barras são 35 – 34 = 1 e 39,6 – 34 = 5,6; assim, (5,6 – 1) / 1 = 460%). Se mostrarmos as barras com uma linha de base zero, de modo que as alturas sejam representadas (35 e 39,6), obteremos um aumento visual real de 13% (39,6 – 35) / 35). Vamos ver em uma comparação lado a lado, na Figura 2.13.[[Storytelling com dados.pdf#page=60|(...)]]

![[Storytelling com dados.pdf#page=61&rect=68,420,298,623|(...)]] diferença de 460%
![[Storytelling com dados.pdf#page=61&rect=316,422,542,624|(...)]] Diferença de 13%

importante reduzir as informações![[Storytelling com dados.pdf#page=61&rect=340,425,495,555|(...)]]
# Tipos de barras
[[Barras verticais]]
[[Barras verticais empilhadas]]
[[Gráfico de cascata]]
[[Barras horizontais]]
[[Barras horizontais empilhadas]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Graficos\Boxplot.md
### Última modificação: 2025-01-02 23:42:02

---
tags: 
data: 2025-01-02
Link: https://www.youtube.com/watch?v=qU2lANG4hYQ
---
# Como interpretar

## Dispersão
### Intervalo interquartílico
A diferença do 1º quartil e 3º [[Quartil|quartil]]
![[Pasted image 20250102233018.png|200]] 3º quartil - 1º quartil = ?
### Amplitude
![[Pasted image 20250102233313.png|200]] valor máximo - valor minimo = ?

## Simetria
![[posição 2.gif|300]]
### Posição
É o local onde está a mediana.
![[posição.gif|200]]
## Caudas
![[Pasted image 20250102233726.png|200]] Essas são as caudas
## Valores discrepantes
 ![[Pasted image 20250102234103.png|200]] Esses são os [[Outliers]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Graficos\Causa e efeito.md
### Última modificação: 2024-12-17 20:38:20

---
tags:
  - Gráfico
  - Conceito
data: 2024-12-17
---
A escolha dos eixos em um gráfico depende da relação de causa e efeito: a **variável independente** (causa) vai no eixo X, pois é o fator que influencia, enquanto a **variável dependente** (efeito) vai no eixo Y, pois reflete as mudanças causadas.
Por exemplo, a idade dos ratos (causa) influencia o peso (efeito), ou o valor gasto em publicidade (causa) afeta o número de vendas (efeito). Sempre analise a relação entre as variáveis para escolher corretamente os eixos. 
![[Elementos de um Bom Gráfico#^b2f879]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Graficos\Conexão.md
### Última modificação: 2024-09-12 16:16:50

---
tags: 
data: 2024-09-12
nivel:
---
A propriedade conectiva normalmente tem um valor associativo mais forte do que cor, tamanho ou forma similar. Como em [[Similaridade]] [[Storytelling com dados.pdf#page=85&selection=22,66,24,34|(...)]]
![[Storytelling com dados.pdf#page=86&rect=69,597,459,679|(...)]]![[Storytelling com dados.pdf#page=86&rect=67,385,445,530|(...)]]


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Graficos\Continuidade.md
### Última modificação: 2024-09-12 16:14:45

---
tags: 
data: 2024-09-12
nivel:
---
![[Storytelling com dados.pdf#page=85&rect=67,588,403,725|(...)]]
Tendemos a continuar como na figura 2 porém pode ser a figura 3
![[Storytelling com dados.pdf#page=85&rect=66,321,189,451|(...)]]
Da para ver que as barras estão alinhadas pelo espaço em branco continuo.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Graficos\Densidade de frequência.md
### Última modificação: 2025-01-02 21:36:52

---
tags:
  - Conceito
  - Gráfico
data: 2025-01-02
Link: https://www.nagwa.com/pt/videos/829194842353/
aliases:
  - Distribuição de frequências
  - Histograma de frequência
---


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Graficos\Diagramas de Venn.md
### Última modificação: 2025-01-04 21:05:46



### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Graficos\Elementos de um Bom Gráfico.md
### Última modificação: 2024-12-17 20:38:10

---
tags:
  - Gráfico
  - Conceito
data: 2024-12-17
---
![[Pasted image 20241217203143.png]] ^b2f879
### Títulos
 Devem ser descritivos e ir além do que já é indicado pelos eixos.
- Exemplo: "Taxa de crescimento dos ratos (Dieta #1)" é melhor que "Peso x Idade".
- Subtítulos podem incluir a conclusão principal do gráfico.
### Eixos
 Legendas claras nos eixos eliminam ambiguidades.
- Unidades devem ser sempre indicadas (ex.: kg, meses, dólares).
- A variável independente (causa) é representada no eixo X, enquanto a dependente (efeito) é no eixo Y.
### Legendas de Gráficos
- Essenciais para gráficos com múltiplos conjuntos de dados.
- Exemplo: No gráfico dos ratos, cores diferentes indicam os dados de cada animal.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Graficos\Exemplo de gráficos.md
### Última modificação: 2024-09-21 19:30:02

---
tags:
  - DataAnalyst
data: 2024-09-13
nivel:
---
# Carga de gráficos
## carga de gráfico

Como diminuir a carga de um gráfico.
![[Storytelling com dados.pdf#page=102&rect=68,268,538,442|400]]
Remova a borda do gráfico, [[Fechamento]][[Storytelling com dados.pdf#page=97&selection=9,3,9,28|(...)]]

![[Storytelling com dados.pdf#page=98&rect=64,463,545,728|400]]
 Remova as linhas de grade[[Storytelling com dados.pdf#page=98&selection=2,2,2,28|(...)]]

![[Storytelling com dados.pdf#page=99&rect=65,470,531,725|400]]
Remova marcadores de dados[[Storytelling com dados.pdf#page=99&selection=2,3,2,29|(...)]]

![[Storytelling com dados.pdf#page=100&rect=61,466,541,730|400]]
Limpe as legendas de eixo[[Storytelling com dados.pdf#page=100&selection=2,3,2,28|(...)]]

![[Storytelling com dados.pdf#page=100&rect=60,83,542,307|400]]
Legende dados diretamente[[Proximidade]] [[Storytelling com dados.pdf#page=101&selection=2,3,2,28|(...)]]

![[Storytelling com dados.pdf#page=101&rect=64,359,538,561|400]]Potencialize cores consistentes [[Similaridade]] [[Storytelling com dados.pdf#page=101&selection=13,3,13,34|(...)]]

![[Storytelling com dados.pdf#page=102&rect=65,530,538,725|400]]



## Pré-atentivos
![[Storytelling com dados.pdf#page=116&rect=66,111,541,370|400]]

![[Storytelling com dados.pdf#page=117&rect=68,344,537,607|400]]

![[Storytelling com dados.pdf#page=118&rect=67,475,539,725|400]]

![[Storytelling com dados.pdf#page=118&rect=70,110,540,368|400]]
## texto 

![[Storytelling com dados.pdf#page=145&rect=66,382,479,638|(...)]]

![[Storytelling com dados.pdf#page=146&rect=69,460,544,722|400]]

# Pré-atentivos
![[Storytelling com dados.pdf#page=113&rect=68,211,540,426|(...)]]![[Storytelling com dados.pdf#page=114&rect=67,346,543,561|(...)]]
![[Storytelling com dados.pdf#page=114&rect=64,76,539,265|(...)]]




### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Graficos\Fechamento.md
### Última modificação: 2024-09-12 16:13:07

---
tags: 
data: 2024-09-12
nivel:
---
 Fechamento diz que as pessoas gostam que as coisas sejam **simples** e se encaixem nas construções que **já estão em nossas mentes**.[[Storytelling com dados.pdf#page=83&selection=9,14,10,68|(...)]]

![[Storytelling com dados.pdf#page=84&rect=69,582,208,722|(...)]]![[Storytelling com dados.pdf#page=84&rect=66,299,434,447|(...)]]


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Graficos\Gráfico de cascata.md
### Última modificação: 2024-12-31 01:28:20

---
tags:
  - DataAnalyst
data: 2024-09-10
nivel:
---
![[Storytelling com dados.pdf#page=65&rect=70,231,541,529|(...)]]
storytellingwithdata.com/waterfall-chart. [[Storytelling com dados.pdf#page=66&selection=11,11,11,52|(...)]]




### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Graficos\Gráfico de dispersão.md
### Última modificação: 2024-09-07 17:49:50

---
tags: 
data: 2024-09-07
nivel:
---
Eles tendem a ser mais usados nos campos científicos[[Storytelling com dados.pdf#page=54&selection=9,44,10,40|(...)]], também existem casos de uso de gráficos de dispersão no mundo dos negócios.[[Storytelling com dados.pdf#page=54&selection=12,27,13,32|(...)]]

![[Storytelling com dados.pdf#page=54&rect=71,257,410,520|(...)]]![[Storytelling com dados.pdf#page=55&rect=69,456,413,722|(...)]]


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Graficos\Gráfico de inclinaçao.md
### Última modificação: 2024-09-29 19:19:52

---
tags: 
data: 2024-09-29
---
![[Storytelling com dados.pdf#page=235&rect=73,229,366,445|400]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Graficos\Gráfico de inclinação.md
### Última modificação: 2024-12-31 01:28:25

---
tags:
  - DataAnalyst
data: 2024-09-10
nivel:
---
No inglês *slopegraghts*
Os gráficos de inclinação são úteis quando você tem dois períodos de tempo ou pontos de comparação e quer mostrar rapidamente os aumentos ou diminuições relativas[[Storytelling com dados.pdf#page=57&selection=5,0,7,21|(...)]]

![[Storytelling com dados.pdf#page=58&rect=70,327,396,676|(...)]]
![[Storytelling com dados.pdf#page=59&rect=70,363,406,722|(...)]]Nossa atenção se volta imediatamente para a diminuição no “Desenvolvimento da carreira”, enquanto o restante dos dados é preservado para contextualizar, sem disputar a atenção.[[Storytelling com dados.pdf#page=59&selection=2,0,4,44|(...)]]



### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Graficos\Gráfico de linhas.md
### Última modificação: 2024-12-31 01:28:29

---
tags:
  - DataAnalyst
data: 2024-09-10
nivel:
---
![[Storytelling com dados.pdf#page=57&rect=67,416,511,723|(...)]]
![[Storytelling com dados.pdf#page=56&rect=71,570,541,722|(...)]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Graficos\Gráfico de Área.md
### Última modificação: 2024-09-11 18:18:18

---
tags: 
data: 2024-09-11
nivel:
---
quando preciso visualizar números de magnitudes amplamente diferentes.[[Storytelling com dados.pdf#page=68&selection=8,25,9,22|(...)]]

![[Storytelling com dados.pdf#page=69&rect=68,519,360,724|(...)]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Graficos\Gráficos de dispersão.md
### Última modificação: 2024-12-18 19:34:52

---
tags:
  - Gráfico
data: 2024-12-18
Link: https://tripleten.com/trainer/data-analyst/lesson/d491db3a-7b32-48d6-ba36-29980aad8d1e/task/9efee7dd-76ff-4069-95f1-fd4717a4dbdb/
---
![[Pasted image 20241218192556.png|200]]Um [[01 - Progetos/Anki/Gráfico]] de dispersão é um gráfico que utiliza pontos para mostrar a relação entre duas variáveis numéricas.

**Para que serve:**

- Identificar padrões, tendências e [[Coeficiente de correlação linear|correlações]] entre variáveis.
- Detectar [[Outliers]] (valores fora do padrão).
- Visualizar a intensidade e direção de uma relação (positiva, negativa ou inexistente).

**Para que não serve:**

- Não é adequado para variáveis categóricas.
- Não explica causalidade, apenas mostra correlação.
- Não é útil para grandes volumes de dados sobrepostos, que dificultam a leitura.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Graficos\Gráficos ruins.md
### Última modificação: 2024-12-17 21:00:36

---
tags:
  - Gráfico
  - Conceito
data: 2024-12-17
---
Uso desnecessário do eixo X
Gráfico de pizza sem sentido
Gráfico de barras enganoso
Sobrecarga de informação
Gráfico de linha enganoso
Uso confuso de cor
[[Como mentir com estatística - Auto (Darrell-Heff).pdf]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Graficos\Histograma.md
### Última modificação: 2024-12-20 19:28:58

---
tags:
  - Gráfico
data: 2024-12-18
---
O histograma é um gráfico de barras onde o eixo Y representa a frequência (quantidade de repetições) dos valores agrupados em intervalos (`bins=`) no eixo X
![[cvb.gif]]


```python
df.hist(column='height')
df['height'].hist()
df['height'].plot(kind='hist')
```
![[Pasted image 20241220192721.png|200]]
# [[Matrizes de dispersão|Matriz]] de histograma
Feito pelo código [[,hist]] ele fiz vários histogramas de todos os dados numéricos do [[DataFrame]].

```python
df.hist()
```
![[Pasted image 20241218233045.png|200]]

São os mesmos dados da diagonal da 
![[Matrizes de dispersão#^2dfd42]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Graficos\Linhas.md
### Última modificação: 2024-09-12 00:16:03

---
tags:
  - "#DataAnalyst"
data: 2024-09-07
nivel:
---
[[Gráfico de linhas]]
[[Gráfico de inclinação]]


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Graficos\Mapa de calor.md
### Última modificação: 2024-09-07 17:42:25

---
tags: 
data: 2024-09-07
nivel:
---
![[Storytelling com dados.pdf#page=52&rect=71,342,542,513|(...)]]
Use uma legenda <font color="#c6d9f0">Baixo</font> <font color="#548dd4">Alto</font>[[Storytelling com dados.pdf#page=53&selection=3,4,8,9|(...)]]



### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Graficos\Matrizes de dispersão.md
### Última modificação: 2024-12-18 23:37:14

---
tags:
  - Conceito
data: 2024-12-18
---
É uma matriz com vários [[Gráficos de dispersão]] porém com todas as colunas com [[Dados numéricos]].

![[Pasted image 20241218195753.png|400]] ^2dfd42

A imagem é uma matriz de dispersão 4x4 onde:
1. **Diagonal principal**: Histogramas que mostram a distribuição individual de cada variável. Por exemplo, o primeiro gráfico (altura) revela que a maioria dos valores está entre 64 e 68 polegadas.
2. **Relações altura-peso**: Nos gráficos ao lado do histograma, há uma forte correlação positiva (cerca de 0,9), representada por pontos alinhados em uma direção ascendente.
3. **Relações idade-altura e idade-peso**: Há ampla dispersão, indicando pouca ou nenhuma correlação entre idade e altura (cerca de 0,01), mas uma ligeira correlação positiva com peso.
4. **Relação sexo e outras variáveis**: Valores de sexo (0 para feminino e 1 para masculino) mostram correlações positivas com altura e peso, mas nenhuma com idade.


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Graficos\Pontos.md
### Última modificação: 2024-12-31 01:29:40

---
tags:
  - DataAnalyst
  - Aprendizado
data: 2024-09-07
nivel:
---
[[Gráfico de dispersão]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Graficos\Princípios da Gestalt.md
### Última modificação: 2024-09-12 17:53:47

---
tags: 
data: 2024-09-12
nivel:
---
![[userlmn_8fc1b2d9548c7ad544978773fd1e9898.jpg]]O princípio da Gestalt que definem como as pessoas interagem e produzem ordem a partir de estímulos visuais.[[Storytelling com dados.pdf#page=80&selection=20,38,21,47|(...)]] [[Proximidade]], [[Similaridade]], [[Acercamento]], [[Fechamento]], [[Continuidade]] e [[Conexão]].

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Graficos\Proximidade.md
### Última modificação: 2024-09-12 16:06:07

---
tags: 
data: 2024-09-12
nivel:
---
![[Storytelling com dados.pdf#page=81&rect=67,593,204,723|(...)]]
Cria a impressão de 3 grupos.
![[Storytelling com dados.pdf#page=81&rect=69,343,457,481|(...)]]
Só das colunas juntas parece que esta separado por colunas e quando linhas juntas parece q esta separado por linhas.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Graficos\Similaridade.md
### Última modificação: 2024-09-12 16:07:30

---
tags: 
data: 2024-09-12
nivel:
---
![[Storytelling com dados.pdf#page=82&rect=68,581,399,724|(...)]]
Cores ou formatos específicos criam uma junção visual. 
![[Storytelling com dados.pdf#page=82&rect=68,305,282,458|(...)]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Graficos\Sites.md
### Última modificação: 2024-09-30 15:31:31

---
tags: 
data: 2024-09-29
---
Eager Eyes[[Storytelling com dados.pdf#page=242&selection=35,0,35,10|(...)]] https://eagereyes.org/
FiveThirtyEight’s Data Lab  https://data.fivethirtyeight.com/
Flowing Data
The Functional Art
The Guardian Data Blog
HelpMeViz
Junk Charts
Junk Charts
Make a Powerful Point
Perceptual Edge
Visualising Data
VizWiz
storytelling with data
WTF Visualizations





### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Graficos\Tabela.md
### Última modificação: 2024-12-31 01:30:20

---
tags:
  - DataAnalyst
data: 2024-09-07
nivel:
---
Bom para publicos mistos pois cada um vera a parte da tebela que o interessa. Porém raramente é uma boa ideia usar uma tabela em uma apresentação ao vivo.[[Storytelling com dados.pdf#page=51&selection=2,0,2,70|(...)]]

Use bordas mínimas para que não chame atenção.[[Storytelling com dados.pdf#page=51&selection=10,0,14,23|(...)]]




### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Graficos\Texto simples.md
### Última modificação: 2024-09-07 17:17:35

---
tags: 
data: 2024-09-07
nivel:
---
Texto simples Quando você tem apenas um número ou dois para compartilhar, um simples texto pode ser uma ótima maneira de comunicar.[[Storytelling com dados.pdf#page=48&selection=0,13,3,46|(...)]]

![[Storytelling com dados.pdf#page=49&rect=74,447,331,721|(...)]]
![[Storytelling com dados.pdf#page=50&rect=71,568,318,721|(...)]]


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Graficos\Uso de animação nos visuais apresentados.md
### Última modificação: 2024-09-26 16:29:10

---
tags:
  - DataAnalyst
data: 2024-09-26
---
Neste capitulo o autos explique que mostrar os dados pouco a pouco e explicar tem varias vantagens.[[Storytelling com dados.pdf#page=205&selection=6,18,7,24|(...)]]



### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Linkedln\Exemplo de postes.md
### Última modificação: 2025-01-16 23:54:28

---
tags: 
data: 2024-12-06
---
# cap

## O que deve ter nos posts
Como isso se relaciona na minha area?
E dai?


## Atributo, Metodo, Função e Instrução
## Importância do Gráfico
## Onde está python na história
## Onde está pandas na história
## Análise Descritiva e diagnostica
## Pré-processamento 
#### Valores nulos
#### Remoção de duplicatas
#### Conversão de tipos de dados
#### Normalização
#### Criação de novas colunas
## Mascara booleana
### 🔍 O Poder das Máscaras Booleanas no Pandas

Já ouviu falar em **máscaras booleanas** no Pandas? Elas são uma ferramenta poderosa para filtrar dados de maneira eficiente e intuitiva.

💡 **O que é uma máscara booleana?**  
É um conjunto de valores `True` ou `False` que indica quais linhas (ou colunas) de um DataFrame devem ser selecionadas com base em uma condição.

Formas de usar a máscara booleana: 
`DataFrame.loc[]` para seleção de linhas ou colunas com base em condições,  
`DataFrame.iloc[]` para manipulação condicional em índices específicos,  
`DataFrame[mascara]` para filtrar linhas diretamente usando uma condição,  
`DataFrame.where()` para substituir valores que não atendem à condição,  
`DataFrame.mask()` para substituir valores que atendem à condição,  
`DataFrame.query()` para aplicar condições booleanas em formato de string,  
`DataFrame.drop()` para remover linhas ou colunas com base em condições,  
`DataFrame.isin()` para verificar a presença de valores específicos,  
`DataFrame.duplicated()` para identificar valores duplicados,  
`DataFrame.drop_duplicates()` para remover duplicatas com base em condições booleanas.
![[Pasted image 20241206201612.png]]
![[Pasted image 20241206204401.png]]



## Types no dataframe
Você sabia que o **Pandas**, uma das bibliotecas mais populares para análise de dados em Python, tem tipos de dados próprios? Embora eles sejam semelhantes aos tipos nativos do Python, a **nomenclatura** muda e há alguns detalhes importantes que podem ajudar no seu trabalho com dados!
![[Pasted image 20241206201354.png]]


# 2
## [[DMA vx Variância]]

# sprint
##### Sprint1

##### Sprint2
##### Sprint3
##### Sprint4
##### Sprint5
##### Sprint6
##### Sprint7
##### Sprint8
##### Sprint9
##### Sprint0


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Linkedln\linkedin.md
### Última modificação: 2024-09-04 01:10:30

---
tags: 
data: 2024-08-31
nivel:
---
- [ ] Analizar as coisas que eu posso por na home
- [x] pesquisar se pode postar em varias linguas
- [x] Postar sobre o multipesquisador
- [ ] Traduzir as coisas que ja fiz para o inglÊs
	- [ ] multpesquisador. 
- [x] tirar a foto 
	editar e colocar nos perfis([[linkedin]][[Github]])
- [x] Decidir capa
- [ ] recomendações de competencias
- [ ] Postar o resumidor.
- [ ] 


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Linkedln\Network.md
### Última modificação: 2024-09-21 23:33:01

---
tags:
  - Networking
data: 2024-09-21
---
### Apresentação Pessoal
Fazer varias apresentações pessoais com tons diferentes
### Comentários
- Insights Pessoais: Compartilhe uma experiência pessoal relacionada ao tema do post, como um projeto que você fez ou um desafio que superou.
- Perguntas: Faça perguntas que incentivem a discussão.
- Estatísticas ou Dados: Adicione dados ou estatísticas relevantes 
- Recomendações de Leitura: Sugira livros, artigos ou vídeos que você achou interessantes e que se relacionam com o tema do post.
- Reconhecimento: Elogie o autor do post por suas ideias ou pelo conteúdo compartilhado, mencionando como isso impactou sua perspectiva.
- Conexões com Outros Temas: Relacione o conteúdo do post a outros tópicos que você conhece.
- Casos Práticos: Se você conhece um caso de sucesso que se alinha ao que foi discutido, compartilhe brevemente como isso se aplica na prática.
- Opiniões Divergentes: Se você tiver uma opinião diferente, expresse-a de forma respeitosa, explicando seu ponto de vista e incentivando um **diálogo**.
### Assunto
**Interesse em Conexões**: Pergunte se eles estariam dispostos a compartilhar experiências na área
**Pedidos de Dicas**: Pergunte se eles têm dicas para quem está começando na área ou sobre como se destacar em processos seletivos.
**Agradecimento**: Se você já interagiu com o conteúdo deles, uma simples mensagem de agradecimento pelo que compartilharam pode ser uma boa forma de iniciar uma conversa.
**Eventos**

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Linkedln\perguntas.md
### Última modificação: 2024-10-16 00:05:31

- **Caminho na Carreira**: "Você poderia compartilhar como foi o início da sua carreira em Ciência de Dados/Análise de Dados? Quais foram os principais desafios que enfrentou?"
    
- **Habilidades Importantes**: "Na sua opinião, quais são as habilidades mais importantes que um Analista/Cientista de Dados deve dominar atualmente?"
    
- **Ferramentas**: "Quais ferramentas ou linguagens de programação você considera essenciais para alguém que está começando na área de Ciência de Dados?"
    
- **Aprendizado Contínuo**: "Como você continua aprendendo e se mantendo atualizado com as novas tendências e tecnologias em Ciência de Dados?"
    
- **Projetos Impactantes**: "Você poderia me falar sobre um projeto em Ciência de Dados que teve grande impacto na sua organização? Quais foram as principais lições que aprendeu?"
    
- **Erros Comuns**: "Quais são os erros mais comuns que você vê profissionais de Ciência de Dados cometerem, especialmente aqueles no início de suas carreiras?"
    
- **Conselhos**: "Que conselho você daria para alguém que está buscando uma transição de carreira para Ciência de Dados?"
    
- **Certificações**: "Você acha que certificações em Ciência de Dados são importantes? Se sim, quais você recomendaria?"
    
- **Networking**: "Qual foi a sua estratégia para construir uma rede de contatos relevante na área de Ciência de Dados? Alguma dica para melhorar meu networking?"
    
- **Oportunidades no Mercado**: "Como você vê o mercado de Ciência de Dados no Brasil? Quais setores estão contratando mais e o que eles buscam em candidatos?"

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Linkedln\Sem título 1.md
### Última modificação: 2025-01-07 19:15:31



### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Linkedln\Sem título.md
### Última modificação: 2024-10-16 00:49:25

### Análise de Dados:

1. **Comparação de Ferramentas de Análise de Dados**: Compartilhe uma análise comparando ferramentas como Python, Power BI e Excel para diferentes tipos de projetos.
2. **Visualizações Impactantes**: Mostre exemplos de visualizações de dados que você criou e explique como elas facilitam a tomada de decisões.
3. **Estudo de Caso**: Conte sobre um projeto específico onde você usou análise de dados para solucionar um problema real.
4. **Dicas de Limpeza de Dados**: Compartilhe dicas e truques de como você limpa e organiza grandes volumes de dados.
5. **Aplicação de Machine Learning**: Explique como técnicas simples de machine learning podem ser aplicadas em projetos pequenos.
6. **Análise de Dados em Logística**: Mostre como sua experiência em Logística pode ser combinada com análise de dados para melhorar processos operacionais.
7. **Geopandas e Análises com Mapas**: Poste sobre seu aprendizado com GeoPandas e como ele pode ser útil para visualizar dados geoespaciais.
8. **Diferença entre Análise Descritiva e Preditiva**: Explique as diferenças e aplicações de cada uma em projetos práticos.

### Sustentabilidade:

9. **Impacto dos Dados na Sustentabilidade**: Como dados podem ajudar a medir o impacto ambiental de políticas públicas, como o NitBike.
10. **Análise de Emissões de CO2 em Niterói**: Crie uma análise sobre como os dados podem ser usados para medir a emissão de gases poluentes em diferentes bairros da cidade.
11. **Projetos Sustentáveis com Análise de Dados**: Compartilhe ideias de como dados podem ser usados para criar soluções sustentáveis em empresas.
12. **Energia Renovável e Dados**: Discuta como dados podem ajudar a otimizar o uso de energia renovável, como a solar e eólica.
13. **Tecnologia e Mobilidade Sustentável**: Faça uma análise de dados sobre o uso de transporte sustentável em sua cidade, usando o exemplo do NitBike.

### SQL e Programação:

14. **Funções SQL para Manipulação de Datas**: Explique como funções de data em SQL podem ser usadas para relatórios mais precisos.
15. **Boas Práticas em SQL**: Compartilhe boas práticas de escrita de queries em SQL para quem está começando.
16. **Criação de Dashboards Automatizados com Python e SQL**: Mostre como você pode integrar Python e SQL para criar relatórios automáticos.
17. **Erros Comuns ao Trabalhar com SQL**: Poste sobre os erros mais comuns que você encontrou ao trabalhar com bancos de dados e como evitá-los.

### Interesses Pessoais:

18. **Dificuldade com Filés Empanados**: Continue com a série de posts leves e divertidos sobre sua dificuldade em diferenciar filés de peixe e frango. A interação pode ser uma oportunidade para se conectar de maneira descontraída com sua rede.
19. **Lições de Leitura de Livros**: Compartilhe lições que você está aprendendo ao analisar livros, como "Alice no País das Maravilhas" ou "O Pequeno Príncipe".
20. **Storytelling com Dados**: Dê exemplos práticos de como você aplicou técnicas de storytelling para criar narrativas de dados impactantes em suas análises.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Linkedln\Torne-se parceiro do contato.md
### Última modificação: 2024-09-18 22:55:13

---
tags:
  - Networking
data: 2024-09-18
nivel:
---
1. Apresentar o contato a uma nova pessoa: 
2. Se houver abertura, compartilhar fatos interessantes sobre o contato
3. Enviar artigos ou links úteis
4. Convidar para eventos ou encontros profissionais
5. Oferecer ajuda em pequenos projetos ou tarefas
6. Solicitar conselhos ou feedback
7. Acompanhar com regularidade
8. Recomendar o contato em oportunidades de trabalho ou negóciosr

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Linkedln\nãosei\O que as empresas querem de mim.md
### Última modificação: 2025-01-17 20:47:31

---
tags: 
data: 2025-01-17
---
**Proporção de vagas escritas em inglês:**

Aproximadamente 50% dos anúncios analisados foram escritos, total ou parcialmente, em inglês.

**Quantas pedem efetivamente inglês:**

Várias vagas explicitam a necessidade de "inglês fluente" (variando de "fluência" a "inglês avançado"), o que demonstra a importância da língua para a comunicação e a interação em contextos internacionais. Não existe um número exato de vagas que pedem inglês, pois a descrição não é sempre explícita.

**Quais são os requisitos mais pedidos, para a vaga?**

Os requisitos mais recorrentes nas vagas de Data Analyst são:

- Conhecimento em SQL: Essencial para a extração e manipulação de dados.
- Excel Avançado: Importante para a manipulação e análise de dados.
- Power BI ou Tableau: Ferramentas de visualização e análise de dados.
- Python ou R: Linguagens de programação para modelagem e análise.
- Habilidades analíticas e de resolução de problemas: Essenciais para a interpretação e extração de insights a partir dos dados.
- Comunicação eficaz: Essencial para a comunicação das análises e insights para as equipes e stakeholders.
- Graduação em áreas quantitativas: Estatística, Computação, Engenharias, Matemática, entre outros.
- Experiência com Data Analytics: Diversos anúncios buscam candidatos com experiência prévia em análise de dados.
- Conhecimentos em Machine Learning/Inteligência Artificial: Um requisito cada vez mais comum, refletindo a crescente importância da IA no mercado de trabalho.

**Quais são os benefícios mais ofertados nas vagas?**

Os benefícios mais frequentes nos anúncios analisados são:

- Assistência médica: Plano de saúde (e odontológico em alguns casos).
- Vale alimentação/refeição: Benefícios de alimentação para colaboradores.
- Vale Transporte: Remuneração do transporte.
- Previdência Privada: Benefícios para a aposentadoria.
- Gympass: Acordo com empresas de ginástica para acesso a academias.
- PLR (Participação nos Lucros ou Resultados): Remuneração variável.
- Licenças maternidade/paternidade: Tempo para cuidar de familiares.
- Auxílio Creche/Babá: Ajuda financeira para cuidar dos filhos.
- Outros: Cartão-presente, programas de desenvolvimento profissional (cursos, workshops), treinamentos.

#### **Sobre tecnologia conte quantas vezes as palavras e termos que referenciam tecnologias aparecem e discrimine pra mim?**

Frequência Alta (citadas em muitas vagas):
	SQL, Excel, Power BI, Tableau
Frequência Média (citadas em diversas vagas):
	Python, R, Power Automate, SAS
Frequência Baixa (citadas em poucas vagas):
	Azure, Databricks, GCP (Google Cloud Platform) e BigQuery, Jira, Snowflake, SQL Server e MariaDB

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Livros\Big Data 2.0.md
### Última modificação: 2024-10-02 16:07:41

---
tags:
  - DataAnalyst
  - Datascience
data: 2024-10-02
---
A [[Mineração de Dados|mineração de dados]] é uma técnica crucial dentro do [[Big Data]] 2.0, este último é um conceito mais amplo que engloba todo o ciclo de vida dos dados, desde a coleta até a análise e aplicação dos insights obtidos.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Livros\Big Data vx mineração de dados.md
### Última modificação: 2024-10-02 15:42:47

---
tags:
  - DataAnalyst
  - Datascience
data: 2024-10-02
---
[[Big Data]] é um conceito amplo que abrange a **coleta**, **armazenamento**, e **processamento** de grandes volumes de dados. [[Mineração de Dados]] é uma **etapa específica** dentro do processo de Big Data, focada em **analisar** os dados para encontrar padrões e gerar insights.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Livros\correlações.md
### Última modificação: 2024-10-04 17:58:33

## Relacionando Capítulos de "Storytelling com Dados" e "Data Science para Negócios"

**Capítulo 1: A importância do contexto**

- **Descrição do capítulo:** Enfatiza a necessidade de entender o contexto da comunicação antes de visualizar os dados, incluindo o público-alvo, a ação desejada e o tom da mensagem.
    
- **Capítulos relacionados em Data Science para Negócios:**
    
    - **Capítulo 1: Introdução: Pensamento Analítico de Dados (Páginas 32-35):** Aborda a importância de compreender o problema de negócios e como data science pode agregar valor. Discute a necessidade de formular perguntas claras e definir metas para a mineração de dados.
        
    - **Capítulo 2: Problemas de Negócios e Soluções de Data Science (Páginas 65-67):** Enfatiza a importância de definir o problema de negócio de forma clara e precisa para direcionar a análise de dados e evitar soluções que não atendam às necessidades reais.
        
    - **Capítulo 7: Decisão do Pensamento Analítico I: O que é um Bom Modelo? (Páginas 157-158):** Discute a importância de definir a meta da mineração de dados e como escolher a função objetiva adequada para otimizar o modelo aos dados, tendo em vista a aplicação de negócios.
        
- **Conceitos relacionados:**
    
    - **Público-alvo:** "Storytelling" (Página 31), "Data Science" (Páginas 32, 66)
        
    - **Ação desejada:** "Storytelling" (Página 33), "Data Science" (Páginas 67, 157)
        
    - **Tom da mensagem:** "Storytelling" (Página 36), "Data Science" (Página 22)
        

**Capítulo 2: A escolha de um visual eficaz**

- **Descrição do capítulo:** Apresenta os tipos mais comuns de visualizações de dados e seus casos de uso apropriados, com exemplos do mundo real.
    
- **Capítulos relacionados em Data Science para Negócios:**
    
    - **Capítulo 8: Visualização do Desempenho do Modelo (Páginas 171-184):** Discute a importância de visualizar o desempenho do modelo em diferentes tipos de incerteza e apresenta técnicas como curvas de lucro, curvas de resposta cumulativa, curvas de elevação (lift) e curvas ROC.
        
- **Conceitos relacionados:**
    
    - **Gráficos de linha:** "Storytelling" (Páginas 54-58), "Data Science" (Páginas 177-184)
        
    - **Gráficos de barras:** "Storytelling" (Páginas 58-67), "Data Science" (Página 103)
        
    - **Gráficos a serem evitados:** "Storytelling" (Páginas 69-74), "Data Science" (Página 20)
        
    - **Uso apropriado de gráficos:** "Storytelling" (Página 77), "Data Science" (Páginas 65-76)
        

**Capítulo 3: A saturação é sua inimiga!**

- **Descrição do capítulo:** Explica o conceito de saturação visual e como ela pode prejudicar a comunicação com dados. Apresenta os Princípios da Gestalt e como aplicá-los para eliminar a saturação e melhorar a clareza da mensagem.
    
- **Capítulos relacionados em Data Science para Negócios:**
    
    - **Capítulo 2: Problemas de Negócios e Soluções de Data Science (Páginas 82-83):** Aborda a importância da preparação dos dados e a necessidade de eliminar informações irrelevantes e redundantes para que os dados rendam melhores resultados.
        
    - **Capítulo 5: O Sobreajuste e Como Evitá-lo (Páginas 105-106):** Discute a necessidade de simplificar modelos e evitar a inclusão de informações que não contribuam para a generalização, o que pode ser considerado saturação em termos de complexidade do modelo.
        
- **Conceitos relacionados:**
    
    - **Saturação visual:** "Storytelling" (Página 79), "Data Science" (Página 83)
        
    - **Princípios da Gestalt:** "Storytelling" (Página 80), "Data Science" (Página 86, implicitamente)
        
    - **Alinhamento:** "Storytelling" (Página 88), "Data Science" (Página 83)
        
    - **Espaço em branco:** "Storytelling" (Página 90), "Data Science" (Página 86)
        
    - **Contraste:** "Storytelling" (Página 92), "Data Science" (Página 20)
        

**Capítulo 4: Focalize a atenção de seu público**

- **Descrição do capítulo:** Enfatiza como usar os atributos pré-atentivos para direcionar a atenção do público para os pontos importantes da visualização e criar uma hierarquia visual de informações.
    
- **Capítulos relacionados em Data Science para Negócios:**
    
    - **Capítulo 5: O Sobreajuste e Como Evitá-lo (Página 106):** Discute a importância de formar grupos de informações maiores e coerentes para facilitar o processamento pelo público.
        
    - **Capítulo 8: Visualização do Desempenho do Modelo (Páginas 173-176):** Aborda a importância de usar recursos visuais para destacar informações importantes e tornar a interpretação dos dados mais fácil para o público.
        
- **Conceitos relacionados:**
    
    - **Atributos pré-atentivos:** "Storytelling" (Página 107), "Data Science" (Página 176)
        
    - **Hierarquia visual:** "Storytelling" (Página 112), "Data Science" (Página 88)
        
    - **Cor:** "Storytelling" (Página 119), "Data Science" (Páginas 20, 121)
        
    - **Tamanho:** "Storytelling" (Página 119), "Data Science" (Página 89)
        
    - **Posição na página:** "Storytelling" (Página 127), "Data Science" (Página 89)
        

**Capítulo 5: Pense como um designer**

- **Descrição do capítulo:** Apresenta conceitos de design, como affordances, acessibilidade e estética, e como aplicá-los à comunicação com dados. Discute estratégias para obter a aceitação do público para os designs visuais.
    
- **Capítulos relacionados em Data Science para Negócios:**
    
    - **Capítulo 2: Problemas de Negócios e Soluções de Data Science (Página 86):** Enfatiza a importância de comunicar claramente a mensagem ao público e a necessidade de tornar as visualizações de dados acessíveis e compreensíveis.
        
- **Conceitos relacionados:**
    
    - **Affordances:** "Storytelling" (Página 129), "Data Science" (Página 141, implicitamente)
        
    - **Acessibilidade:** "Storytelling" (Página 140), "Data Science" (Página 86)
        
    - **Estética:** "Storytelling" (Página 146), "Data Science" (Página 22)
        
    - **Aceitação do público:** "Storytelling" (Página 150), "Data Science" (Página 20, implicitamente)
        

**Capítulo 6: Dissecagem de modelos visuais**

- **Descrição do capítulo:** Examina cinco modelos visuais eficazes, discutindo o processo de pensamento e as escolhas de design que levaram à sua criação.
    
- **Capítulos relacionados em Data Science para Negócios:**
    
    - **Capítulo 2: Problemas de Negócios e Soluções de Data Science (Páginas 76-85):** Apresenta o processo de mineração de dados, incluindo modelagem, avaliação e implantação, com exemplos de como diferentes modelos podem ser utilizados para resolver problemas de negócios.
        
    - **Capítulo 3: Introdução à Modelagem Preditiva: Da Correlação à Segmentação Supervisionada (Páginas 104-113):** Discute como selecionar atributos informativos e segmentar dados de forma supervisionada, o que é fundamental para a construção de modelos visuais eficazes.
        
- **Conceitos relacionados:**
    
    - **Ordenação dos dados:** "Storytelling" (Página 167), "Data Science" (Páginas 88, 112)
        
    - **Uso de cores:** "Storytelling" (Página 163), "Data Science" (Páginas 20, 121)
        
    - **Tamanho relativo:** "Storytelling" (Página 163), "Data Science" (Página 89)
        
    - **Uso de texto:** "Storytelling" (Página 163), "Data Science" (Página 142)
        

**Capítulo 7: Lições sobre storytelling**

- **Descrição do capítulo:** Apresenta conceitos de storytelling que podem ser aplicados à comunicação com dados. Discute a estrutura da narrativa, o poder da repetição e as diferenças entre narrativa falada e escrita.
    
- **Capítulos relacionados em Data Science para Negócios:**
    
    - **Capítulo 1: Introdução: Pensamento Analítico de Dados (Página 22):** Menciona a importância de comunicar as descobertas de data science de forma eficaz e como uma visualização de dados eficaz pode ajudar a contar uma história convincente.
        
    - **Capítulo 13: Data Science e Estratégia de Negócios (Página 203):** Enfatiza a necessidade de comunicação clara entre cientistas de dados e stakeholders do negócio, o que inclui a capacidade de contar uma história com dados.
        
- **Conceitos relacionados:**
    
    - **Estrutura da narrativa:** "Storytelling" (Página 167), "Data Science" (Páginas 171-172)
        
    - **Repetição:** "Storytelling" (Página 178), "Data Science" (Página 20)
        
    - **Narrativa falada e escrita:** "Storytelling" (Páginas 176-177), "Data Science" (Página 34)
        

**Capítulo 8: Tudo reunido**

- **Descrição do capítulo:** Apresenta um exemplo completo de storytelling com dados, do início ao fim, aplicando todas as lições abordadas nos capítulos anteriores.
    
- **Capítulos relacionados em Data Science para Negócios:**
    
    - **Capítulo 2: Problemas de Negócios e Soluções de Data Science (Páginas 65-89):** Apresenta o processo de mineração de dados como um guia abrangente para a aplicação de data science, que pode ser utilizado para orientar o processo de storytelling com dados.
        
- **Conceitos relacionados:**
    
    - **Processo completo de storytelling:** "Storytelling" (Página 184), "Data Science" (Páginas 65-89)
        
    - **Identificar o contexto:** "Storytelling" (Página 185), "Data Science" (Página 66)
        
    - **Escolher o visual:** "Storytelling" (Página 186), "Data Science" (Páginas 65-76)
        
    - **Eliminar a saturação:** "Storytelling" (Página 191), "Data Science" (Página 83)
        
    - **Focalizar a atenção:** "Storytelling" (Página 192), "Data Science" (Página 176)
        
    - **Pensar como um designer:** "Storytelling" (Página 195), "Data Science" (Página 141)
        
    - **Contar uma história:** "Storytelling" (Página 196), "Data Science" (Página 22)
        

**Capítulo 9: Estudos de caso**

- **Descrição do capítulo:** Explora estratégias para enfrentar desafios comuns na comunicação com dados, por meio de vários estudos de caso.
    
- **Capítulos relacionados em Data Science para Negócios:**
    
    - **Capítulo 5: O Sobreajuste e Como Evitá-lo (Páginas 105-139):** Aborda estratégias para evitar o sobreajuste, um desafio comum na comunicação com dados, que é detalhado nos estudos de caso do livro "Storytelling com Dados".
        
    - **Capítulo 11: Decisão do Pensamento Analítico II: Rumo à Engenharia Analítica (Páginas 246-264):** Discute a importância de formular o problema de data science de forma clara e precisa, o que pode ajudar a evitar os desafios encontrados nos estudos de caso do livro "Storytelling com Dados".
        
- **Conceitos relacionados:**
    
    - **Cor em fundo escuro:** "Storytelling" (Página 202), "Data Science" (Página 20, implicitamente)
        
    - **Animação:** "Storytelling" (Página 205), "Data Science" (Página 88, implicitamente)
        
    - **Lógica na ordem:** "Storytelling" (Página 213), "Data Science" (Página 88)
        
    - **Gráfico espaguete:** "Storytelling" (Página 223), "Data Science" (Páginas 86, 106)
        
    - **Gráficos de pizza:** "Storytelling" (Página 231), "Data Science" (Página 70)
        

**Capítulo 10: Considerações finais**

- **Descrição do capítulo:** Discute dicas para o futuro da comunicação com dados, como aprimorar as habilidades de storytelling com dados em uma equipe e recapitular as principais lições abordadas no livro.
    
- **Capítulos relacionados em Data Science para Negócios:**
    
    - **Capítulo 13: Data Science e Estratégia de Negócios (Páginas 201-209):** Aborda estratégias para desenvolver a competência em data science em uma equipe e como construir uma cultura que valorize a comunicação com dados.
        
    - **Capítulo 14: Conclusão (Páginas 265-266):** Recapitula os conceitos fundamentais de data science e a importância da comunicação clara e eficaz com dados.
        
- **Conceitos relacionados:**
    
    - **Desenvolver competência em storytelling:** "Storytelling" (Página 245), "Data Science" (Páginas 201-209)
        
    - **Cultura de data science:** "Storytelling" (Página 245), "Data Science" (Página 203)
        
    - **Recapitulação das lições:** "Storytelling" (Página 248), "Data Science" (Página 265)

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Livros\Métodos Supervisionados vx Não Supervisionados.md
### Última modificação: 2024-10-07 17:49:42

---
tags:
  - DataAnalyst
  - Datascience
data: 2024-10-07
---
A primeira é: “Nossos clientes naturalmente se encaixam em grupos diferentes?” Aqui, nenhuma proposta, ou alvo, em particular foi especificada para o agrupamento. Quando **não** existe tal alvo, o problema de mineração de dados é chamado de **não supervisionado**. Compare isso com uma pergunta ligeiramente diferente: “Podemos encontrar grupos de clientes que tenham probabilidades particularmente elevadas de cancelar seus serviços logo após o vencimento de seus contratos?” Aqui há um **alvo específico** definido: será que um cliente abandonará o serviço quando seu contrato vencer? Neste caso, a segmentação está sendo feita por um motivo específico: tomar medidas com base na probabilidade de rotatividade. Isso é chamado de problema **supervisionado** de mineração de dados.[[Data Science para Negócios.pdf#page=74&selection=26,0,58,22|(...)]]



### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Livros\Porque não é manual mas.md
### Última modificação: 2024-10-05 20:48:20

---
tags:
  - DataAnalyst
  - Datascience
data: 2024-10-05
---
Agora, com grandes quantidades de dados disponíveis, as empresas em quase todos os setores estão focadas em explorá-los para obter vantagem competitiva. No passado, as empresas podiam contratar equipes de estatísticos, modeladores e analistas para explorar manualmente os conjuntos de dados, mas seu volume e variedade superaram muito a capacidade da análise manual. Ao mesmo tempo, os computadores se tornaram muito mais poderosos, a comunicação em rede é onipresente, e foram desenvolvidos algoritmos que podem conectar conjuntos de dados para permitir análises muito mais amplas e profundas do que antes. [[Data Science para Negócios.pdf#page=33&selection=2,0,59,1|(...)]]



### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Livros\Publico.md
### Última modificação: 2024-10-05 20:38:38

---
tags:
  - DataAnalyst
  - Datascience
data: 2024-10-05
---
Um dos conseitos de data science[[Data Science para Negócios.pdf#page=21&selection=27,54,31,54|(...)]]



### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Livros\Storytelling.md
### Última modificação: 2024-09-25 18:30:35

---
tags:
  - DataAnalyst
data: 2024-09-24
---
# Coisas a fazer
Eu o conduzo por exercícios para ajudá-lo a enunciar a Grande Ideia e a história de 3 minutos que discutimos no Capítulo 1. Por quê? Preciso ter um sólido entendimento do que ele quer comunicar antes de elaborar a comunicação. Uma vez articuladas a Grande Ideia e a história de 3 minutos, ele pode começar a pensar em qual fluxo de narrativa faz sentido e em como organizar sua pilh[[Storytelling com dados.pdf#page=175&selection=15,62,20,40|(...)]]


## Grande ideia
## Historia em 3 minutos
# Inicio
1. O ambiente: quando e onde a história ocorre? 
2. O personagem principal: quem está conduzindo a ação? (Isso deve ser enquadrado de acordo com seu público!) 
3. O desequilíbrio: por que é necessário, o que mudou? 
4. O equilíbrio: o que você quer que aconteça? 
5. A solução: como você vai provocar as mudanças?[[Storytelling com dados.pdf#page=171&selection=37,0,42,49|(...)]]
# Meio 
- Desenvolva melhor a situação ou problema, abordando as informações relevantes. 
- Incorpore o contexto externo ou pontos de comparação. 
- Dê exemplos que ilustrem a questão. 
- Inclua dados que demonstrem o problema. 
- Enuncie o que acontecerá se nenhuma ação for adotada ou nenhuma mudança for feita. 
- Discuta possíveis opções para tratar do problema. 
- Ilustre as vantagens de sua solução recomendada. 
- Torne claro para seu público por que ele está em uma posição privilegiada para tomar uma decisão ou adotar uma ação.[[Storytelling com dados.pdf#page=173&selection=0,66,32,55|(...)]]
# Fim
 Termine com uma **chamada para ação**: torne totalmente claro para seu público o que você quer que ele faça com o novo entendimento ou conhecimento transmitido. [[Storytelling com dados.pdf#page=174&selection=0,39,8,53|(...)]]

# Fluxo narrativo 
- Trata-se de um público ocupado, que gostaria que você dissesse logo o que quer dele? 
- Ou é um público novo com o qual você precisa estabelecer credibilidade? 
- Ele se importa com seu processo ou quer apenas a resposta? 
- É um processo colaborativo, no qual você precisa da opinião dele? 
- Você está pedindo para que ele tome uma decisão ou adote uma ação? 
[[Storytelling com dados.pdf#page=174&selection=38,0,40,74|(...)]]

[[Táticas]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Livros\Táticas.md
### Última modificação: 2024-09-25 19:00:43

---
tags: 
data: 2024-09-25
---
## Lógica horizontal[[Storytelling com dados.pdf#page=180&selection=11,0,11,17|(...)]]
![[Storytelling com dados.pdf#page=180&rect=69,69,435,314|300]]
Fazer um resumo diretor, levando em conta o resto do conteúdo.
## Lógica vertical[[Storytelling com dados.pdf#page=181&selection=5,0,5,15|(...)]]
![[Storytelling com dados.pdf#page=181&rect=68,350,297,511|300]]
Fazer links no proprio conteudo, para deixar hamonioso e almentando o sentido para o publico.
## Storyboard inverso[[Storytelling com dados.pdf#page=181&selection=21,0,21,18|(...)]]
![[Storytelling com dados.pdf#page=182&rect=66,511,428,725|300]]
Você pega a comunicação final, a folheia e anota o ponto principal de cada página [[Storytelling com dados.pdf#page=181&selection=25,35,26,39|(...)]]
## Uma nova perspectiva[[Storytelling com dados.pdf#page=182&selection=2,0,2,20|(...)]]
Pedir para alguém que não entende do assunto olhar e palpitar, ou pedir para o uma [[IA generativa]] fazer este papel. 



### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Livros\Web 1.0 vx Web 2.0.md
### Última modificação: 2024-10-02 16:04:32

---
tags:
  - Programação
data: 2024-10-02
---
### Web 1.0

- **Estática**: A [[Web 1.0]], também conhecida como a primeira geração da web, era composta principalmente por páginas estáticas. Isso significa que o conteúdo era fixo e não mudava a menos que fosse atualizado manualmente pelo webmaster.
### Web 2.0

- **Interativa**: A [[Web 2.0 ]]trouxe uma abordagem mais interativa, permitindo que os usuários não apenas consumissem conteúdo, mas também contribuíssem com ele.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Palavras\Glossário (data science para negocios).md
### Última modificação: 2024-10-29 00:25:31

---
tags:
  - DataAnalyst
  - Datascience
data: 2024-10-28
---
Imagine um cenário de [[mineração de dado|mineração de dados]] ([[KDD]]) para [[Descoberta de conhecimento|descoberta de conhecimento]] a partir de um grande [[Conjunto de dados|Conjunto de dados]].  Nosso objetivo é construir um **[[Classificador|classificador]]** com alta **[[Precisão|precisão]]** (baixa **[[Taxa de erro|taxa de erro]]**) usando **[[Aprendizagem de máquina|aprendizagem de máquina]]**. O conjunto de dados contém diversos **[[Atributos|atributos]]** (**[[Campos|campos]]**, **[[Variáveis|variáveis]]**, **[[Características|características]]**) descrevendo cada **[[Exemplo|exemplo]]** (**[[Instância|instância]]**, **[[Caso|caso]]**, **[[Registro|registro]]**, **[[Tupla|tupla]]**, **[[Vetor de característica|vetor de característica]]**), incluindo a **[[Classe|classe]]** (**[[Rótulo|rótulo]]**) que queremos prever.

**[[A priori|A priori]]**, assumimos uma distribuição i.i.d. para as **[[Amostras i.i.d.|amostras i.i.d.]]**. Durante a **[[Limpeza/purificação dos dados|limpeza/purificação dos dados]]**, tratamos **[[Valores ausentes|valores ausentes]]**. A **[[Indução|indução]]** do modelo envolve a seleção de **[[Características|características]]** relevantes e a otimização de uma função de **[[Custo|custo]]** (**[[Utilidade|utilidade]]**, **[[Perda|perda]]**, **[[Retribuição|retribuição]]**). Utilizamos **[[Validação cruzada|validação cruzada]]** para estimar o desempenho do **[[Modelo|modelo]]** e sua **[[Implementação do modelo|implementação do modelo]]** em cenários reais. A **[[Matriz de confusão|matriz de confusão]]** nos auxilia a avaliar métricas como **[[Sensibilidade|sensibilidade]]**, **[[Especificidade|especificidade]]** e **[[Cobertura|cobertura]]**. A **[[Dimensão|dimensão]]** do conjunto de dados pode impactar o processo. Aplicamos técnicas de **[[Aprendizagem supervisionada|aprendizagem supervisionada]]** para classificação e **[[Aprendizagem não supervisionada|aprendizagem não supervisionada]]**, como **[[Mineração de associação|mineração de associação]]**, para descobrir padrões nos dados. Ferramentas **[[OLAP|OLAP]]** (**[[MOLAP|MOLAP]]**, **[[ROLAP|ROLAP]]**) podem auxiliar na análise exploratória. Finalmente, o **[[Esquema|esquema]]** relacional define a estrutura dos dados.

[[Data Science para Negócios.pdf]]
A priori

Precisão (taxa de erro)

Mineração de associação

Atributo (campo, variável, característica)

Classe (rótulo)

Classificador

Matriz de confusão

Cobertura

Custo (utilidade/perda/retribuição)

Validação cruzada

Limpeza/purificação dos dados

Mineração de Dados

Conjunto de dados

Dimensão

Taxa de erro

Exemplo

Característica

Vetor de característica (registro, tupla)

Campo

Amostra i.i.d.

Indução

Exemplo (instância, caso, registro)

KDD

Descoberta de conhecimento

Perda

Aprendizagem de máquina

Valor ausente

Modelo

Implementação do modelo

OLAP (MOLAP, ROLAP)

Registro

Esquema

Sensibilidade

Especificidade

Aprendizagem supervisionada

Tupla

Aprendizagem não supervisionada

Utilidade



### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Palavras\Palavras.md
### Última modificação: 2024-10-22 01:58:35

---
tags: 
data: 2024-10-22
Titulo: Case Real de Dados
---
# Case Real de Dados

Nas últimas semanas de trabalho, tive o desafio de organizar uma estrutura de dados considerável e queria compartilhar com vocês como desenvolvi essa solução.

## 1. Estudo do Problema:
Antes de efetivamente iniciar qualquer desenvolvimento, realizei uma abordagem do problema para identificar os pontos que precisavam ser resolvidos. O objetivo principal era a **organização dos dados**, **ganho de performance** (evitando consultas e movimentações excessivas de dados em um servidor on-premises) e **implementação de governança**.

Com o objetivo definido, segui para a próxima etapa.

## 2. Escolha das Ferramentas:
Um problema frequente em muitas empresas são as opções limitadas de stacks que você consegue utilizar na organização. Muitas vezes, a instalação de ferramentas locais, linguagens e seus frameworks são proibidos pelo departamento de tecnologia em função dos riscos apresentados.

Para enfrentar o desafio, optei por usar as ferramentas da **Microsoft Fabric**, que garantem a manutenção e a escalabilidade da solução.

## 3. Desenvolvimento:
Com as ferramentas definidas, iniciei o desenvolvimento.

Em termos gerais, precisava definir 5 etapas:

- **(a) Ingestão dos dados brutos**
- **(b) Armazenamento**
- **(c) Limpeza, enriquecimento e agregação dos dados**
- **(d) Orquestração e monitoramento**
- **(e) Disponibilização ao usuário**

### (a) Ingestão dos Dados Brutos
A fonte principal era a **SAP** e alguns **flat files** (xlsx, csv). Para consumir esses dados e movimentá-los em sua forma bruta (raw), utilizei o **Dataflow Engine** (basicamente o Power Query Online), aplicando consultas na linguagem M, criadas pela equipe de negócios, nos dataflows. Realizei particionamento em "histórico" e "incremental" para garantir maior performance nas consultas ao servidor.

### (b) Armazenamento
No armazenamento, defini dentro dos dataflows o destino em um **lakehouse**, gerando tabelas **Delta "raw"** para consolidar os dados.

### (c) Limpeza, Enriquecimento e Agregação
Utilizei **notebooks** com instruções em **PySpark** e **SparkSQL** para a etapa de limpeza e agregação. Apliquei boas práticas da **arquitetura medalhão**, desacoplando as transformações em camadas. Em cada transformação de "raw-to-trusted" e "trusted-to-refined", os dados foram salvos em suas respectivas camadas.

### (d) Orquestração e Monitoramento
Utilizei **pipelines do Data Factory** para orquestrar todas essas etapas (até a atualização dos modelos semânticos) e agendar as execuções diárias.

### (e) Disponibilização ao Usuário
Com os dados limpos e agregados, utilizei o **warehouse** e seu ponto de extremidade **SQL** para disponibilizá-los. Dessa forma, os dados podem ser consumidos via **Power BI**, **Excel**, **Azure Data Studio**, **SSMS**, entre outros.

---

Hoje, esse processo roda diariamente, garantindo **organização** e **performance** para a construção de **BIs** e análises.

Divido com vocês o desenho da arquitetura.

---

O que acharam? Feedbacks de melhoria são super bem-vindos.


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\PLN\Perceptron e Aprendizado Supervisionado.md
### Última modificação: 2024-10-08 23:56:05

---
tags:
  - DataAnalyst
  - Datascience
data: 2024-10-08
---
O módulo é dividido em quatro partes:

1. **Perceptron Clássico**: Primeira forma de rede neural, usada para classificação linear. Ele tenta separar dados em duas categorias (como azuis e vermelhos) através de um hiperplano.
2. **Perceptron Probabilístico**: Uma evolução do perceptron clássico, que melhora sua capacidade de aprendizado e resolve alguns problemas, como a falta de confiança nas classificações.
3. **Redes Multicamadas**: São compostas por várias camadas de perceptrons, que permitem a criação de redes neurais mais complexas.
4. **Treinamento de Redes**: Focado no aprendizado supervisionado, onde a rede neural aprende com base em dados de entrada e saída fornecidos.

O aprendizado supervisionado é dividido em dois tipos:

- **Regressão**: Quando a saída é um valor contínuo (ex: temperatura de um paciente).
- **Classificação**: Quando a saída é uma categoria (ex: classe gramatical de uma palavra).

O perceptron clássico resolve problemas separáveis linearmente, mas tem limitações. Se os dados não forem linearmente separáveis, o algoritmo não convergirá, e pode ter dificuldades em generalizar. Por isso, o perceptron probabilístico, abordado na próxima parte do curso, visa resolver essas limitações.

1. **Problemas do Perceptron Clássico**: O perceptron clássico enfrenta três problemas principais:
    
    - Apenas lida com dados separáveis.
    - Possui pequenas margens, onde pontos próximos à linha de separação podem ser mal classificados.
    - Não oferece uma medida de confiança para suas classificações.
2. **Medida de Confiabilidade**: Para resolver o problema das pequenas margens, a ideia é usar a distância dos pontos à linha de separação como uma medida de confiabilidade. Quanto mais distante um ponto estiver da linha, maior a confiança em sua classificação.
    
3. **Classificação Probabilística**: A introdução de probabilidades permite classificar pontos como pertencentes a uma classe (por exemplo, azul) com uma certa probabilidade, utilizando a curva sigmoide. A curva tem formato de S e fornece:
    
    - Alta probabilidade à direita (classe azul).
    - Baixa probabilidade à esquerda (não azul).
    - Probabilidades intermediárias no meio.
4. **Transformações Não Lineares**: Para dados não linearmente separáveis ou inseparáveis, é possível aplicar transformações não lineares para separar os dados. Essas transformações podem distorcer o espaço, permitindo que os dados se tornem separáveis.
    
5. **Perceptrons Multicamadas**: Ao combinar a ideia de medidas de confiabilidade e transformações não lineares, surge a necessidade de redes com múltiplos perceptrons. Essas redes utilizam funções de ativação não lineares para realizar a separação de dados que não podiam ser separados anteriormente.
    

A aula termina com a introdução do conceito de perceptrons multicamadas, que será explorado em segmentos futuros.

- **Evolução do Perceptron**:
    
    - Apresentação do Perceptron simples.
    - Evolução para o Perceptron probabilístico com uma não linearidade.
    - Composição de várias camadas para formar redes neurais multicamadas.
- **Aprendizado de Pesos (Treinamento)**:
    
    - Definição de uma função de custo ou "loss" que mede a distância entre a previsão ('ŷ') e o valor real ('y').
    - O objetivo é minimizar essa perda para otimizar a rede neural.
- **Minimização da Perda (Otimização)**:
    
    - Gradiente descendente: técnica usada para ajustar os pesos da rede e minimizar a função de custo.
    - Taxa de aprendizado (alfa): controle do tamanho dos passos no gradiente descendente para evitar erros e flutuações.
- **Geografia da Função de Custo**:
    
    - Funções convexas e a dificuldade em encontrar mínimos globais devido a mínimos locais.
    - Métodos para evitar cair em mínimos locais.
- **Algoritmo de Backpropagation**:
    
    - Explicação do algoritmo de retropropagação dos anos 60, que se tornou popular nos anos 80.
    - Três passos: propagação do dado para frente, cálculo da loss, e retropropagação dos gradientes para atualizar os pesos.
- **Treinamento em Batches**:
    
    - O processo de usar lotes de dados (batches) para atualizar os pesos em vez de um dado por vez.
    - Conceito de "época": uma passagem por todos os dados de treinamento.
- **Softwares Usados**:
    
    - Ferramentas como PyTorch e TensorFlow automatizam os cálculos dos gradientes e atualizações.
- **Parâmetros de Treinamento**:
    
    - Importância de definir corretamente a taxa de aprendizado e os parâmetros para garantir a eficiência do treinamento.
- **Possíveis Problemas**:
    
    - Overfitting, underfitting e mínimos locais, com métodos para lidar com esses problemas (normalização, regularização).
- **Próximos Passos**:
    
    - No próximo módulo, será abordada a representação de palavras e o processamento de textos.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\PLN\Problemas básicos.md
### Última modificação: 2024-10-04 00:08:26

---
tags: 
data: 2024-10-04
---
Vamos começar uma série de partes descrevendo problemas básicos de processamento de linguagem natural. Antes de entrar nesses problemas, é importante introduzir alguns conceitos fundamentais.

**Conceitos Fundamentais:**

1. **O que é uma palavra?**  
    O termo "palavra" pode ter múltiplos significados, então é importante distingui-los. Podemos falar de:
    
    - **Ocorrências de palavras (tokens):** São cada uma das palavras escritas em um texto. Por exemplo, na frase "O menino viu o vizinho", temos cinco ocorrências de palavras: 'O', 'menino', 'viu', 'o' e 'vizinho'.
    - **Tipos de palavras:** Referem-se às palavras únicas, independentemente de quantas vezes elas ocorrem no texto. Na frase anterior, temos quatro tipos de palavras: 'o', 'menino', 'viu', 'vizinho', sendo que 'o' ocorre duas vezes.
2. **O que são problemas?**  
    O termo "problema" em PLN é ainda mais complicado que o termo "palavra", pois depende da língua, da aplicação, do modelo matemático e do algoritmo. Cada problema pode ser composto por vários subproblemas.
    
3. **O que é um 'corpus'?**  
    Um corpus é uma coleção de textos (ou áudios, vídeos, etc.). Pode ser um texto puro ou anotado, e pode haver diferentes tipos de anotações, como classe gramatical, polaridade das sentenças, ou detecção de preconceito. Textos paralelos (em diferentes idiomas ou entre texto e fala) também podem compor um corpus.
    

---

**Pré-processamento de Texto:**

O pré-processamento é a etapa inicial em PLN e é fundamental. Apesar de parecer uma tarefa simples, pode ocupar a maior parte do tempo. Aqui estão algumas etapas de pré-processamento:

1. **Tokenização:**  
    A tokenização é o processo de segmentar o texto em palavras (ou tokens). Exemplo: "mais vale asno que me carregue do que cavalo que me derrube". Cada palavra seria um token.
    
2. **Filtragem:**  
    A filtragem é o processo de remover ou transformar partes do texto que não são relevantes para o processamento. Exemplo: Remover tags em XML ou anotações gramaticais de um texto.
    
3. **Identificação de Pontos Finais:**  
    Um aspecto importante é determinar quais pontos no texto indicam o final de uma sentença. Nem todos os pontos marcam o final de uma sentença, como em abreviações ("Dr.", "Jr.") ou em contextos específicos de certas línguas (como em Catalão).
    
4. **Expansão de Abreviações:**  
    Este processo transforma abreviações em suas formas completas. Exemplo: "Ling. comp" pode ser expandido para "linguística computacional".
    
5. **Separação de Sentenças:**  
    Identificar as sentenças em um texto pode ser desafiador. Sentenças sem verbos ou frases incompletas podem complicar o processo.
    
6. **Restrição de 'Stop-words':**  
    'Stop-words' são palavras muito comuns que não contribuem significativamente para a compreensão do texto e podem ser removidas. Exemplo: artigos, preposições e conjunções. No entanto, dependendo do modelo utilizado (ex: redes neurais), a remoção de 'stop-words' pode não ser necessária.
    

---

**Considerações Finais:**

O pré-processamento de texto é uma combinação de várias etapas que raramente ocorrem isoladamente. A filtragem, tokenização e outras técnicas são frequentemente aplicadas juntas para preparar os dados de maneira adequada para a aplicação de algoritmos.



### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\PLN\Problemas de Morfologia.md
### Última modificação: 2024-10-04 00:46:14

---
tags:
  - DataAnalyst
  - Datascience
data: 2024-10-04
---
Continuando com os problemas típicos de processamento de linguagem natural, agora vamos falar sobre questões relacionadas à morfologia das palavras. Esses problemas envolvem identificar partes de palavras e/ou classificar as palavras, analisando-as no contexto de um texto.

**1. Separações de Junções**

Um dos problemas que podemos considerar nessa categoria é a separação de junções. Por exemplo, no português existem junções que não existem em inglês. Palavras como "naquelas" (que significa "aquelas") ou "àquilo" (com crase) podem ser separadas para fins de processamento posterior, funcionando como uma fronteira entre pré-processamento e processamento propriamente dito. Outros exemplos incluem "pela" (que é "por a") e "do" (que é "de o").

**2. Expressões Multipalavras**

Outro fenômeno é o das expressões multipalavras, que são unidades lexicais complexas com um significado que não pode ser compreendido apenas decompondo suas partes. Por exemplo, na frase "A lei entrou imediatamente em vigor", "entrar em vigor" é um verbo que deveria ser tratado como uma unidade. Outra expressão, como "ele é uma mão na roda", não faz sentido se analisarmos apenas as palavras individualmente, pois "mão na roda" significa que a pessoa é muito solícita.

**3. Lematização e Stemming**

Avançando para a análise interna das palavras, encontramos a operação de lematização, que consiste em extrair os lemas ou radicais das palavras. Por exemplo, em uma sentença, "extrair totalmente os lemas, radicais das palavras", os radicais seriam: "extrai", "total", "o", "lema", "radic", "da", "palavr". A lematização requer um dicionário para identificar corretamente os radicais, sufixos e prefixos.

O stemming, por outro lado, é uma aproximação da lematização, onde o programa tenta adivinhar quais partes das palavras são sufixos ou prefixos e os remove. Assim, "extraiu" poderia ser reduzido a "extra", mas isso pode resultar em erros, como "aproximadamente" sendo reduzido a "aproximada".

**4. Etiquetagem Morfossintática**

Um problema recorrente é a etiquetagem morfossintática, que consiste em atribuir etiquetas ou classes morfossintáticas às palavras em uma sentença, dependendo do conjunto de etiquetas utilizado. Por exemplo, em uma frase extraída de um sermão do Padre Vieira: "Quando há de ser o dia do juízo", as palavras seriam etiquetadas da seguinte forma: "a" (determinante feminino), "primeira" (adjetivo feminino), "coisa" (nome) e "que" (pronome relativo).

Atualmente, existem programas, alguns disponíveis em Python e outras linguagens, que realizam essa etiquetagem morfossintática por meio de aprendizado automático. O processo envolve a etiquetagem manual de textos para criar um corpus, que é utilizado para treinar algoritmos de etiquetagem, baseando-se em regras, probabilidade ou redes neurais.

**Considerações Finais**

A etiquetagem morfossintática depende do contexto e do conjunto de etiquetas utilizado. Um exemplo interessante é a palavra "canto", que pode ser um verbo ou um substantivo, dependendo do contexto.

Vamos abordar problemas típicos de processamento de linguagem natural que envolvem textos completos e não apenas palavras isoladas. Esses problemas são classificados como de natureza sintática.

### 1. Segmentação

A segmentação consiste em identificar as principais unidades sintáticas da sentença, como sintagmas nominais e verbais. Por exemplo, na frase "Quando há de ser o dia do juízo":

- **Sintagmas Nominais**:
    
    - "a primeira coisa"
    - "o dia do juízo"
- **Sintagma Verbal**:
    
    - "há de ser" (que poderia ser simplificado como "será" na linguagem contemporânea).

Aqui, observamos que um sintagma verbal pode conter um sintagma nominal e vice-versa.

### 2. Análise Sintática Rasa

A análise sintática rasa, ou "shallow parsing", vai além da segmentação, classificando os componentes básicos da sentença, como sintagmas verbais e nominais. Por exemplo:

- O sintagma nominal engloba o sintagma verbal, e o sintagma verbal contém o sintagma nominal.

Embora essa análise forneça uma visão geral da estrutura, ela ainda não considera cada palavra em detalhes.

### 3. Análise Sintática Profunda

A análise sintática profunda, ou "deep parsing", é uma análise completa da estrutura da sentença, incluindo categorias vazias. Exemplos de categorias incluem:

- **Noun Phrase (Sintagma Nominal Mudo)**
- **Sujeito Oculto**

Essa análise é complexa e desafiadora, pois busca identificar todas as partes da sentença, incluindo junções.

### 4. Reconhecimento de Entidades Mencionadas (NER)

O reconhecimento de entidades mencionadas envolve identificar e classificar nomes próprios dentro de um texto. Por exemplo:

- Na frase: "A influência da pressão social exercida pela contrarreforma, na qual os Jesuítas tiveram papel de liderança."
    - **Entidades Mencionadas**:
        - "contrarreforma" (classificada como um acontecimento)
        - "Jesuítas" (classificado como um grupo de pessoas)

### 5. Resolução de Anáfora

Esse problema se refere a encontrar o referente de uma expressão, como pronomes e sintagmas nominais. Por exemplo:

- No texto: "João chegou completamente bêbado. Ele foi muito desagradável. O idiota não se manca."
    - **Referentes**:
        - "Ele" refere-se a "João".
        - "O idiota" também se refere a "João".

A resolução de anáforas é um problema complexo que pode envolver aspectos sintáticos, semânticos e pragmáticos.
### Problemas Típicos de Processamento de Linguagem Natural

#### 1. Problemas Semânticos

- **Detecção de Relações Semânticas**
    
    - **Sinonímia**: Identificação de palavras sinônimas, como "redondo" e "esférico".
    - **Antonímia**: Identificação de antônimos, como "bom" e "ruim".
    - **Hiperonímia**: Relação onde uma palavra é uma instância de outra, por exemplo, "cachorro" é um "mamífero".
- **Embedding de Palavras**
    
    - Inserção de palavras em um espaço n-dimensional.
    - O passado envolvia probabilidades relacionadas à morfologia e funções sintáticas.
    - Atualmente, utiliza-se vetores de tamanhos grandes (ex: 50, 100, 1024), onde o significado dos números não é necessariamente interpretado, mas sim utilizado para calcular similaridade entre palavras.
    - Exemplo: A frase "João ama Maria" é convertida em vetores para cada palavra.
- **Word2Vec**
    
    - Um algoritmo famoso que realiza o embedding de palavras em um espaço n-dimensional.

#### 2. Problemas Pragmáticos

- **Desambiguação de Palavras**
    
    - A fronteira entre semântica e pragmática.
    - Exemplo: "Eu sento no banco" (assento) versus "Eu entro no banco" (agência).
- **Desambiguação de Sentenças**
    
    - Exemplo: "Eu vi o menino com telescópio" pode ser interpretado de duas maneiras:
        - "Eu usei o telescópio para ver o menino."
        - "Eu vi o menino que estava carregando o telescópio."
- **Parseamento Semântico**
    
    - Transformação de sentenças de linguagem natural para linguagem de máquina.
    - Exemplo: Transformar a pergunta "Quais os estados cortados pelo rio São Francisco?" em um comando SQL.
- **Tradução entre Línguas**
    
    - Um problema fundamental na linguística computacional.
    - Exemplo: "Time flies like an arrow" pode ser traduzido como "O tempo voa como uma flecha" ou "As moscas do tempo gostam de uma seta."
    - A desambiguação de contexto é necessária para determinar a tradução correta.

#### 3. Problemas Éticos

- **Geração Automática de Respostas Odiosas**
    
    - Risco de disseminação de fake news e geração de textos prejudiciais.
- **Identificação de Autoria**
    
    - A utilização da identificação de autoria de textos pode levar a abusos, como prisões indevidas.
- **Utilizações Problemáticas da Tecnologia**
    
    - Oportunidades para uso ético da tecnologia em áreas como medicina, reconhecimento de doenças e seleção de pacientes.
- **Consciência Ética**
    
    - É importante estar ciente dos problemas éticos e buscar abordagens que minimizem os impactos negativos.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\PLN\REsumo.md
### Última modificação: 2024-10-01 22:51:35

---
tags:
  - DataAnalyst
data: 2024-10-01
---
Esse conteúdo aborda os modelos probabilísticos no processamento de linguagem natural (PLN), utilizando cadeias de Markov e modelos de n-gramas. A ideia principal é que probabilidades são utilizadas para modelar transições entre estados, o que pode ser aplicado a tarefas como etiquetagem morfossintática e análise de sentimento.

### Cadeias de [[Markov]]:

- **Definição**: Cadeias de Markov modelam transições entre estados, onde o próximo estado depende apenas do estado atual, e não da sequência de eventos anteriores.
- **Exemplo**: O comportamento do mercado financeiro é modelado como estados de alta, baixa ou estagnação. A transição para outro estado depende somente do estado atual.
- **Aplicação no PLN**: Na etiquetagem morfossintática, a probabilidade de uma palavra ser de uma certa classe gramatical depende da classe da palavra anterior.

### Modelos de [[N-gramas]]:

- **Definição**: Um n-grama é uma sequência de n palavras. Modelos de n-gramas ignoram a estrutura gramatical e consideram apenas as contagens das palavras ou sequências de palavras.
- **Exemplo**: Em um modelo unigrama (1-palavra), contamos quantas vezes cada palavra aparece. Em bigramas (2-palavras), contamos sequências de duas palavras, e assim por diante.
- **Aplicação**: Os modelos de n-gramas podem ser utilizados para análise de sentimento, onde bigramas e trigramas fornecem uma melhor base para prever se o texto tem sentimento positivo, negativo ou neutro.

### Algoritmo de Viterbi:

- Esse algoritmo é mencionado como uma técnica para encontrar a sequência mais provável de estados ou etiquetas, mas não é explorado em detalhes na aula.

### Limitações dos Modelos:

- Tanto as cadeias de Markov quanto os modelos de n-gramas têm limitações significativas quando o contexto se torna mais complexo ou exige olhar muito para o passado.
- **Cadeias de Markov**: Limitam-se ao olhar para o estado atual ou poucos estados anteriores. Quanto mais passado precisa ser considerado, mais complexo o modelo se torna.
- **N-gramas**: À medida que se aumenta o valor de "n", os dados tornam-se mais esparsos, o que pode prejudicar a precisão.

### Conclusão:

Os modelos probabilísticos têm aplicações úteis, mas possuem limites claros, especialmente em relação ao contexto. Com o avanço das técnicas de redes neurais, esses modelos probabilísticos foram amplamente superados em tarefas mais complexas de PLN, mas ainda são uma boa introdução ao campo e podem ser eficazes em certos casos de análise simples.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Programação\Abstração.md
### Última modificação: 2024-08-10 23:20:49

---
tags:
  - Programação
  - POO
data: 2024-08-10
nivel:
---
A abstração, na [[Programação Orientada a Objetos (POO)|POO]], é como simplificar a representação de um objeto, ocultando detalhes complexos e expondo apenas o essencial para o usuário. É como se você estivesse usando um controle remoto para operar um aparelho de TV: você não precisa saber como a TV funciona internamente para mudar o canal.

# POO a abstração se manifesta em:
[[Classes abstratas]] 
[[Métodos abstratos ]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Programação\Atributos.md
### Última modificação: 2024-11-14 22:01:16

---
tags:
  - Programação
  - POO
data: 2024-08-10
nivel:
---
Um **atributo** é uma característica ou propriedade associada a um [[Programação Orientada a Objetos (POO)|objeto]] ou classe.

Exemplos:
[[shape]] em [[NumPy]]
[[columns]] em [[Pandas]]
[[title]] em objetos do [[Matplotlib]]

```python
import numpy as np
arr = np.array([[1, 2, 3], [4, 5, 6]])
print(arr.shape)  # Saída: (2, 3)
```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Programação\Classes.md
### Última modificação: 2024-12-31 01:31:24

---
tags:
  - Programação
  - POO
data: 2024-08-10
nivel:
---
A classe, na [[Programação Orientada a Objetos (POO)]], é como um modelo ou [[blueprint]] para a criação de [[Objetosd|objetos]]. Ela define as características ([[Atributos|atributos]]) e comportamentos ([[Métodos|métodos]]) que todos os objetos do mesmo tipo terão.
# Exemplos
Imagine a classe como uma receita de bolo:
A receita define os ingredientes (atributos) necessários e os passos (métodos) para fazer o bolo.
 
Cada bolo que você faz a partir da receita é uma instância da classe "bolo".
Todos os bolos terão os mesmos ingredientes e passos básicos, mas podem variar em detalhes como tamanho, sabor, etc.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Programação\Construtor.md
### Última modificação: 2024-10-13 00:26:12

---
tags:
  - Programação
  - POO
data: 2024-08-12
nivel:
---

Em [[Programação Orientada a Objetos (POO)]], um construtor é um [[Métodos|método]] especial que é chamado automaticamente quando um novo [[Objetos|objeto]] é criado. Ele é usado para inicializar os [[Atributos|atributos]] (membros de dados) do objeto e preparar o objeto para uso.

# Características principais de construtores:
Nome: O nome do construtor é sempre o mesmo que o nome da [[Classe|classe]].
Sem tipo de retorno: Construtores não têm um tipo de retorno, nem mesmo [[void]].
Chamado automaticamente: Quando uma nova [[Instância]] da classe é criada, o construtor é chamado automaticamente.
Inicialização de atributos: O construtor é usado para inicializar os valores dos atributos do objeto.
Pode ter [[Parâmetros|parâmetros]]: Construtores podem ter parâmetros para receber valores iniciais para os atributos.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Programação\Instância.md
### Última modificação: 2024-12-31 01:31:42

---
tags:
  - Programação
  - POO
data: 2024-08-10
nivel:
---
A instância de uma [[Classe|classe]] é como criar um exemplo concreto daquela classe. Imagine a classe como um "modelo" e a instância como um [[Objetos|objeto]] real baseado nesse modelo.
# Exemplo:
Classe: "Carro"
	Atributos: marca, modelo, cor
	[[Métodos]]: acelerar(), frear(), buzinar()

Instância: "Meu carro"
	Atributos: marca = "Honda", modelo = "Civic", cor = "Preto"
	Métodos: acelerar(), frear(), buzinar()

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Programação\Métodos.md
### Última modificação: 2024-08-16 00:18:33

---
tags:
  - Python
  - POO
  - Programação
data: 2024-08-15
nivel:
---
Método são todas as partes da [[Classe]]: [[Função]], [[Decorador]], [[Atributos]]...


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Programação\Objetos.md
### Última modificação: 2024-08-10 21:19:04

---
tags:
  - "#Programação"
  - "#POO"
data: 2024-08-10
nivel:
---
O objeto é a instância da classe. ![[Instância]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Programação\Private.md
### Última modificação: 2024-08-13 23:40:57

---
tags:
  - Programação
  - POO
data: 2024-08-13
nivel:
---
Em [[Programação Orientada a Objetos (POO)]], o conceito de **[[Encapsulamento]]** é fundamental para proteger os [[dados]] e controlar o acesso a eles. Uma maneira de fazer isso é através da definição de **modificadores de acesso**, como o `private`, que restringe o acesso a determinados [[Atributos]] e [[Métodos]] dentro de uma [[Classe]].

# Exemplos
![[Private em python]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Programação\Programação Orientada a Objetos (POO).md
### Última modificação: 2024-12-31 01:31:51

---
tags:
  - Programação
  - POO
data: 2024-08-10
nivel:
---
# Programação Orientada a Objetos (POO)

A Programação Orientada a Objetos (POO) é um paradigma de programação que organiza o código em torno de "[[Objetos|objetos]]" que possuem dados (atributos) e comportamentos (métodos). Essa abordagem oferece diversos benefícios, como:

# Princípios Fundamentais(paradigmas):

* [[Abstração]] 
* [[Atributos]]
* [[Classe]]
* [[Objetos]]([[Instância]] da classe)
* [[Encapsulamento]] 
* [[Herança]] 
* [[Polimorfismo]] 
* [[Visibilidade]]
* [[Métodos]]
* [[Construtor]]
* [[Padrões de projetos]]
* [[Composição p]]
* [[Private]]
# Python

* [[Decorador]]
## Divisão
```python
class ContaBancaria:
    # Atributos
    taxa_juros = 0.05  # Atributo de classe

    def __init__(self, saldo=0.0):
        self._saldo = saldo  # Atributo de instância

    @property
    def saldo(self):
        return self._saldo

    @saldo.setter
    def saldo(self, valor):
        if valor < 0:
            raise ValueError("O saldo não pode ser negativo")
        self._saldo = valor

    def depositar(self, valor):
        self._saldo += valor

    @classmethod
    def definir_taxa_juros(cls, nova_taxa):
        cls.taxa_juros = nova_taxa

    @staticmethod
    def info_bancaria():
        return "Informações sobre a conta bancária."

# Criando um objeto
conta = ContaBancaria(1000.0)

# Usando métodos
conta.depositar(500)
print(conta.saldo)  # Acessando o atributo através do getter

```
- **Classe:** `ContaBancaria`
- **Atributos:** `taxa_juros`, `_saldo`
- **Métodos:** `__init__`, `depositar`, `saldo` (getter e setter), `definir_taxa_juros` (método de classe), `info_bancaria` (método estático)
- **Decoradores:** `@property`, `@saldo.setter`, `@classmethod`, `@staticmethod`
- **Objeto:** `conta` é uma [[Instância]] da classe `ContaBancaria`
# Benefícios da POO:

* **Reutilização de código:** A herança permite a criação de classes derivadas que reutilizam código das classes base, reduzindo o esforço de desenvolvimento e promovendo a consistência.
* **Manutenção simplificada:** O encapsulamento facilita a manutenção do código, pois as alterações em um objeto não afetam diretamente outros objetos.
* **Modularidade:** A divisão do código em objetos facilita o desenvolvimento e a depuração, permitindo a criação de sistemas complexos de forma mais organizada.
* **Flexibilidade:** O polimorfismo permite a adaptação do código a diferentes situações, tornando o software mais flexível e adaptável.
* **Facilidade de entendimento:** A POO facilita o entendimento do código, pois ele é organizado em unidades lógicas e bem definidas.



### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\projetos\Análise de E-commerce.md
### Última modificação: 2024-10-27 20:40:54

### Passo 1: **Entendimento do Problema e Definição de Objetivos**

- **Objetivo Geral**: Avaliar as vendas do e-commerce para entender o desempenho de produtos, comportamento de clientes e sazonalidade das compras.
- **Perguntas-chave**:
    1. Quais são os produtos mais vendidos?
    2. Existe sazonalidade nas vendas?
    3. Quem são os principais clientes?
    4. Qual é o valor médio gasto por cliente?
    5. Valor médio de comprar no dia?

### Passo 2: **Coleta e Entendimento dos Dados**

- **Dados Necessários**:
    - Tabela de vendas com informações como `data`, `ID do produto`, `quantidade vendida`, `preço`, `ID do cliente`.
    - Tabela de produtos com `ID`, `nome`, `categoria`, `custo`, `preço de venda`.
    - Tabela de clientes com `ID`, `nome`, `localização`.
- **Fonte de Dados**: Dependendo do acesso, você pode usar dados de sistemas como o Google Analytics, Shopify, ou um dataset simulado.

### Passo 3: **Limpeza e Preparação dos Dados**

- **Tratamento de Valores Nulos**: Remover ou substituir valores ausentes.
- **Correção de Tipos de Dados**: Verificar tipos de dados para colunas como `data` e `preço`.
- **Remoção de Duplicatas**: Certifique-se de que não haja registros duplicados, especialmente em tabelas de clientes e produtos.
- **Criação de Novas Colunas**:
    - **Valor total da venda**: `quantidade vendida * preço` em cada linha da tabela de vendas.
    - **Margem de lucro**: `preço - custo` em cada linha da tabela de produtos.

### Passo 4: **Análise Exploratória de Dados (EDA)**

- **Análise Descritiva**:
    - Calcule estatísticas como média, mediana, valores máximo e mínimo para `preço`, `quantidade`, `valor total`.
- **Identificação dos Produtos Mais Vendidos**:
    - Agrupe as vendas por `ID do produto` e calcule a soma da `quantidade vendida`.
- **Análise de Sazonalidade**:
    - Agrupe as vendas por `mês` para identificar picos de vendas ao longo do ano.
- **Segmentação de Clientes**:
    - Agrupe vendas por `ID do cliente` para ver quem são os principais clientes.
- **Análise do Valor Médio por Cliente**:
    - Calcule o valor médio gasto por cliente, agrupando por `ID do cliente` e obtendo a média do `valor total`.

### Passo 5: **Visualização dos Dados**

- **Ferramentas**: Use bibliotecas como `Matplotlib` ou `Seaborn` (Python) ou plataformas como Tableau e Power BI.
- **Gráficos**:
    - Gráfico de barras para produtos mais vendidos.
    - Gráfico de linha para mostrar a sazonalidade (vendas ao longo dos meses).
    - Gráfico de barras para mostrar os principais clientes e seus gastos.

### Passo 6: **Interpretação e Conclusões**

- **Identificar Produtos Populares**: Observe os produtos com maiores vendas e avalie se faz sentido aumentar seu estoque ou preço.
- **Compreender Sazonalidade**: Use a análise de sazonalidade para planejar campanhas de marketing.
- **Análise de Clientes**: Identifique os principais clientes para estratégias de fidelização e ofertas especiais.
- **Decisões de Estoque e Preço**: Baseado na margem de lucro dos produtos, avalie se é possível otimizar estoque e lucros.

### Passo 7: **Relatório Final e Apresentação dos Resultados**

- Prepare um **relatório** ou **apresentação** com os principais achados e gráficos.
- Destaque insights acionáveis, como recomendações para aumentar o estoque de produtos populares ou lançar promoções em meses de menor demanda.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Atributo.md
### Última modificação: 2024-11-15 21:24:12

---
tags:
  - Conceito
  - Python
data: 2024-11-14
---
Um **atributo** em Python é uma característica ou propriedade associada a um [[Programação Orientada a Objetos (POO)|objeto]], que pode armazenar dados ou comportamento.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Composição p.md
### Última modificação: 2024-08-13 22:50:23

---
tags:
  - POO
  - Python
  - Programação
data: 2024-08-13
nivel:
---
### Como funciona a composição?

Em vez de [[Herança|herdar]] características e comportamentos de uma [[Classe]] base (como ocorre na herança), a composição envolve a inclusão de [[Instância]] de outras classes como [[Atributos]] de uma classe. Isso cria uma relação de "tem-um" (em inglês, "has-a") entre os [[Objetos]]. Por exemplo, um **Carro** pode ser composto por várias partes, como **Motor**, **Rodas** e **Portas**.

### Exemplo:

Imagine que temos as classes `Motor`, `Roda` e `Carro`:

``` python
class Motor:     
	def __init__(self, potencia):
		 self.potencia = potencia  
		 
class Roda:     
	def __init__(self, tamanho):  
	self.tamanho = tamanho  
class Carro:     
	def __init__(self, marca, motor, rodas):        
		self.marca = marca         
		self.motor = motor  # Composição: o carro tem um motor         
		self.rodas = rodas  # Composição: o carro tem rodas
```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Instrução.md
### Última modificação: 2024-11-13 19:24:46

---
tags:
  - Conceito
data: 2024-11-13
---
Uma instrução em Python é uma linha de código que representa uma ação ou comando executado pelo interpretador.

Exemplos de Instruções em Python (sem explicação):
- [[del]]
- [[print]]
- [[if]], [[elif]], [[else]]
- [[for]]
- [[while]]
- [[break]]
- [[continue]]
- [[return]]
- [[import]]
- [[from]]
- [[with]]
- [[try]], [[except]], [[finally]]
- [[raise]]
- [[pass]]
- [[global]]
- [[nonlocal]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Método.md
### Última modificação: 2024-11-13 19:25:11

---
tags: 
data: 2024-11-13
---

No Python, um método é uma função que pertence a um objeto, como listas, dicionários, strings, entre outros. Os métodos permitem manipular e interagir com esses objetos de forma conveniente. Eles são chamados usando a notação de ponto (objeto.metodo()).

Aqui estão alguns exemplos de métodos em Python:

Métodos de listas:
- [[,append]]()
- [[,extend]]()
- [[,insert]]()
- [[,remove]]()
- [[,pop]]()
- [[,sort]]()
- [[,reverse]]()
- [[,index]]()
- [[,count]]()
- [[,clear]]()

Métodos de dicionários:
- [[,get]]()
- [[,keys]]()
- [[,values]]()
- [[,items]]()
- [[,pop]]()
- [[,popitem]]()
- [[,update]]()
- [[,clear]]()

Métodos de strings:
- [[,upper]]()
- [[,lower]]()
- [[,capitalize]]()
- [[,title]]()
- [[,find]]()
- [[,replace]]()
- [[,strip]]()
- [[,split]]()
- [[,join]]()
- [[,count]]()

Métodos de conjuntos:
- [[,add]]()
- [[,remove]]()
- [[,discard]]()
- [[,pop]]()
- [[,union]]()
- [[,intersection]]()
- [[,difference]]()
- [[,symmetric_difference]]()
- [[,clear]]()

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Objetos são acessado por endereços.md
### Última modificação: 2024-08-12 20:55:24

---
tags:
  - Python
  - Programação
  - POO
data: 2024-08-12
nivel:
---
# Instancias igualadas
```python
c1 = Conta('123-4', 'João', 120.0,  1000.0)
c2 = c1
c2.saldo
```
```
inicializando uma conta
120.0
```
Quando eu igualo objetos a mais de 1 instancia a resposta do programa sempre será a mesma para as 2 instancias no caso.

## pode se ver pelo id

```python
id(c1)
```
```
2129998308144
```

```python
id(c2)
```
```
2129998308144
```
# Objeto instanciado 
Na verdade o objeto instanciado é apenas um endereço para o mesmo local da memória, quando instanciado em 2 locais.
![[Pasted image 20240812205247.png]]

# O contrario não
Quando instancia o mesmo conteudo em objetos diferentes. Quando se pergunta se os 2 são o mesmo o python reponde `false`
![[Pasted image 20240812205425.png]]
```python
c1  =   Conta("123-4",  "Python",   500.0,  1000.0)
c2  =   Conta("123-4",  "Python",   500.0,  1000.0)
c1  ==  c2
```
```
inicializando uma conta 
inicializando uma conta

False
```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (10).md
### Última modificação: 2024-08-07 14:49:38

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Solicita ao usuário o valor em reais que ele possui
reais = float(input("Quantos reais você tem na carteira? "))

# Solicita ao usuário a cotação atual do dólar
cotacao_dolar = float(input("Qual a cotação atual do dólar? "))

# Calcula a quantidade de dólares que o usuário pode comprar
dolares = reais / cotacao_dolar

# Exibe o resultado para o usuário
print(f"Você pode comprar {dolares:.2f} dólares.") 
# O formato :.2f especifica que o valor de dolares deve ser exibido com duas casas decimais.

```
Quantos reais você tem na carteira? 100
Qual a cotação atual do dólar? 5.20
Você pode comprar 19.23 dólares.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (100).md
### Última modificação: 2024-08-08 19:29:39

---
tags: 
data: 2024-08-06
nivel:
---
```Python

from random import randrange

# Define a função sorteando() que recebe uma lista como argumento
def sorteando(num):
    """
    Sorteia 5 números aleatórios entre 0 e 9 e adiciona à lista passada como argumento.
    
    Args:
        num: A lista para a qual os números sorteados serão adicionados.
    """
    print('Soteando 5 valores da lista: ', end='')  # Imprime a mensagem inicial
    for c in range(0, 5):  # Itera 5 vezes (para sortear 5 números)
        n = randrange(10)  # Gera um número aleatório entre 0 e 9
        num.append(n)  # Adiciona o número sorteado à lista
        print(f'{n} ', end=' ')  # Imprime o número sorteado
    print('Pronto!')  # Imprime mensagem de conclusão

# Define a função somando_pares() que recebe uma lista como argumento
def somando_pares(num):
    """
    Calcula a soma dos números pares presentes na lista passada como argumento.
    
    Args:
        num: A lista que contém os números a serem analisados.
    """
    soma = 0  # Inicializa a variável soma com 0
    for v in range(0, len(num)):  # Itera sobre cada elemento da lista
        if num[v] / 2 == num[v] // 2:  # Verifica se o número é par (divisível por 2 sem resto)
            soma += num[v]  # Se o número for par, adiciona-o à variável soma
    print(f'Somando os valores pares de {num}, temos {soma}.')  # Imprime a soma dos números pares

# Cria uma lista vazia chamada num
num = list()

# Chama a função sorteando() para sortear números e adicioná-los à lista num
sorteando(num)

# Chama a função somando_pares() para calcular a soma dos números pares na lista num
somando_pares(num)

```
Soteando 5 valores da lista: 3 7 0 2 8 Pronto!
Somando os valores pares de [3, 7, 0, 2, 8], temos 10.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (101).md
### Última modificação: 2024-08-08 19:30:57

---
tags: 
data: 2024-08-06
nivel:
---
```Python

from datetime import date  # Importa a biblioteca 'date' para trabalhar com datas

def voto(ano_nascimento=0):  # Define a função 'voto' que recebe o ano de nascimento como parâmetro
    """
    Verifica a situação do voto de uma pessoa com base no ano de nascimento.

    Args:
        ano_nascimento (int): O ano de nascimento da pessoa.

    Returns:
        str: Um valor literal indicando se o voto é NEGADO, OPCIONAL ou OBRIGATÓRIO.
    """
    data_atual = date.today().year  # Obtém o ano atual

    idade = data_atual - ano_nascimento  # Calcula a idade da pessoa

    if idade < 16:  # Verifica se a pessoa tem menos de 16 anos
        print(f'Com {idade}: NÃO VOTA')  # Imprime que o voto é NEGADO
    elif 16 <= idade < 18 or idade > 65:  # Verifica se a pessoa tem entre 16 e 18 anos ou mais de 65 anos
        print(f'Com {idade}: VOTO OPIONAL')  # Imprime que o voto é OPCIONAL
    else:  # Se nenhuma das condições anteriores for verdadeira, o voto é obrigatório
        print(f'Com {idade}: VOTO OBRIGATÓRIO')  # Imprime que o voto é OBRIGATÓRIO


ano_nascimento = int(input('Em que ano você nasceu? '))  # Solicita ao usuário o ano de nascimento e converte para inteiro
voto(ano_nascimento)  # Chama a função 'voto' passando o ano de nascimento como argumento

```
Em que ano você nasceu? 2005
Com 18: VOTO OBRIGATÓRIO

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (102).md
### Última modificação: 2024-08-08 19:33:00

---
tags: 
data: 2024-08-06
nivel:
---
```Python

def fatorial(n, show=False):
    """
    Calcula o fatorial de um número inteiro.

    Args:
        n (int): O número inteiro a ser fatorado.
        show (bool, optional): Se True, mostra o processo de cálculo do fatorial. Defaults to False.

    Returns:
        int: O fatorial do número.
    """
    f = 1  # Inicializa o fatorial com 1
    for c in range(n, 0, -1):  # Itera de 'n' até 1, decrementando de 1 em 1
        if show:  # Se o argumento 'show' é True
            print(c, end='')  # Imprime o número atual
            if c > 1:  # Se o número atual é maior que 1
                print(' x ', end='')  # Imprime ' x '
            else:
                print(' = ', end='')  # Caso contrário, imprime ' = '
        f *= c  # Multiplica o fatorial atual pelo número atual
    return f  # Retorna o fatorial calculado


# Exemplo de uso:
print(fatorial(5, show=True))  # Calcula o fatorial de 5 e mostra o processo
print(fatorial(6))  # Calcula o fatorial de 6 sem mostrar o processo
help(fatorial)  # Mostra a documentação da função

```
5 x 4 x 3 x 2 x 1 = 120
720
Help on function fatorial in module __main__:

fatorial(n, show=False)
    -> e uma função que dis a fatorial.
    :param n: o numero a fatorar
    :param show: Se você quer que apareça o historico      
    :return: sem retorno


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (103).md
### Última modificação: 2024-08-08 19:34:32

---
tags: 
data: 2024-08-06
nivel:
---
```Python

def ficha(nome='<DESCONHECIDO>', gols=0):
    """
    Esta função recebe o nome de um jogador e a quantidade de gols que ele marcou como parâmetros opcionais.
    Ela monta e exibe a ficha do jogador, mesmo que algum dado não tenha sido informado corretamente.

    Args:
        nome (str, optional): O nome do jogador. Padrão é '<DESCONHECIDO>'.
        gols (int, optional): A quantidade de gols marcados pelo jogador. Padrão é 0.
    """

    # Verifica se a entrada de gols é um número. Se não for, define como 0.
    if gols.isnumeric():
        gols = int(gols)  # Converte a string para inteiro
    else:
        gols = 0

    # Verifica se o nome foi informado. Se não, define como '<DESCONHECIDO>'.
    if nome.strip() == '':
        nome = '<DESCONHECIDO>'

    # Imprime a ficha do jogador formatada.
    print(f"O jogador {nome} fez {gols} gol(s) no campeonato.")

# Solicita ao usuário o nome do jogador e a quantidade de gols.
a = str(input('Nome do jogador: '))
b = str(input('Número de Gols:'))

# Chama a função ficha() para gerar e exibir a ficha do jogador.
ficha(a, b)

```
Nome do jogador: jonathas
Número de Gols:67
O jogador jonathas fez 67 gol(s) no campeonato.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (104).md
### Última modificação: 2024-08-08 19:36:43

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Define a função leia_int, que recebe uma string como argumento (mensagem para o usuário)
def leia_int(msg):
    # Solicita ao usuário que digite um número e converte a entrada para string
    n = str(input(msg))
    # Inicia um loop que continua até que o usuário digite um número inteiro válido
    while True:
        # Verifica se a entrada é composta apenas por dígitos numéricos usando o método isnumeric()
        if not n.isnumeric():
            # Se a entrada não for numérica, exibe uma mensagem de erro em vermelho
            print('\033[31mERRO! Digite um número inteiro válido\033[m')
            # Solicita novamente a entrada do usuário e converte para string
            n = str(input(msg))
        else:
            # Se a entrada for numérica, sai do loop
            break
    # Retorna a entrada convertida para inteiro
    return int(n)  # A entrada já é um número inteiro, aqui convertemos para int

# Chama a função leia_int para solicitar um número ao usuário
n = leia_int('Digite um número: ')
# Imprime a mensagem com o número digitado pelo usuário
print(f'Você acabou de digitar o número {n}')

```
![[Pasted image 20240808193642.png]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (105).md
### Última modificação: 2024-08-08 19:38:40

---
tags: 
data: 2024-08-06
nivel:
---
```Python

def notas(*n, sit=False):
    """
    Função que analisa as notas de alunos e retorna um dicionário com informações relevantes.

    Args:
        *n (int): Uma ou mais notas dos alunos, recebidas como argumentos variáveis.
        sit (bool, optional): Se True, inclui a situação do aluno no dicionário de retorno. Defaults to False.

    Returns:
        dict: Um dicionário contendo as seguintes informações:
            - 'total': Quantidade de notas.
            - 'maior': Maior nota.
            - 'menor': Menor nota.
            - 'média': Média das notas.
            - 'situação': (opcional) Situação do aluno ('aprovado', 'recuperação' ou 'reprovado'), apenas se sit for True.
    """
    d = {}  # Cria um dicionário vazio para armazenar as informações.

    d['total'] = len(n)  # Calcula a quantidade de notas e armazena em 'total'.
    d['maior'] = max(n)  # Encontra a maior nota e armazena em 'maior'.
    d['menor'] = min(n)  # Encontra a menor nota e armazena em 'menor'.
    d['média'] = sum(n) / d['total']  # Calcula a média das notas e armazena em 'média'.

    # Se o argumento 'sit' for True, calcula a situação do aluno e adiciona ao dicionário.
    if sit:
        if d['média'] > 7:
            d['situação'] = 'aprovado'
        elif d['média'] > 3:
            d['situação'] = 'recuperação'
        else:
            d['situação'] = 'reprovado'

    return d  # Retorna o dicionário com as informações calculadas.


# Exemplo de uso da função:
notas_alunos = notas(7.5, 6.0, 9.0, 5.5, sit=True)  # Chama a função com as notas e 'sit=True'
print(notas_alunos)  # Imprime o dicionário com as informações das notas.

# Saída:
# {'total': 4, 'maior': 9.0, 'menor': 5.5, 'média': 7.0, 'situação': 'aprovado'}

```
{'total': 3, 'maior': 9, 'menor': 2, 'média': 5.333333333333333, 'situação': 'recuperação'}
Help on function notas in module __main__:

notas(*n, sit=False)
    Função que analiza as notas
    :param n: todas as notas
    :param sit: Se quer a situação ou não (True/False)     
    :return: dicionario d


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (106).md
### Última modificação: 2024-08-08 19:51:51

---
tags: 
data: 2024-08-06
nivel:
---
```Python

""" 106: Faça um mini-sistema que utilize o Interactive Help do Python.
O usuário vai digitar o comando e o manual vai aparecer. Quando o usuário digitar
 a palavra 'FIM', o programa se encerrará. Importante: use cores."""

# Define as cores para o terminal
fVerde, fAzul, fRoxo = "\033[1;30;42m", "\033[1;30;44m", "\033[1;30;45m"
normal = "\033[m"  # Define a cor padrão do terminal

# Define a função que implementa o sistema de ajuda
def ajuda():
    """
    Função principal que implementa o sistema de ajuda. 
    Exibe um menu de ajuda para comandos e bibliotecas Python.
    """
    while True:  # Loop principal para o sistema de ajuda
        # Exibe o título do sistema de ajuda com cores
        print(fVerde, end="")
        print("-" * 30)
        print(" Sistema de ajuda para Python")
        print("-" * 30)
        print(normal)

        # Solicita ao usuário que insira um comando ou biblioteca
        comando = str(input("Comando ou biblioteca ('fim' para sair): "))

        # Verifica se o usuário digitou 'fim' para sair
        if comando.lower() == "fim":
            # Exibe mensagem de despedida com cores
            print(fRoxo, end="")
            print("-" * 16)
            print(" Até a próxima!")
            print("-" * 16)
            print(normal)
            break  # Sai do loop principal

        # Exibe a ajuda para o comando ou biblioteca usando a função `help()`
        print(fAzul, end="")
        print(help(comando))  # Executa a função `help()` e exibe a documentação
        print(normal)

# Chama a função `ajuda()` para iniciar o sistema de ajuda
ajuda()

```

![[Pasted image 20240808194138.png]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (11).md
### Última modificação: 2024-08-07 14:51:26

---
tags: 
data: 2024-08-06
nivel:
---
```Python

print('\033[31m'+'Isto eh vermelho'+'\033[0;0m')

print('\033[32m'+'Isto eh verde'+'\033[0;0m')

print('\033[42m'+'\033[1m'+'\033[33m'+'Isto eh amarelo negrito com fundo verde'+'\033[0;0m')

```
![[Pasted image 20240807145124.png]]


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (12).md
### Última modificação: 2024-08-07 14:55:45

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# 1. Solicita ao usuário o valor do produto.
n = float(input('Qual o valor do produto?: '))

# 2. Calcula o desconto de 5% sobre o valor do produto.
desconto = n * 0.05

# 3. Calcula o novo preço do produto.
novo_preco = n - desconto

# 4. Imprime o novo preço com desconto.
print('O valor do produto descontado 5% é:', novo_preco, 'Reais')

```
Qual o valor do produto?: 39
O valor do produto descontado 5% é: 37.05 Reais

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (13).md
### Última modificação: 2024-08-07 14:57:31

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Solicita ao usuário que digite o salário atual
salario_atual = float(input('Qual seu salário atual?: '))

# Calcula o valor do aumento
aumento = salario_atual * 0.15

# Calcula o novo salário
novo_salario = salario_atual + aumento

# Imprime o novo salário
print('Seu salário de {} vai passar a ser {}'.format(salario_atual, novo_salario))

```
Qual seu salario atual?:3000
Seu salario de 3000 vai passar a ser:3450.0

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (14).md
### Última modificação: 2024-08-07 14:58:54

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Solicita ao usuário que insira a temperatura em graus Celsius
n = int(input('Qual valor em Celsius: '))

# Calcula a temperatura em Fahrenheit usando a fórmula:
# Fahrenheit = (Celsius * 9/5) + 32
fahrenheit = (n * 9 / 5) + 32

# Imprime a temperatura em Fahrenheit
print('São {} Fahrenheit'.format(fahrenheit))

```
Qual valor em Celsius: 25
São 77.0 Fahrenheit

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (15).md
### Última modificação: 2024-08-07 15:00:30

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Este programa calcula o preço a pagar pelo aluguel de um carro.

# Pede ao usuário a quantidade de quilômetros percorridos.
# A função `input()` lê a entrada do usuário como uma string,
# então a convertemos para um número de ponto flutuante usando `float()`.
km_percorridos = float(input('Quantos km percorreu?: '))

# Pede ao usuário a quantidade de dias que o carro foi alugado.
# A função `input()` lê a entrada do usuário como uma string,
# então a convertemos para um inteiro usando `int()`.
dias_aluguel = int(input('Quantos dias ficou com o carro?: '))

# Define o preço diário do aluguel.
preco_diario = 60

# Define o preço por quilômetro rodado.
preco_km = 0.15

# Calcula o custo total do aluguel.
# O custo total é calculado multiplicando o preço diário pelo número de dias
# e adicionando o custo por quilômetro rodado (preço por km multiplicado pela 
# quantidade de km percorridos).
custo_total = (dias_aluguel * preco_diario) + (km_percorridos * preco_km)

# Imprime o custo total do aluguel.
print('O valor pago será de:', custo_total)

```
Quantos km percorreu?:250
Quantos dias ficou com o carro?:3
O valor pago será de: 217.5

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (16).md
### Última modificação: 2024-08-07 15:02:19

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Importar a função trunc da biblioteca matemática
from math import trunc

# Solicitar ao usuário para digitar um número real e armazenar na variável num
num = float(input('Digite um número real?: '))

# Usar a função trunc para obter a parte inteira do número
# A função trunc remove a parte decimal do número, retornando apenas a parte inteira
parte_inteira = trunc(num)

# Exibir o resultado na tela, formatando a saída para mostrar o número original e sua parte inteira
print('O número {} tem a parte inteira {}'.format(num, parte_inteira))

```
digite um numero real?:4.1231231212331212 
O numero 4.123123121233121 tem a parte inteira 4

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (17).md
### Última modificação: 2024-08-07 15:14:36

---
tags: 
data: 2024-08-06
nivel:
---
```Python

import math  # Importa a biblioteca matemática para utilizar a função hypot()

# Pede ao usuário para inserir o comprimento do cateto oposto
o = float(input('Qual o cateto oposto?:'))

# Pede ao usuário para inserir o comprimento do cateto adjacente
a = float(input('Qual o cateto adjacente?:'))

# Calcula a hipotenusa usando a função hypot() da biblioteca matemática
hipotenusa = math.hypot(o, a)

# Imprime o comprimento da hipotenusa
print('A hipotenusa é de:', hipotenusa)

```
- **Entrada:**
    
    - Cateto oposto: 3
        
    - Cateto adjacente: 4
        
- **Saída:**
    
    - A hipotenusa é de: 5.0

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (18).md
### Última modificação: 2024-08-07 15:17:58

---
tags: 
data: 2024-08-06
nivel:
---
```Python

import math  # Importa a biblioteca matemática do Python, que fornece funções matemáticas como seno, cosseno e tangente.

# Solicita ao usuário que insira um ângulo em graus.
angulo_graus = float(input('Qual o ângulo?: '))

# Converte o ângulo de graus para radianos, pois as funções trigonométricas do Python usam radianos.
angulo_radianos = math.radians(angulo_graus)

# Calcula o seno, cosseno e tangente do ângulo em radianos.
seno = math.sin(angulo_radianos)
cosseno = math.cos(angulo_radianos)
tangente = math.tan(angulo_radianos)

# Imprime os resultados formatados com duas casas decimais.
print('O seno é: {:.2f}'.format(seno))
print('O coseno é: {:.2f}'.format(cosseno))
print('O tangente é: {:.2f}'.format(tangente))
# \n para pular linha
```
Qual o angulo?:70
O seno é:0.94 
O coseno é:0.34
O trangente é:2.75

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (19).md
### Última modificação: 2024-08-07 15:19:16

---
tags: 
data: 2024-08-06
nivel:
---
```Python

import random  # Importa a biblioteca 'random' para gerar números aleatórios

# Solicita ao usuário que digite o nome dos alunos
z = input('Nome do aluno?: ')
x = input('Nome do aluno?: ')
c = input('Nome do aluno?: ')
v = input('Nome do aluno?: ')

# Cria uma tupla com os nomes dos alunos
p = (z, x, c, v)  # A tupla é imutável, ou seja, seu conteúdo não pode ser alterado após a criação

# Escolhe um nome aleatório da tupla
u = random.choice(p)  # A função 'random.choice()' seleciona um elemento aleatório da tupla 'p'

# Imprime o nome do aluno escolhido
print('\nO nome escolhido foi:', u)

```
Nome do aluno?: João
Nome do aluno?: Maria
Nome do aluno?: Pedro
Nome do aluno?: Ana
O nome escolhido foi: Pedro

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (20).md
### Última modificação: 2024-08-07 15:21:02

---
tags: 
data: 2024-08-06
nivel:
---
```Python

import random

# Solicita o nome dos alunos
z = input('Nome do aluno?:')
x = input('Nome do aluno?:')
c = input('Nome do aluno?:')
v = input('Nome do aluno?:')

# Cria uma lista com os nomes dos alunos
alunos = [z, x, c, v]

# Utiliza a função 'random.sample' para sortear a ordem dos alunos
# A função 'random.sample' recebe como parâmetros a lista de alunos e o número de elementos a serem sorteados (k=4)
ordem_sorteada = random.sample(alunos, k=4)

# Imprime a ordem sorteada
print('\nO nome escolhido foi:', ordem_sorteada)

```
Nome do aluno?:João
Nome do aluno?:Maria
Nome do aluno?:Pedro
Nome do aluno?:Ana
O nome escolhido foi: ['Maria', 'Ana', 'João', 'Pedro']

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (21).md
### Última modificação: 2024-08-07 15:22:12

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Solicita ao usuário que digite seu nome completo
nome = input('Qual seu nome todo: ')

# Imprime o nome em letras maiúsculas
print('Seu nome em maiúsculo é:', nome.upper())

# Imprime o nome em letras minúsculas
print('Seu nome em minúsculas é:', nome.lower())

# Conta o número total de letras no nome, excluindo espaços
# len(nome) retorna o número total de caracteres (letras e espaços)
# nome.count(' ') conta o número de espaços no nome
print('Seu nome tem {} letras ao todo.'.format(len(nome) - nome.count(' ')))

# Divide o nome em uma lista de palavras, separando por espaços
n = nome.split()

# Imprime o número de letras no primeiro nome
# len(n[0]) retorna o número de letras na primeira palavra (primeiro nome)
print('Seu primeiro nome tem {} letras.'.format(len(n[0])))

```
Qual seu nome todo: João da Silva
Seu nome em maiúsculo é: JOÃO DA SILVA
Seu nome em minúsculas é: joão da silva
Seu nome tem 13 letras ao todo.
Seu primeiro nome tem 4 letras.


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (22).md
### Última modificação: 2024-08-07 15:25:07

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Solicita ao usuário que digite um número inteiro
n = int(input('Digite um número: '))

# Extrai a unidade
unidade = n % 10  # O operador módulo (%) retorna o resto da divisão por 10, 
                  # que corresponde ao dígito da unidade
print('Unidade:', unidade)

# Extrai a dezena
dezena = n // 10 % 10  # A divisão inteira (//) remove a unidade, 
                     # o módulo (%) retorna a unidade após a divisão por 10, 
                     # que corresponde ao dígito da dezena
print('Dezena:', dezena)

# Extrai a centena
centena = n // 100 % 10  # A divisão inteira (//) remove a dezena e a unidade,
                      # o módulo (%) retorna a unidade após a divisão por 10,
                      # que corresponde ao dígito da centena
print('Centena:', centena)

# Extrai o milhar
milhar = n // 1000 % 10  # A divisão inteira (//) remove a centena, a dezena e a unidade,
                      # o módulo (%) retorna a unidade após a divisão por 10,
                      # que corresponde ao dígito do milhar
print('Milhar:', milhar)

```
Digite um numero:4567
unidade: 7.0
desena: 6
centena: 5
milhar: 4

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (23).md
### Última modificação: 2024-08-07 15:26:30

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Solicita ao usuário que digite o nome de uma cidade
cida = input('Digite uma cidade: ')

# Divide o nome da cidade em uma lista de palavras, separando por espaços
cidade = cida.split()

# Acessa a primeira palavra da lista (o primeiro nome da cidade)
primeira_palavra = cidade[0]

# Converte a primeira palavra para letras minúsculas para comparação sem problemas de maiúsculas e minúsculas
primeira_palavra_minuscula = primeira_palavra.lower()

# Verifica se a palavra "sant" está no início da primeira palavra (usando find(), que retorna 0 se a string for encontrada no início)
if primeira_palavra_minuscula.find('sant') == 0:
    print('Esta cidade tem "santo" no começo.')
else:
    print('Esta cidade não tem "santo" no começo.')

```
Digite uma cidade: Santo André
Esta cidade tem "santo" no começo.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (24).md
### Última modificação: 2024-08-07 15:28:21

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Solicita ao usuário que digite seu nome e armazena em uma variável chamada 'n'.
n = input('Digite seu nome:')

# Converte o nome para letras maiúsculas e remove espaços em branco no início e no fim.
n = n.upper().strip()

# Verifica se a string 'SILVA' está presente no nome do usuário.
# O resultado da verificação é armazenado na variável 'tem_silva'.
tem_silva = 'SILVA' in n

# Imprime na tela se o nome do usuário tem ou não 'SILVA'.
print('Seu nome tem Silva?:', tem_silva)

```
Digite seu nome:João da Silva
Seu nome tem silva?: True

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (25).md
### Última modificação: 2024-08-07 15:29:37

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Solicita ao usuário que digite uma frase e armazena em uma variável
f = input('Digite uma frase:').upper().strip()

# Conta quantas vezes a letra 'A' aparece na frase
# O método .count('A') conta o número de ocorrências de 'A' na string
print('A letra "a" aparece {} vezes.'.format(f.count('A')))

# Encontra a primeira posição em que a letra 'A' aparece na frase
# O método .find('A') retorna o índice da primeira ocorrência de 'A' na string
# Se 'A' não estiver presente, a função retorna -1
# O +1 é adicionado para mostrar a posição correta na frase (começando em 1)
print('A letra "a" aparece na primeira vez:', f.find('A')+1)

# Encontra a última posição em que a letra 'A' aparece na frase
# O método .rfind('A') retorna o índice da última ocorrência de 'A' na string
# Se 'A' não estiver presente, a função retorna -1
# O +1 é adicionado para mostrar a posição correta na frase (começando em 1)
print('A ultima letra A apareceu na posição', f.rfind('A')+1)

```
**Entrada:** "Olá, Mundo!"
A letra "a" aparece 2 vezes.
A letra "a" aparece na primeira vez: 1
A ultima letra A apareceu na posição 7

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (26).md
### Última modificação: 2024-08-07 16:51:15

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Solicita ao usuário que digite uma frase
f = input('Digite uma fraze:')

# Converte a frase para maiúsculas e remove espaços em branco no início e no fim
f = f.upper().strip()

# Conta quantas vezes a letra 'A' aparece na frase
print('A letra "a" aparece {} vezes.'.format(f.count('A')))

# Encontra a primeira ocorrência da letra 'A' na frase
# O método find() retorna o índice da primeira ocorrência, 
# ou -1 se a letra não estiver presente.
# Adicionamos 1 ao resultado para que a posição seja exibida de acordo com o índice humano, 
# começando em 1.
print('A letra "a" aparece na primeira vez:', f.find('A')+1)

# Encontra a última ocorrência da letra 'A' na frase
# O método rfind() funciona da direita para a esquerda, 
# encontrando a última ocorrência da letra.
# Adicionamos 1 ao resultado para que a posição seja exibida de acordo com o índice humano.
print('A última letra A apareceu na posição', f.rfind('A')+1)

```
Digite uma fraze:Olá mundo! A a. 
A letra "a" aparece 2 vezes.
A letra "a" arece ne primeira ves: 12
A ultima letra A apareceu na posição 14


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (27).md
### Última modificação: 2024-08-07 16:49:44

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Solicita ao usuário que digite seu nome completo e armazena na variável 'n'
#strip() remove espaços em branco no início e no final da string, garantindo que o nome seja armazenado corretamente.
n = input('Qual seu nome todo:').strip()

# Separa o nome completo em uma lista de strings, onde cada elemento é uma palavra
# e armazena na variável 'e'
# split() divide a string n (nome completo) em uma lista de strings, usando o espaço em branco como delimitador.
e = n.split()

# Imprime o primeiro nome da lista, que é o elemento de índice 0
print('Seu primeiro nome é:', e[0])

# Encontra a última ocorrência de um espaço em branco no nome completo
# e adiciona 1 ao índice, para obter o índice do primeiro caractere do último nome
#rfind(' ') encontra a última ocorrência de um espaço em branco na string n.
f = n.rfind(' ') + 1

# Imprime o último nome, que é a substring do nome completo a partir do índice 'f' até o final
print('Seu ultimo nome é:', n[f:])

```
João da Silva Santos
Seu primeiro nome é: João
Seu ultimo nome é: Santos

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (28).md
### Última modificação: 2024-08-06 16:35:42

---
tags: 
data: 2024-08-06
nivel:
---
```Python



```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (29).md
### Última modificação: 2024-08-07 16:54:04

---
tags: 
data: 2024-08-06
nivel:
---
```Python

import random  # Importa a biblioteca 'random' para gerar números aleatórios.

print("-=-" * 17)  # Imprime uma linha de separação com "-" para melhorar a apresentação.
print("O jogo é, adivinhe o valor aleatorio(entre 1 a 5)")  # Imprime as instruções do jogo.
print("-=-" * 17)  # Imprime outra linha de separação.

n = random.randrange(5)  # Gera um número aleatório entre 0 e 4 (inclusive) e atribui à variável 'n'.
v = int(input("Digite o seu chute:"))  # Solicita ao usuário que digite um número e converte para inteiro.

if n == v:  # Verifica se o número digitado pelo usuário é igual ao número aleatório.
    print("parabens você acertou!")  # Se forem iguais, imprime uma mensagem de parabéns.
else:  # Caso contrário (se os números forem diferentes)
    print("A maquina venceu, o numero é {}".format(n))  # Imprime uma mensagem de derrota e revela o número aleatório.

```
1. **O programa gera um número aleatório entre 0 e 4.** Digamos que o número seja 3.
    
2. **O programa pede para o usuário digitar um número.** O usuário digita 2.
    
3. **O programa compara o número digitado com o número aleatório.** Como 2 é diferente de 3, o programa imprime a mensagem "A maquina venceu, o numero é 3".

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (30).md
### Última modificação: 2024-12-31 01:31:19

---
tags:
  - Programação
data: 2024-08-06
nivel:
---
```Python

# Solicita ao usuário que digite um número inteiro e armazena o valor na variável 'n'
n = int(input("Digite um numero: "))

# Verifica se o resultado da divisão inteira de 'n' por 2 é igual ao resultado da divisão de 'n' por 2
# Se sim, o número é par; caso contrário, é ímpar.
if n // 2 == n / 2:
    # Se o número for par, imprime a mensagem "Este numero é par"
    print("Este numero é par")
else:
    # Se o número for ímpar, imprime a mensagem "Este numero é impar."
    print("Este numero é impar.")

```
dis se um numero é impar ou par. 

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (31).md
### Última modificação: 2024-08-07 16:56:47

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Pede ao usuário para inserir a distância da viagem em km
distancia = int(input("Digite a distância de sua viagem (em km): "))

# Verifica se a distância é menor ou igual a 200 km
if distancia <= 200:
    # Se a distância for menor ou igual a 200 km, calcula o preço da passagem a R$0,50 por km
    preco_passagem = distancia * 0.50
    # Imprime o preço da passagem formatado com duas casas decimais
    print("O valor da sua passagem é de R$ {:.2f}".format(preco_passagem))
else:
    # Se a distância for maior que 200 km, calcula o preço da passagem a R$0,45 por km
    preco_passagem = distancia * 0.45
    # Imprime o preço da passagem formatado com duas casas decimais
    print("O valor da sua passagem é de R$ {:.2f}".format(preco_passagem))

```
Digite a distancia de sua viagem:150
O valor da sua passagem é de R$75.00

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (32).md
### Última modificação: 2024-08-07 16:57:44

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Importa a biblioteca datetime para obter o ano atual
import datetime

# Imprime uma mensagem introdutória ao usuário
print("Irei descobrir se o ano que você digitar é bissexto ou não")

# Solicita ao usuário que digite um ano
a = int(input("Digite um ano:"))

# Verifica se o ano digitado é 0
# Se for, define a variável "a" como o ano atual
if a == 0:
    a = datetime.date.today().year

# Verifica se o ano é bissexto usando as regras:
# - Se o ano for divisível por 4 e não for divisível por 100, ele é bissexto.
# - Se o ano for divisível por 400, ele também é bissexto.
if a // 4 == a / 4 and a // 100 != a / 100 or a / 400 == a // 400:
    # Imprime uma mensagem informando que o ano é bissexto
    print("{} é bissexto!".format(a))
else:
    # Imprime uma mensagem informando que o ano não é bissexto
    print("{} não é bissexto.".format(a))

```
Irei descobrir se o ano que você digitar é bissexto ou não
Digite um ano: 2024
2024 é bissexto!

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (33).md
### Última modificação: 2024-08-07 16:58:59

---
tags: 
data: 2024-08-06
nivel:
---
```Python

#  Faça um programa que leia três números e mostre qual é o maior e qual é o menor.

# Pede ao usuário para digitar três números inteiros e armazena-os nas variáveis a, b e c
a = int(input("Digite um numero: ")) 
b = int(input("Digite um numero: "))
c = int(input("Digite um numero: "))

# Inicializa a variável 'menor' com o valor de 'a'.
# Supomos que 'a' é o menor número por enquanto.
menor = a 

# Verifica se 'b' é menor que 'a' e 'c'. Se sim, atualiza 'menor' para 'b'.
if b < a and b < c:
    menor = b

# Verifica se 'c' é menor que 'a' e 'b'. Se sim, atualiza 'menor' para 'c'.
if c < a and c < b:
    menor = c

# Inicializa a variável 'maior' com o valor de 'a'.
# Supomos que 'a' é o maior número por enquanto.
maior = a 

# Verifica se 'b' é maior que 'a' e 'c'. Se sim, atualiza 'maior' para 'b'.
if b > a and b > c:
    maior = b

# Verifica se 'c' é maior que 'a' e 'b'. Se sim, atualiza 'maior' para 'c'.
if c > a and c > b:
    maior = c

# Imprime na tela o menor número encontrado
print("O menor numero é {}".format(menor))

# Imprime na tela o maior número encontrado
print("O maior numero é {}".format(maior))

```
**Entrada**
- a = 5
    
- b = 1
    
- c = 3
    

**Saída:**

- O menor numero é 1
    
- O maior numero é 5

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (34).md
### Última modificação: 2024-08-07 17:01:03

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Solicita ao usuário que digite o salário.
s = int(input("Digite seu salário: "))

# Verifica se o salário é inferior ou igual a R$1250,00.
if s <= 1250:
    # Se o salário for inferior ou igual a R$1250,00, calcula o aumento de 15%.
    # Multiplica o salário por 0.15 (15%) para obter o valor do aumento.
    # Soma o valor do aumento ao salário original para obter o novo salário.
    s2 = (s * 0.15) + s 
    # Imprime a mensagem com o valor do aumento e o novo salário.
    print("Você receberá um aumento de R$ {:.2f} para R$ {:.2f}".format(s * 0.15, s2))
else:
    # Se o salário for superior a R$1250,00, calcula o aumento de 10%.
    # Multiplica o salário por 0.10 (10%) para obter o valor do aumento.
    # Soma o valor do aumento ao salário original para obter o novo salário.
    s2 = (s * 0.10) + s
    # Imprime a mensagem com o valor do aumento e o novo salário.
    print("Você receberá um aumento de R$ {:.2f} para R$ {:.2f}".format(s * 0.10, s2))

```
Digite seu salário: 1000
Você receberá um aumento de R$ 150.00 para R$ 1150.00

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (35).md
### Última modificação: 2024-08-07 17:01:49

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Imprime uma mensagem inicial para o usuário
print("Vou dizer se 3 valores formam um triângulo. ")

# Solicita ao usuário que insira três números inteiros representando os comprimentos das retas
a = int(input("Digite um numero:"))
b = int(input("Digite um numero:"))
c = int(input("Digite um numero:"))

# Verifica se a soma de quaisquer dois lados é maior que o terceiro lado.
# Essa é a condição necessária para que os três lados formem um triângulo.
if a + b > c and a + c > b and b + c > a:
    # Se a condição for verdadeira, imprime uma mensagem informando que os lados formam um triângulo.
    print("Os valores {}cm, {}cm e {}cm, formam um triangulo.".format(a, b, c))
else:
    # Se a condição for falsa, imprime uma mensagem informando que os lados não formam um triângulo.
    print("Os valores {}cm, {}cm e {}cm, não formam um triangulo.".format(a, b, c))

```
**Entrada:**

- a = 5
    
- b = 7
    
- c = 3
    

**Saída:**

- Os valores 5cm, 7cm e 3cm, formam um triângulo.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (36).md
### Última modificação: 2024-08-07 17:17:09

---
tags: 
data: 2024-08-06
nivel:
---
```Python

print('$'*60)  # Imprime uma linha de 60 caracteres '$' para fins de formatação visual
print('Olá sou do banco Itanu, vim aqui te dar um emprestimo.')  # Mensagem de boas-vindas ao usuário

salario = float(input('Qual seu salario mensal:'))  # Solicita ao usuário o salário mensal e converte a entrada para um número de ponto flutuante
valor_casa = float(input('Qual o valor da casa que quer comprar:'))  # Solicita o valor da casa desejada e converte para um número de ponto flutuante
prazo_anos = int(input('Em quantos anos quer pagar:'))  # Solicita o prazo do financiamento em anos e converte para um número inteiro

# Cálculo do limite máximo da parcela: 30% do salário
limite_parcela = salario * 0.3  # Calcula o limite máximo da parcela como 30% do salário

# Conversão de anos para meses
prazo_meses = prazo_anos * 12  # Calcula o prazo do financiamento em meses

# Cálculo do valor da parcela mensal
valor_parcela = valor_casa / prazo_meses  # Calcula o valor da parcela mensal dividindo o valor da casa pelo número de meses

# Verificação da aprovação do financiamento
if valor_parcela >= limite_parcela:  # Verifica se o valor da parcela excede o limite máximo
    print('Seu financiamento não foi liberado')  # Imprime uma mensagem informando que o financiamento foi negado
else:
    print('Seu financiamento foi aprovado!')  # Imprime uma mensagem informando que o financiamento foi aprovado
    print('Você deverar pagar por mes o valor de {:.2f}reais por {:.0f}meses'.format(valor_parcela, prazo_meses))  # Imprime o valor da parcela e o prazo do financiamento em meses
    print('$' * 60)  # Imprime outra linha de 60 caracteres '$' para fins de formatação visual

```
Olá sou do banco Itanu, vim aqui te dar um emprestimo.
Qual seu salario mensal:4000
Qual o valor da casa que quer comprar:40000
Em quantos anos quer pagar:4
Seu financiamento foi aprovado!
Você deverar pagar por mes o valor de 833.33reais por 48meses


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (37).md
### Última modificação: 2024-08-07 17:19:25

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Obter o número inteiro do usuário
n = int(input('Digite um número: '))

# Perguntar ao usuário qual base de conversão ele deseja
print('Qual conversão quer fazer?')
c = int(input('1 para binário, 2 para octal e 3 para hexadecimal: '))

# Conversão para binário
if c == 1:
    # Calcular os dígitos binários
    d1 = n // 2  # Divisão inteira por 2 para obter o próximo dígito
    d2 = d1 // 2
    d3 = d2 // 2
    d4 = d3 // 2
    d5 = d4 // 2
    d6 = d5 // 2
    d7 = d6 // 2
    d8 = d7 // 2
    n1 = n % 2  # Resto da divisão por 2 para obter o primeiro dígito
    n2 = d1 % 2
    n3 = d2 % 2
    n4 = d3 % 2
    n5 = d4 % 2
    n6 = d5 % 2
    n7 = d6 % 2
    n8 = d7 % 2

    # Exibir o número binário
    print('Seu número em binário é: {}{}{}{}{}{}{}{}'.format(n8, n7, n6, n5, n4, n3, n2, n1))

# Conversão para octal
elif c == 2:
    # Calcular os dígitos octais
    d1 = n // 8  # Divisão inteira por 8 para obter o próximo dígito
    d2 = d1 // 8
    d3 = d2 // 8
    d4 = d3 // 8
    d5 = d4 // 8
    d6 = d5 // 8
    d7 = d6 // 8
    d8 = d7 // 8
    n1 = n % 8  # Resto da divisão por 8 para obter o primeiro dígito
    n2 = d1 % 8
    n3 = d2 % 8
    n4 = d3 % 8
    n5 = d4 % 8
    n6 = d5 % 8
    n7 = d6 % 8
    n8 = d7 % 8

    # Exibir o número octal
    print('Seu número em octal é: {}{}{}{}{}{}{}{}'.format(n8, n7, n6, n5, n4, n3, n2, n1))

# Conversão para hexadecimal
elif c == 3:
    # Utilizar a função built-in 'hex' para converter para hexadecimal
    print('Seu número em hexadecimal é: {}'.format(hex(n)))

```
Digite um número: 15
Qual conversão quer fazer?
1 para binário, 2 para octal e 3 para hexadecimal: 1
Seu número em binário é: 1111

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (38).md
### Última modificação: 2024-08-07 17:20:53

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Pede ao usuário para digitar o primeiro número e converte para inteiro
n1 = int(input("Digite o primeiro número: "))

# Pede ao usuário para digitar o segundo número e converte para inteiro
n2 = int(input("Digite o segundo número: "))

# Verifica se o primeiro número é maior que o segundo
if n1 > n2:
    # Se o primeiro número for maior, imprime a mensagem
    print("O primeiro valor é o maior")

# Verifica se o segundo número é maior que o primeiro
elif n2 > n1:
    # Se o segundo número for maior, imprime a mensagem
    print("O segundo valor é o maior.")

# Se nenhuma das condições anteriores for verdadeira, os números são iguais
else:
    # Imprime a mensagem indicando que os números são iguais
    print("Os dois valores são iguais")

```
1. **Entrada:**
    
    - O usuário digita 10 para o primeiro número.
        
    - O usuário digita 5 para o segundo número.
        
2. **Processamento:**
    
    - O programa compara 10 e 5.
        
    - A condição n1 > n2 (10 > 5) é verdadeira.
        
3. **Saída:**
    
    - O programa imprime a mensagem: "O primeiro valor é o maior".


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (39).md
### Última modificação: 2024-08-07 17:23:35

---
tags: 
data: 2024-08-06
nivel:
---
```Python

import datetime

# Pede ao usuário para inserir o ano de nascimento
ano_nascimento = int(input("Diga o ano em que nasceu: "))

# Calcula a idade atual do usuário
idade_atual = datetime.date.today().year - ano_nascimento

# Verifica se o usuário precisa se alistar, já se alistou ou se está atrasado
if idade_atual < 18:
    # Se a idade for menor que 18 anos, o usuário ainda vai se alistar
    tempo_falta = 18 - idade_atual
    print(f"Você ainda vai se alistar, faltam {tempo_falta} anos.")
elif idade_atual == 18:
    # Se a idade for 18 anos, é a hora de se alistar
    print("Esta é a hora exata de se alistar.")
else:
    # Se a idade for maior que 18 anos, o tempo de alistamento já passou
    tempo_passado = idade_atual - 18
    print(f"O tempo de se alistar já passou em {tempo_passado} anos.")

```
Diga o ano em que nasceu: 2005
Você ainda vai se alistar, faltam 3 anos.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (40).md
### Última modificação: 2024-08-07 17:25:48

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Objetivo: Ler duas notas de um aluno, calcular a média e exibir a situação (Aprovado, Reprovado ou Recuperação).

# Solicita ao usuário que digite a primeira nota e converte a entrada para um número de ponto flutuante.
n1 = float(input("Digite a primeira nota: "))

# Solicita ao usuário que digite a segunda nota e converte a entrada para um número de ponto flutuante.
n2 = float(input("Digite a segunda nota: "))

# Calcula a média das duas notas.
media = (n1 + n2) / 2

# Verifica a média e exibe a situação do aluno com cores diferentes para cada caso.
if media >= 7:
  # Se a média for 7 ou superior, o aluno está aprovado.
  print('\033[32m' + 'Sua média é {} você Foi aprovado'.format(media) + '\033[0;0m'.format(media))
  print('\033[32m' + 'PARABENS!!' + '\033[0;0m')
elif media >= 5.1 and media <= 6.9:
  # Se a média estiver entre 5.1 e 6.9, o aluno está em recuperação.
  print('\033[33m' + 'Sua média é {} você esta de recuperação.'.format(media) + '\033[0;0m'.format(media))
elif media <= 5:
  # Se a média for 5 ou inferior, o aluno está reprovado.
  print('\033[31m' + 'Sua média é {} você Foi reprovado.'.format(media) + '\033[0;0m'.format(media))



```
 Exemplo simples do funcionamento:
 Digite a primeira nota: 6
 Digite a segunda nota: 4
 Sua média é 5.0 você esta de recuperação.  

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (41).md
### Última modificação: 2024-08-07 17:26:47

---
tags: 
data: 2024-08-06
nivel:
---
```Python

import datetime

# Imprime uma mensagem de boas-vindas ao usuário
print("Este programa dirá qual sua categoria na natação.")

# Solicita ao usuário que digite o ano de nascimento
ano_nascimento = int(input("Qual ano você nasceu: "))

# Obtém o ano atual usando a biblioteca datetime
ano_atual = datetime.date.today().year

# Calcula a idade do atleta
idade = ano_atual - ano_nascimento

# Verifica a categoria do atleta com base na idade
if idade <= 9:
    categoria = "MIRIM"
elif idade <= 14:
    categoria = "INFANTIL"
elif idade <= 19:
    categoria = "JÚNIOR"
elif idade <= 25:
    categoria = "SÊNIOR"
else:
    categoria = "MASTER"

# Imprime a categoria do atleta
print(f"Sua categoria é: {categoria}")

```
Este programa dirá qual sua categoria na natação. Qual ano você nasceu: 2005 
Sua categoria é: JÚNIOR

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (42).md
### Última modificação: 2024-08-06 16:35:42

---
tags: 
data: 2024-08-06
nivel:
---
```Python



```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (43).md
### Última modificação: 2024-08-07 17:28:18

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Título do programa
print("Vou dizer se 3 valores formam um triângulo. ")
print("E que tipo de triângulo é.")

# Solicita ao usuário que insira três valores inteiros representando os lados do triângulo
a = int(input("Digite um numero: "))
b = int(input("Digite um numero: "))
c = int(input("Digite um numero: "))

# Verifica se os valores inseridos formam um triângulo, utilizando a desigualdade triangular
if a + b > c and a + c > b and b + c > a:
    # Se formar um triângulo, imprime a mensagem e o tipo de triângulo
    print("Os valores {}cm, {}cm e {}cm, formam um triangulo.".format(a, b, c))
    # Verifica se o triângulo é equilátero (todos os lados iguais)
    if a == b and a == c and c == b:
        print('EQUILÁTERO')
    # Verifica se o triângulo é isósceles (dois lados iguais, um diferente)
    elif a == b or b == a or c == a or c == b:
        print('ISÓSCELES')
    # Se não é equilátero nem isósceles, então é escaleno (todos os lados diferentes)
    else:
        print('ESCALENO')
# Se os valores não formarem um triângulo, imprime a mensagem
else:
    print("Os valores {}cm, {}cm e {}cm, não formam um triangulo.".format(a, b, c))

```
**Entrada:**

- a = 5
    
- b = 5
    
- c = 7
    

**Saída:**

Os valores 5cm, 5cm e 7cm, formam um triangulo.
ISÓSCELES


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (44).md
### Última modificação: 2024-08-07 17:29:37

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Solicita o valor total das compras do usuário
valor_compras = float(input('Quanto foi suas compras: '))

# Apresenta as opções de pagamento ao usuário
print('[ 1 ] dinheiro ou cheque')
print('[ 2 ] à vista no cartão')
print('[ 3 ] em 2x no cartão')
print('[ 4 ] 3x ou mais no cartão')

# Solicita ao usuário a escolha da forma de pagamento
opcao_pagamento = int(input('Qual formato de pagamento: '))

# Calcula o valor final a ser pago de acordo com a opção escolhida
if opcao_pagamento == 1:
    # Desconto de 10% para pagamento à vista em dinheiro ou cheque
    valor_final = valor_compras * 0.9
    print('Você pagará {:.2f}'.format(valor_final))  # Exibe o valor final com duas casas decimais

elif opcao_pagamento == 2:
    # Desconto de 5% para pagamento à vista no cartão
    valor_final = valor_compras * 0.95
    print('Você pagará {:.2f}'.format(valor_final))

elif opcao_pagamento == 3:
    # Parcelamento em 2x sem juros
    valor_parcela = valor_compras / 2
    print('Você pagará 2x de {:.2f}'.format(valor_parcela))

elif opcao_pagamento == 4:
    # Solicita o número de parcelas para pagamento em 3x ou mais
    numero_parcelas = int(input('Em quantas vezes você pagará?: '))
    # Calcula o valor da parcela com juros de 20%
    valor_parcela = (valor_compras * 1.2) / numero_parcelas
    print('Você pagará {:.2f} em {} vezes'.format(valor_parcela, numero_parcelas))

# Caso o usuário digite uma opção inválida
else:
    print('Opção de pagamento inválida.')

```
Quanto foi suas compras: 100
[ 1 ] dinheiro ou cheque
[ 2 ] à vista no cartão
[ 3 ] em 2x no cartão
[ 4 ] 3x ou mais no cartão
Qual formato de pagamento: 4
Em quantas vezes você pagará?: 3
Você pagará 40.00 em 3 vezes

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (45).md
### Última modificação: 2024-08-07 17:31:24

---
tags: 
data: 2024-08-06
nivel:
---
```Python

import random  # Importa a biblioteca 'random' para gerar números aleatórios.

print("""Joqueipô
[1] Pedra
[2] Papel
[3] Tesoura""")  # Imprime as opções do jogo para o usuário.

e = int(input("Qual escolhe:"))  # Solicita ao usuário para digitar sua escolha (1, 2 ou 3) e converte para inteiro.

# Define as constantes para as opções do jogo:
r = 1  # Pedra
p = 2  # Papel
t = 3  # Tesoura

# Cria uma tupla 'p' com as opções do jogo (Pedra, Papel, Tesoura).
p = (r, p, t) 

# Gera uma escolha aleatória da máquina utilizando a função 'random.choice()'.
u = random.choice(p)

# Verifica o resultado do jogo:
if e == u:  # Se a escolha do usuário for igual à da máquina:
    print("A maquina escolheu {}".format(u))  # Imprime a escolha da máquina.
    print("Empatou")  # Imprime o resultado.
elif (e == 1 and u == 3) or (e == 2 and u == 1) or (e == 3 and u == 2):  # Se o usuário vencer:
    print("A maquina escolheu {}".format(u))  # Imprime a escolha da máquina.
    print("Você venceu!")  # Imprime o resultado.
elif (e == 1 and u == 2) or (e == 2 and u == 3) or (e == 3 and u == 1):  # Se o usuário perder:
    print("A maquina escolheu {}".format(u))  # Imprime a escolha da máquina.
    print("Você perdeu!")  # Imprime o resultado.

```
Joqueipô
[1] Pedra
[2] Papel
[3] Tesoura
Qual escolhe:3
A maquina escolheu 1
Você perdeu!

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (46).md
### Última modificação: 2024-08-07 17:32:51

---
tags: 
data: 2024-08-06
nivel:
---
```Python

import time  # Importa a biblioteca 'time' para utilizar funções relacionadas ao tempo.

# Exibe uma mensagem na tela avisando sobre o início da contagem regressiva.
print('Os fogos serão lançados em 10 segundos')

# Aguarda 1 segundo antes de iniciar a contagem.
time.sleep(1)

# Loop 'for' para iterar de 10 a 0, decrementando de 1 em 1.
for c in range(10, -1, -1):
    # Exibe o valor atual do contador 'c' na tela.
    print(c)

    # Verifica se o contador 'c' atingiu 0.
    if c == 0:
        # Se o contador for 0, interrompe o loop.
        break

    # Aguarda 0.3 segundos antes de exibir o próximo número.
    time.sleep(0.3)

# Após a contagem regressiva, exibe a mensagem "Fogo".
print('Fogo')

```

Os fogos serão lançados em 10 segundos
10
9
8
7
6
5
4
3
2
1
0
Fogo

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (47).md
### Última modificação: 2024-08-07 17:34:00

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Este programa irá imprimir todos os números pares no intervalo de 1 a 50.

# O loop 'for' irá iterar através de um intervalo de números.
# O 'range(2, 51, 2)' define o intervalo de números a serem iterados.
# 2 é o valor inicial, 51 é o valor final (exclusivo) e 2 é o passo (incremento).
for c in range(2, 51, 2):
    # A cada iteração, o valor atual de 'c' será impresso.
    # O 'end=' ' ' irá adicionar um espaço em branco após cada número, em vez de uma nova linha.
    print(c, end=' ')

# Este programa irá imprimir os seguintes números:
# 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50

```
2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (48).md
### Última modificação: 2024-08-07 17:35:31

---
tags: 
data: 2024-08-06
nivel:
---
```Python

#  Faça um programa que calcule a soma entre todos os números que
# impares que são múltiplos de três e que se encontram no intervalo de 1 até 500.

# Inicializa a variável 's' (soma) com 0.
s = 0

# Inicializa a variável 'cont' (contador) com 0.
cont = 0

# Itera sobre os números ímpares de 1 a 500.
# 'range(1, 500, 2)' gera uma sequência de números ímpares: 1, 3, 5, 7, ... , 499.
for c in range(1, 500, 2):
    # Verifica se o número 'c' é múltiplo de 3.
    # A divisão inteira (//) e a divisão normal (/) são comparadas.
    # Se 'c' for múltiplo de 3, o resultado da divisão inteira será igual ao resultado da divisão normal.
    if c // 3 == c / 3:
        # Se 'c' é múltiplo de 3, incrementa o contador 'cont'.
        cont = cont + 1

        # Adiciona 'c' à soma 's'.
        s += c

# Imprime a soma de todos os valores encontrados e a quantidade de valores encontrados.
print('A soma de todos os {} valores solicitados é {} '.format(cont,s))

```
A soma de todos os 83 valores solicitados é 20667 

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (49).md
### Última modificação: 2024-08-07 17:56:22

---
tags: 
data: 2024-08-06
nivel:
---
```Python

#  mostrando a tabuada de um número que o usuário escolher, só que agora utilizando um laço for.

# Pede ao usuário para inserir um número inteiro e armazena o valor na variável 't'.
t = int(input('Qual numero:'))

# Inicia um laço 'for' que itera 10 vezes (de 1 a 10).
# A variável 'c' assume os valores de 1 a 10 em cada iteração do laço.
for c in range(1,11):
    # Imprime a tabuada na tela.
    # A string 't', 'X', 'c', '=', c * t' é formatada e impressa.
    print(t, 'X', c, '=', c * t)

```
5 X 1 = 5
5 X 2 = 10
5 X 3 = 15
5 X 4 = 20
5 X 5 = 25
5 X 6 = 30
5 X 7 = 35
5 X 8 = 40
5 X 9 = 45
5 X 10 = 50

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (5).md
### Última modificação: 2024-08-06 18:16:34

---
tags: 
data: 2024-08-06
nivel:
---
```Python
# Solicita ao usuário que digite um número inteiro e armazena o valor na variável "num".
num = int(input('Qual numero?:'))

# Imprime na tela uma mensagem formatada com o número digitado e seu sucessor.
# A função "format()" substitui os "{}" pela variável "num" e "num + 1", respectivamente.
print('O sucessor de {} é {}'.format(num, num + 1))

# Imprime na tela uma mensagem formatada com o número digitado e seu antecessor.
# A função "format()" substitui os "{}" pela variável "num" e "num - 1", respectivamente.
print('O antecessor de {} é {}'.format(num, num - 1))

```
**Exemplo de funcionamento:**

1. **Entrada:** O usuário digita o número 5.
    
2. **Processamento:** O programa armazena o número 5 na variável num.
    
    - Calcula o sucessor: num + 1 = 5 + 1 = 6
        
    - Calcula o antecessor: num - 1 = 5 - 1 = 4
        
3. **Saída:** O programa imprime as seguintes mensagens na tela:
    
    - "O sucessor de 5 é 6"
        
    - "O antecessor de 5 é 4"



reescreva e faça comentários minuciosos do programa acima e faça um exemplo simples do funcionamento.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (50).md
### Última modificação: 2024-08-07 17:57:51

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Inicializa a variável 't' para armazenar a soma dos números pares
t = 0

# Loop para ler 6 números inteiros
for c in range(0, 6):
    # Lê um número inteiro do usuário
    n = int(input('Digite um número: '))

    # Verifica se o número é par
    # Se o número dividido por 2 for igual ao número dividido por 2 usando a divisão inteira (//), então o número é par
    if n / 2 == n // 2:
        # Se o número for par, adiciona-o à variável 't'
        t = n + t

# Imprime a soma dos números pares
print(t)

```
5 X 1 = 5
5 X 2 = 10
5 X 3 = 15
5 X 4 = 20
5 X 5 = 25
5 X 6 = 30
5 X 7 = 35
5 X 8 = 40
5 X 9 = 45
5 X 10 = 50

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (51).md
### Última modificação: 2024-08-07 17:59:54

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Desenvolva um programa que leia o primeiro termo e a razão de uma PA. No final,
# mostre os 10 primeiros termos dessa progressão.

# Pede ao usuário para inserir o primeiro termo da PA
p = int(input('Primeiro termo:')) 

# Pede ao usuário para inserir a razão da PA
r = int(input('Razão:')) 

# Calcula o décimo termo da PA
# Fórmula: a_n = a_1 + (n - 1) * r
# onde:
#   a_n é o n-ésimo termo da PA
#   a_1 é o primeiro termo da PA
#   n é o número do termo que queremos encontrar (no nosso caso, 10)
#   r é a razão da PA
d = p + (10 - 1) * r 

# Itera sobre os termos da PA, imprimindo cada um deles
# O loop 'for' itera sobre um intervalo de números, começando pelo primeiro termo 'p' 
# e incrementando a cada passo pela razão 'r'
# O loop termina quando o último termo a ser impresso é 'd'
for c in range(p, d + r, r):
    print(c, end=' ')

# Imprime uma mensagem indicando o fim da sequência
print('Acabou') 

```
primeiro termo:2
Razão:3
2 5 8 11 14 17 20 23 26 29 Acabou

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (52).md
### Última modificação: 2024-08-07 18:01:17

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Pede ao usuário para inserir um número inteiro.
num = int(input("Digite um número: "))

# Inicializa um contador para rastrear o número de divisores do número.
contador = 0

# Itera sobre todos os números de 1 até o número inserido.
for i in range(1, num + 1):
    # Verifica se o número é divisível pelo número atual (i).
    if num % i == 0:
        # Se o número é divisível, incrementa o contador.
        contador += 1

# Imprime o número e quantas vezes ele foi divisível.
print("O número {} foi divisível {} vezes!".format(num, contador))

# Se o contador for igual a 2, significa que o número só é divisível por 1 e por ele mesmo,
# portanto, é um número primo.
if contador == 2:
    print("O número é primo")
# Caso contrário, o número não é primo.
else:
    print("O número não é primo")

```
Digite um número: 78
O número 78 foi divisível 8 vezes!
O número não é primo

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (53).md
### Última modificação: 2024-08-07 18:11:05

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Solicita ao usuário que digite uma frase e converte para letras maiúsculas
f = input('Digite a frase:').upper()

# Remove todos os espaços da frase
f = f.split() # Divide a frase em uma lista de palavras
j = "".join(f) # Junta as palavras novamente sem espaços

# Inverte a frase
i = ''
for letra in range(len(j) - 1, -1, -1): # Itera pelas letras da frase, da última para a primeira
    i += j[letra] # Adiciona cada letra à string invertida

# Compara a frase original com a invertida
if i == j:
    print("Temos um palíndromo!")
else:
    print('Não temos um palíndromo"')

```
Digite a fraze: aja
Temos um palindromo!

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (54).md
### Última modificação: 2024-08-07 18:12:19

---
tags: 
data: 2024-08-06
nivel:
---
```Python

import datetime  # Importa a biblioteca datetime para trabalhar com datas.

# Inicializa as variáveis que contarão as pessoas maiores e menores de idade.
maiores_de_idade = 0
menores_de_idade = 0

# Loop para ler o ano de nascimento de 7 pessoas.
for pessoa in range(1, 8):  # Itera de 1 a 7 para representar cada pessoa.
    ano_nascimento = int(input(f'Qual o ano de nascimento da {pessoa}ª pessoa: '))  # Lê o ano de nascimento da pessoa.

    # Calcula a idade da pessoa.
    idade = datetime.date.today().year - ano_nascimento  # Obtem o ano atual e subtrai o ano de nascimento.

    # Verifica se a pessoa é maior ou menor de idade.
    if idade >= 18:  # Se a idade for maior ou igual a 18, a pessoa é maior de idade.
        maiores_de_idade += 1  # Incrementa o contador de maiores de idade.
    else:  # Caso contrário, a pessoa é menor de idade.
        menores_de_idade += 1  # Incrementa o contador de menores de idade.

# Imprime o resultado.
print(f'{maiores_de_idade} pessoas atingiram a maior idade.')  # Exibe a quantidade de pessoas maiores de idade.
print(f'{menores_de_idade} pessoas ainda não atingiram a maior idade.')  # Exibe a quantidade de pessoas menores de idade.

```
- Pessoa 1: 2005
    
- Pessoa 2: 2003
    
- Pessoa 3: 2000
    
- Pessoa 4: 2008
    
- Pessoa 5: 1999
    
- Pessoa 6: 2002
    
- Pessoa 7: 2006
    

O programa irá solicitar o ano de nascimento de cada pessoa e calcular a idade. No final, mostrará que 3 pessoas atingiram a maioridade e 4 pessoas ainda não.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (55).md
### Última modificação: 2024-08-07 18:13:13

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Inicializa as variáveis para armazenar o maior e o menor peso
maior_peso = 0
menor_peso = 0

# Define o número de pessoas a serem pesadas (5 neste caso)
numero_pessoas = 5

# Inicia um loop que itera por cada pessoa
for i in range(numero_pessoas):
    # Incrementa o contador da pessoa (começando em 1)
    i += 1
    # Lê o peso da pessoa atual
    peso = float(input(f'Qual o peso da {i}ª pessoa: '))

    # Na primeira iteração (i = 1), atribui o peso atual como maior e menor
    if i == 1:
        menor_peso = peso
        maior_peso = peso
    else:
        # Se o peso atual for maior que o maior peso atual, atualiza o maior peso
        if peso > maior_peso:
            maior_peso = peso
        # Se o peso atual for menor que o menor peso atual, atualiza o menor peso
        elif peso < menor_peso:
            menor_peso = peso

# Imprime o maior e o menor peso encontrados
print(f"""O maior peso é {maior_peso}Kg
O menor peso é {menor_peso}Kg""")

```
Suponha que os pesos das 5 pessoas sejam:

- Pessoa 1: 70 kg
    
- Pessoa 2: 65 kg
    
- Pessoa 3: 75 kg
    
- Pessoa 4: 60 kg
    
- Pessoa 5: 68 kg
    

O programa executará os passos descritos acima e imprimirá:

```
O maior peso é 75Kg
O menor peso é 60Kg
```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (56).md
### Última modificação: 2024-08-07 18:14:38

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Inicializa as variáveis para armazenar informações:
# - 'h' (homem mais velho): idade do homem mais velho (começa com 0, será atualizada)
# - 'me' (média): soma das idades (começa com 0, será acumulada)
# - 'sm' (mulheres menores de 20): contagem de mulheres com menos de 20 anos (começa com 0, será incrementada)
# - 'r' (quantidade de pessoas): define o número de pessoas a serem analisadas (4 nesse caso)
h = 0
me = 0
sm = 0
r = 4

# Loop para coletar informações de cada pessoa (4 iterações)
for x in range(1, r + 1):
    print('------{}ªPessoa------'.format(x))  # Mostra o número da pessoa atual

    # Coleta os dados da pessoa: nome, idade e sexo
    n = str(input('Qual o nome: '))
    i = float(input('Qual sua idade:'))
    s = str(input('Qual sexo(M/F)'))

    # Acumula a idade da pessoa na variável 'me' (soma das idades)
    me = i + me

    # Verifica se a pessoa é do sexo masculino ('M' ou 'm')
    if s == 'M' or s == 'm':
        # Se for o primeiro homem, armazena sua idade em 'h'
        if x == 1:
            h = i
        # Se não for o primeiro homem, compara a idade atual com a idade do homem mais velho ('h')
        else:
            if i > h:
                # Se a idade atual for maior que 'h', atualiza 'h' com a idade atual e o nome do homem mais velho em 'nh'
                h = i
                nh = ('O homem mais velho é o {}, ele tem {} anos.'.format(n, h))

    # Se a pessoa for do sexo feminino
    else:
        # Verifica se a idade é menor que 20 anos
        if i < 20:
            # Incrementa o contador de mulheres menores de 20 anos ('sm')
            sm += 1

# Imprime os resultados:
print('A media das idades é', me / r, 'anos')  # Calcula e imprime a média das idades
print(nh)  # Imprime o nome do homem mais velho e sua idade
print('Tem {} meninas com menos de 20 anos'.format(sm))  # Imprime o número de mulheres menores de 20 anos

```
------1ªPessoa------
Qual o nome: João
Qual sua idade:30
Qual sexo(M/F):M
------2ªPessoa------
Qual o nome: Maria
Qual sua idade:18
Qual sexo(M/F):F
------3ªPessoa------
Qual o nome: Pedro
Qual sua idade:25
Qual sexo(M/F):M
------4ªPessoa------
Qual o nome: Ana
Qual sua idade:16
Qual sexo(M/F):F
A media das idades é 22.25 anos
O homem mais velho é o João, ele tem 30 anos.
Tem 2 meninas com menos de 20 anos

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (57).md
### Última modificação: 2024-08-07 18:27:55

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# #  Faça um programa que leia o sexo de uma pessoa, mas só aceite os valores 'M' ou 'F'.

# #  Caso esteja errado, peça a digitação novamente até ter um valor correto.
  

s = str(input("Qual seu Sexo:")).strip().upper()[0]

while s not in "MmFf":

    s = str(input("Dados invalidos. Qual seu Sexo:")).strip().upper()[0]

print('Sexo {} foi registrado'.format(s))

```
Qual seu Sexo:masculino
Sexo M foi registrado

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (58).md
### Última modificação: 2024-08-07 18:29:14

---
tags: 
data: 2024-08-06
nivel:
---
```Python

import random  # Importa a biblioteca random para gerar números aleatórios

# Gera um número aleatório entre 1 e 10 (inclusive) e armazena na variável 'n'
n = random.randrange(1, 11)

# Inicializa a variável 'a' como False. 'a' será usada para controlar o loop while.
a = False

# Inicializa a variável 'c' como 1 para contar o número de tentativas.
c = 1

# Loop while que continua até que 'a' seja True (o jogador acerte o número).
while not a:
    # Incrementa a contagem de tentativas.
    c += 1
    
    # Pede ao jogador para digitar um chute e converte a entrada para inteiro.
    t = int(input('Digite novamente, seu chute: '))
    
    # Se o chute do jogador for igual ao número aleatório:
    if t == n:
        # Define 'a' como True para sair do loop.
        a = True
    
    # Se o chute do jogador for diferente do número aleatório:
    if n != t:
        # Informa ao jogador que ele errou.
        print('Você errou!')
    
    # Se o chute do jogador for menor que o número aleatório:
    if n > t:
        # Informa ao jogador que o número é "Mais...".
        print('Mais...')
    # Se o chute do jogador for maior que o número aleatório:
    elif n < t:
        # Informa ao jogador que o número é "Menos...".
        print('Menos...')

# Depois que o jogador acerta, imprime a mensagem com o número de tentativas.
print('Você precisou de {} tentativas para acertar.'.format(c))

```
1. **O programa escolhe um número aleatório entre 1 e 10.** Digamos que o número seja 7.
    
2. **O jogador é solicitado a digitar seu chute.** Digamos que ele digite 5.
    
3. **O programa informa que o jogador errou e que o número é "Mais...".**
    
4. **O jogador digita outro chute, digamos 8.**
    
5. **O programa informa que o jogador errou e que o número é "Menos...".**
    
6. **O jogador digita 7, e o programa informa que ele acertou.**
    
7. **O programa imprime a mensagem "Você precisou de 3 tentativas para acertar."**

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (59).md
### Última modificação: 2024-08-07 18:31:42

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Objetivo: Criar um programa que realiza operações matemáticas básicas entre dois números, 
# com um menu interativo para o usuário escolher a operação desejada.

# 1. Entrada de dados:
n = int(input("Digite o primeiro numero: "))  # Lê o primeiro número do usuário e converte para inteiro.
nn = int(input('Digite o segundo numero: ')) # Lê o segundo número do usuário e converte para inteiro.

# 2. Variável de controle do loop:
x = 0  # Inicializa a variável 'x' com 0 para controlar o loop while.

# 3. Loop principal:
while x != 5:  # O loop continua até que o usuário escolha a opção 5 (sair do programa).
    # 4. Apresentação do menu:
    print('''[ 1 ] somar
[ 2 ] multiplicar
[ 3 ] maior
[ 4 ] novos números
[ 5 ] sair do programa''')

    # 5. Leitura da opção do usuário:
    x = int(input('oque voce quer que aconteça? '))  # Lê a opção do usuário e converte para inteiro.

    # 6. Verificação da opção escolhida:
    if x == 1:  # Se o usuário escolheu 'somar' (opção 1):
        print('{} + {} = {}'.format(n, nn, n + nn))  # Exibe a soma dos dois números.
    elif x == 2:  # Se o usuário escolheu 'multiplicar' (opção 2):
        print('{} x {} = {}'.format(n, nn, n * nn))  # Exibe a multiplicação dos dois números.
    elif x == 3:  # Se o usuário escolheu 'maior' (opção 3):
        if n > nn:  # Se o primeiro número é maior que o segundo:
            print('Entre {} e {} o maior numero :{}'.format(n, nn, n))  # Exibe o primeiro número como o maior.
        else:  # Se o segundo número é maior ou igual ao primeiro:
            print('Entre {} e {} o maior numero :{}'.format(n, nn, nn))  # Exibe o segundo número como o maior.
    elif x == 4:  # Se o usuário escolheu 'novos números' (opção 4):
        n = int(input("Digite o primeiro numero: "))  # Lê um novo primeiro número.
        nn = int(input('Digite o segundo numero: '))  # Lê um novo segundo número.
    else:  # Se o usuário escolheu uma opção inválida:
        print("Opção invalida tente novamente")  # Exibe uma mensagem de erro.

    print('-=' * 50)  # Imprime uma linha separadora.

# 7. Mensagem de saída:
print('Acabou!')  # Exibe uma mensagem de saída quando o loop termina.

```
1. **Entrada de dados:**
    
    - O programa pede para o usuário digitar o primeiro número: 10
        
    - O programa pede para o usuário digitar o segundo número: 5
        
2. **Menu:**
    
    - O programa apresenta o menu com as opções: somar, multiplicar, maior, novos números, sair do programa.
        
3. **Opção "Somar":**
    
    - O usuário escolhe a opção 1 (somar).
        
    - O programa calcula 10 + 5 = 15 e exibe o resultado.
        
4. **Opção "Novos Números":**
    
    - O usuário escolhe a opção 4 (novos números).
        
    - O programa pede para o usuário digitar um novo primeiro número: 20
        
    - O programa pede para o usuário digitar um novo segundo número: 8
        
5. **Opção "Maior":**
    
    - O usuário escolhe a opção 3 (maior).
        
    - O programa compara 20 e 8 e exibe 20 como o maior número.
        
6. **Opção "Sair do Programa":**
    
    - O usuário escolhe a opção 5 (sair do programa).
        
    - O programa exibe a mensagem "Acabou!".

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (6).md
### Última modificação: 2024-08-07 14:39:55

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# O programa pede ao usuário para digitar um número inteiro.
n = int(input('Qual numero?: '))

# Calcula o dobro do número digitado.
dobro = n * 2

# Calcula o triplo do número digitado.
triplo = n * 3

# Calcula a raiz quadrada do número digitado. 
# A função `int()` é usada para converter o resultado para um inteiro.
raiz_quadrada = int(n ** (1 / 2))

# Imprime o dobro do número.
print('O dobro de {} é :{}'.format(n, dobro))

# Imprime o triplo do número.
print('O triplo de {} é :{}'.format(n, triplo))

# Imprime a raiz quadrada do número.
print('A raiz quadrada de {} é:{}'.format(n, raiz_quadrada))
```
1. O usuário digita o número **9**.
    
2. O programa calcula o dobro de 9 (18), o triplo de 9 (27) e a raiz quadrada de 9 (3).
    
3. O programa imprime os seguintes resultados:
    
    - O dobro de 9 é: 18
        
    - O triplo de 9 é: 27
        
    - A raiz quadrada de 9 é: 3

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (60).md
### Última modificação: 2024-08-07 18:33:16

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Solicita ao usuário que digite um número inteiro
n = int(input('Digite o numero a ser fatorado:'))

# Inicializa a variável 'c' com o valor do número digitado 
# Esta variável será usada para controlar o loop e realizar as multiplicações
c = n

# Inicializa a variável 'f' com o valor 1, 
# que representará o fatorial do número
f = 1

# Imprime o início da equação do fatorial, incluindo o número digitado e o símbolo de fatorial "!"
print('{}! = '.format(n), end='')

# Loop 'while' que continua enquanto 'c' for maior que 1
# Este loop é responsável por calcular o fatorial
while c > 1:
    # Imprime o valor atual de 'c' 
    print(c, end='')

    # Imprime " x " se 'c' for maior que 1, 
    # indicando que a multiplicação continua
    # Caso contrário, imprime " = ", indicando o fim da multiplicação
    print(' x ' if c > 1 else ' = ', end='')

    # Multiplica 'f' por 'c' para calcular o fatorial
    # A cada iteração, 'f' acumula o resultado da multiplicação
    f *= c

    # Decrementa 'c' em 1
    # A cada iteração, 'c' é diminuído em 1 para controlar o loop
    c -= 1

# Imprime o resultado final do fatorial
print("=", f, end='')

```
Digite o numero a ser fatorado:9
9! = 9 x 8 x 7 x 6 x 5 x 4 x 3 x 2 x = 362880

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (61).md
### Última modificação: 2024-08-07 18:34:38

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# O programa recebe o primeiro termo (p) e a razão (r) da progressão aritmética (PA) do usuário.
p = int(input('Primeiro termo: '))
r = int(input('Razão da PA: '))

# Inicializa um contador (s) para acompanhar a quantidade de termos impressos.
s = 1

# O loop `while` continua até que o contador (s) atinja 10, imprimindo os 10 primeiros termos da PA.
while s != 10:
    # Se este for o primeiro termo (s == 1), imprime o primeiro termo sem o '=>'.
    if s == 1:
        print(p, end=' => ')  
    # Calcula o próximo termo da PA adicionando a razão ao termo anterior.
    p = p + r
    # Incrementa o contador para o próximo termo.
    s += 1
    # Imprime o termo atual com '=>'.
    print(p, end=' => ')
# Após o loop, imprime 'FIM' para indicar o término da sequência.
print('FIM')

```
Primeiro termo:2
Razão pa:9
2 => 11 => 20 => 29 => 38 => 47 => 56 => 65 => 74 => 83 => FIM

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (62).md
### Última modificação: 2024-08-07 18:35:56

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Leitura dos dados do usuário
p = int(input('Primeiro termo: '))  # Lê o primeiro termo da PA
r = int(input('Razão da PA: '))  # Lê a razão da PA

# Inicialização das variáveis de controle
i = 1  # Variável de controle do loop principal (1 para continuar, 0 para parar)
s = 10  # Número de termos a serem impressos em cada iteração
c = 1  # Contador do número total de termos impressos

# Imprime o primeiro termo da PA
print('{}!'.format(p), end=' = ')
print(p, end=' => ')

# Loop principal para imprimir os termos da PA
while i != 0:  # Continua enquanto o usuário não digitar 0
    while s != 1:  # Loop para imprimir os 10 primeiros termos
        p += r  # Calcula o próximo termo da PA
        print(p, end=' => ')  # Imprime o termo atual
        s -= 1  # Decrementa o contador de termos
        c += 1  # Incrementa o contador total de termos
    print('PAUSE')  # Imprime uma mensagem de pausa

    # Solicita ao usuário se ele deseja continuar
    i = int(input('''Que continuar?
Digite 0 parar encerrar.
Se não quantas vezes quer fazer:'''))

    # Se o usuário quiser continuar, define o novo número de termos
    s = i + 1 

# Imprime uma mensagem de fim e o número total de termos impressos
print('''FIM 
Teve {} termos'''.format(c))

```
Primeiro termo: 2
Razão da PA: 3
2! = 2 => 5 => 8 => 11 => 14 => 17 => 20 => 23 => 26 => 29 => PAUSE
Que continuar?
Digite 0 parar encerrar.
Se não quantas vezes quer fazer:5
32 => 35 => 38 => 41 => 44 => PAUSE
Que continuar?
Digite 0 parar encerrar.
Se não quantas vezes quer fazer:0
FIM 
Teve 16 termos

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (63).md
### Última modificação: 2024-08-07 18:37:58

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Imprime uma linha de '=' com 50 caracteres para delimitar visualmente o início do programa
print('=' * 50)

# Solicita ao usuário que insira a quantidade de termos da sequência de Fibonacci que deseja visualizar
# A entrada é convertida para um inteiro e armazenada na variável 'q'
q = int(input("Quantos termos você quer mostrar?: "))

# Subtrai 2 da quantidade de termos ('q') para ajustar o loop 'while'
# Isso porque os dois primeiros termos da sequência (0 e 1) já são impressos antes do loop
q -= 2

# Imprime outra linha de '=' para delimitar visualmente
print('=' * 50)

# Define a variável 'x' como 0, que será usada para armazenar o próximo termo da sequência
x = 0

# Define a variável 'fn' como 0, que representa o primeiro termo da sequência
fn = 0

# Define a variável 'f' como 1, que representa o segundo termo da sequência
f = 1

# Imprime uma linha de '~' com 50 caracteres para delimitar visualmente o início da sequência
print('~' * 50)

# Imprime os dois primeiros termos da sequência (0 e 1) com a formatação "0 => 1 => "
print('{} => {} => '.format(fn, f), end='')

# Loop 'while' que continua até que a variável 'q' seja igual a 0
while q != 0:
    # Decrementa a variável 'q' em 1 a cada iteração do loop
    q -= 1

    # Calcula o próximo termo da sequência ('x') como a soma dos dois termos anteriores ('fn' e 'f')
    x = fn + f

    # Imprime o termo calculado ('x') com a formatação "x => "
    print(x, end=' => ')

    # Atualiza o valor de 'fn' com o valor atual de 'f'
    fn = f

    # Atualiza o valor de 'f' com o valor atual de 'x'
    f = x

# Imprime a mensagem "Acabou" para indicar o fim da sequência
print('Acabou')

# Imprime outra linha de '~' para delimitar visualmente o fim da sequência
print('~' * 50)

```
==================================================
Quantos termos coçê quer mostrar?: 78
==================================================
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0 => 1 => 1 => 2 => 3 => 5 => 8 => 13 => 21 => 34 => 55 => 89 => 
144 => 233 => 377 => 610 => 987 => 1597 => 2584 => 4181 => 6765 => 10946 => 17711 => 28657 => 46368 => 75025 => 121393 => 196418 => 317811 => 514229 => 832040 => 1346269 => 2178309 => 3524578 => 
5702887 => 9227465 => 14930352 => 24157817 => 39088169 => 63245986 => 102334155 => 165580141 => 267914296 => 433494437 => 701408733 => 1134903170 => 1836311903 => 2971215073 => 4807526976 => 7778742049 => 12586269025 => 20365011074 => 32951280099 => 53316291173 => 86267571272 => 139583862445 => 225851433717 => 365435296162 
=> 591286729879 => 956722026041 => 1548008755920 => 2504730781961 => 4052739537881 => 6557470319842 => 10610209857723 => 17167680177565 => 27777890035288 => 44945570212853 => 72723460248141 => 117669030460994 => 190392490709135 => 308061521170129 => 498454011879264 => 806515533049393 => 1304969544928657 => 2111485077978050 
=> 3416454622906707 => 5527939700884757 => Acabou
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (64).md
### Última modificação: 2024-08-07 18:39:46

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Inicializa as variáveis:
# - x: armazena o número digitado pelo usuário
# - y: acumula a soma dos números digitados
# - c: conta a quantidade de números digitados
x = y = c = 0

# Lê o primeiro número e verifica se é a condição de parada
x = int(input('Digite um número[999 para parar]: '))

# Loop que continua enquanto o usuário não digitar 999
while x != 999:
    # Acumula a soma dos números digitados
    y = x + y
    # Incrementa o contador de números digitados
    c += 1
    # Lê o próximo número
    x = int(input('Digite um número[999 para parar]: '))

# Imprime a quantidade de números digitados e a soma
print('Você digitou {} números e a soma é {}'.format(c, y))

```
Digite um número[999 para parar:998
Digite um número[999 para parar:99
Digite um número[999 para parar:0
Digite um número[999 para parar:2
Digite um número[999 para parar:3
Digite um número[999 para parar:999
Você digitou 5 numeros e a soma é 1102


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (65).md
### Última modificação: 2024-08-07 18:41:26

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Inicialização das variáveis
i = 's'  # Variável de controle do loop, inicia como 's' para entrar no loop
x = 0  # Variável para armazenar o número digitado pelo usuário
me = 0  # Variável para armazenar o menor valor digitado
ma = 0  # Variável para armazenar o maior valor digitado
c = 0  # Contador de números digitados
m = 0  # Soma dos números digitados

# Loop para receber os números do usuário
while i not in 'Nn':  # O loop continua enquanto a entrada do usuário não for 'N' ou 'n'
    x = int(input('Digite um numero: '))  # Lê um número inteiro do usuário
    i = str(input('Quer continuar? [S/N]: '))  # Pergunta ao usuário se ele quer continuar
    
    # Atualiza a soma e o contador
    m = x + m  # Acumula a soma dos números digitados
    c += 1  # Incrementa o contador de números digitados

    # Verifica se é o primeiro número digitado
    if c == 1:  # Se for o primeiro número
        ma = me = x  # Define o maior e o menor como o primeiro número
    else:
        # Compara com o maior e o menor
        if x > ma:  # Se o número atual é maior que o maior atual
            ma = x  # Atualiza o maior valor
        if x < me:  # Se o número atual é menor que o menor atual
            me = x  # Atualiza o menor valor

# Exibe os resultados
print('A media é dos valore é :{}'.format(m / c))  # Imprime a média dos números digitados
print('O maior numero é {} e o menor numero é {}'.format(ma, me))  # Imprime o maior e o menor número

```
1. **Entrada:** O usuário digita o número 10 e responde 'S' à pergunta "Quer continuar?".
    
2. **Processamento:** O programa atualiza as variáveis:
    
    - m (soma) = 10
        
    - c (contador) = 1
        
    - ma (maior) = 10
        
    - me (menor) = 10
        
3. **Entrada:** O usuário digita o número 5 e responde 'S' à pergunta "Quer continuar?".
    
4. **Processamento:** O programa atualiza as variáveis:
    
    - m (soma) = 15
        
    - c (contador) = 2
        
    - ma (maior) = 10
        
    - me (menor) = 5
        
5. **Entrada:** O usuário digita o número 20 e responde 'N' à pergunta "Quer continuar?".
    
6. **Processamento:** O programa atualiza as variáveis:
    
    - m (soma) = 35
        
    - c (contador) = 3
        
    - ma (maior) = 20
        
    - me (menor) = 5
        
7. **Saída:** O programa imprime os seguintes resultados:
    
    - A média é dos valores é: 11.666666666666666
        
    - O maior número é 20 e o menor número é 5

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (66).md
### Última modificação: 2024-08-07 18:43:36

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Inicializa as variáveis que serão usadas para contar os números e guardar a soma.
c = 0  # Contador de números digitados
y = 0  # Soma dos números digitados

# Loop infinito (while True) que continua até que a condição de parada seja satisfeita.
while True:
    # Solicita ao usuário para digitar um número inteiro.
    x = int(input('Digite um número:'))
    
    # Verifica se o número digitado é a condição de parada (999).
    if x == 999:
        # Se for, sai do loop (break).
        break
    
    # Caso contrário, soma o número digitado à variável 'y' (soma).
    y += x
    
    # Incrementa o contador de números digitados.
    c += 1

# Imprime o número de números digitados e a soma total.
print(f'Foram digitados {c} números. E a soma entre eles é {y}')

```
Digite um número: 5
Digite um número: 10
Digite um número: 15
Digite um número: 999
Foram digitados 3 números. E a soma entre eles é 30

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (67).md
### Última modificação: 2024-08-07 18:45:02

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Inicializa a variável 'c' para controlar o contador da tabuada
c = 0

# Loop principal que continua até o usuário digitar um número negativo
while True:
    # Reinicia a variável 'c' para 0 a cada nova tabuada
    c = 0
    
    # Solicita ao usuário que digite o número para a tabuada
    t = int(input('Qual numero quer fazer a taboada: '))
    
    # Verifica se o número digitado é negativo. Se for, interrompe o loop principal
    if t < 1:
        break
    
    # Loop para imprimir a tabuada do número 't'
    while True:
        # Incrementa o contador 'c' em 1 a cada iteração
        c += 1
        
        # Calcula o resultado da multiplicação do número 't' pelo contador 'c'
        cont = c * t
        
        # Imprime a linha da tabuada na tela
        print(f'{t} X {c} = {cont}')
        
        # Verifica se o contador 'c' chegou a 10. Se sim, interrompe o loop da tabuada
        if c == 10:
            break

# Imprime a mensagem "Acabou" após o loop principal terminar
print('Acabou')

```
Qual numero quer fazer a taboada:678
678 X 1 = 678
678 X 2 = 1356
678 X 3 = 2034
678 X 4 = 2712
678 X 5 = 3390
678 X 6 = 4068
678 X 7 = 4746
678 X 8 = 5424
678 X 9 = 6102
678 X 10 = 6780
Qual numero quer fazer a taboada:9
9 X 1 = 9
9 X 2 = 18
9 X 3 = 27
9 X 4 = 36
9 X 5 = 45
9 X 6 = 54
9 X 7 = 63
9 X 8 = 72
9 X 9 = 81
9 X 10 = 90
Qual numero quer fazer a taboada:-1
Acabou

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (68).md
### Última modificação: 2024-08-07 18:47:15

---
tags: 
data: 2024-08-06
nivel:
---
```Python

import random

# Inicialização das variáveis:
# n - número aleatório escolhido pelo computador
# r - resultado da soma do número do jogador e do computador
# c - contador de vitórias consecutivas do jogador
n = r = c = 0

# Loop principal do jogo, que continua até o jogador perder
while True:
    # O computador escolhe um número aleatório entre 1 e 10
    n = random.randrange(1, 11)

    # O jogador digita um número
    q = int(input('Digite um número: '))

    # O jogador escolhe par ou ímpar
    pi = str(input('Digite [P/I]: '))

    # O computador mostra o número que escolheu
    print(f'O Computador escolheu {n}')

    # Calcula o resultado da soma do número do jogador e do computador
    r = n + q

    # Verifica se o resultado é par
    if r // 2 == r / 2:  # Usa a divisão inteira para verificar se o resultado é par
        print(f'{r} é Par')

        # Verifica se a escolha do jogador foi correta
        if pi in "Ii":  # Se o jogador escolheu ímpar e o resultado é par, ele perde
            print('Voce perdeu!')
            break  # Sai do loop, pois o jogador perdeu
        else:  # Se o jogador escolheu par e o resultado é par, ele ganha
            print('Voce ganhou!')
            c += 1  # Incrementa o contador de vitórias

    # Caso contrário, o resultado é ímpar
    else:
        print(f'{r} é Impar')

        # Verifica se a escolha do jogador foi correta
        if pi in "Pp":  # Se o jogador escolheu par e o resultado é ímpar, ele perde
            print('Voce perdeu!')
            break  # Sai do loop, pois o jogador perdeu
        else:  # Se o jogador escolheu ímpar e o resultado é ímpar, ele ganha
            print('Voce ganhou!')
            c += 1  # Incrementa o contador de vitórias

    # Imprime um separador entre as rodadas
    print('~^'*50)

# Imprime o número de vitórias consecutivas do jogador
print(f'Você ganhou {c} vezes.')

```
Digite um numero:7
Digite [P/I]:p
O Computador escolheu 7
14 é Par
Voce ganhou!
~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^
Digite um numero:8
Digite [P/I]:i
O Computador escolheu 4
12 é Par
Voce perdeu!
Você ganhou 1 vezes.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (69).md
### Última modificação: 2024-08-07 19:28:36

---
tags: 
data: 2024-08-06
nivel:
---
```Python

#  Crie um programa que leia a idade e o sexo de várias pessoas.
#  A cada pessoa cadastrada, o programa deverá perguntar se o usuário quer ou não continuar. No final, mostre:
# A) quantas pessoas tem mais de 18 anos.
# B) quantos homens foram cadastrados.
# C) quantas mulheres tem menos de 20 anos.

# Inicializa as variáveis:
# s = armazena o sexo da pessoa (F/M)
# n = armazena a idade da pessoa
# c18 = contador de pessoas com mais de 18 anos
# ch = contador de homens
# cm20 = contador de mulheres com menos de 20 anos
# c = armazena a resposta do usuário sobre continuar ou não (S/N)
s = ''
n = c18 = ch = cm20 = c = 0

print('~^'*50)  # Imprime uma linha de separação com ~^

# Loop principal para cadastrar as pessoas
while True:
    # Solicita o sexo da pessoa e valida a entrada
    s = str(input("Qual seu Sexo[F/M]:")).strip().upper()[0]
    while s not in "MmFf":
        s = str(input("""Dados invalidos.
Qual seu Sexo[F/M]:""")).strip().upper()[0]
    
    # Solicita a idade da pessoa e a converte para inteiro
    n = int(input('Qual sua idade:'))

    # Calcula as estatísticas:
    if n > 18:
        c18 += 1  # Incrementa o contador de pessoas com mais de 18 anos
    if s in 'Mm':
        ch += 1  # Incrementa o contador de homens
    if s in 'Ff' and n < 20:
        cm20 += 1  # Incrementa o contador de mulheres com menos de 20 anos

    # Pergunta ao usuário se deseja continuar
    c = str(input('Você quer continuar[S/N]?:')).strip().upper()[0]
    while c not in "SsNn":
        c = str(input("""Dados invalidos.
Você quer continuar[S/N]?:""")).strip().upper()[0]
    print('~^' * 50)  # Imprime uma linha de separação com ~^

    # Se o usuário digitar 'N', sai do loop
    if c in 'Nn':
        break

# Imprime os resultados
print(f'''Tem {c18} Pessoas que tem mais de 18 anos.
Tem {ch} homens nesta lista.
Tem {cm20} Mulheres com menos de 20 anos.  ''')
print('~^'*50)  # Imprime uma linha de separação com ~^

```
~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^
Qual seu Sexo[F/M]:F
Qual sua idade:19
Você quer continuar[S/N]?:S
~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~
Qual seu Sexo[F/M]:M
Qual sua idade:25
Você quer continuar[S/N]?:S
~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~
Qual seu Sexo[F/M]:F
Qual sua idade:17
Você quer continuar[S/N]?:N
~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~
Tem 2 Pessoas que tem mais de 18 anos.
Tem 1 homens nesta lista.
Tem 2 Mulheres com menos de 20 anos.  
~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (7).md
### Última modificação: 2024-08-07 14:42:47

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Este programa lê duas notas de um aluno, calcula e exibe a média.

# Solicita a primeira nota ao usuário e armazena na variável 'n' como um número inteiro.
n = int(input('Qual sua primeira nota?: '))

# Solicita a segunda nota ao usuário e armazena na variável 'n2' como um número inteiro.
n2 = int(input('Qual sua segunda nota?: '))

# Calcula a média das duas notas e armazena na variável 'M'.
M = (n + n2) / 2

# Exibe a mensagem "A sua média é:" seguida do valor da média (variável 'M').
print('A sua média é:', M)

```
Qual sua primeira nota?: 7
Qual sua segunda nota?: 8
A sua média é: 7.5

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (70).md
### Última modificação: 2024-08-08 18:16:35

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Inicialização das variáveis
# A: acumula o valor total da compra
# B: conta quantos produtos custam mais de R$1000
# r: contador de produtos
# c: armazena a resposta do usuário sobre continuar ou não
# C: armazena o nome do produto mais barato
# me: armazena o menor preço encontrado, inicializado com um valor alto (2 elevado a 10)
A = B = r = 0
c = C = ''
me = 2 ** 10

# Imprime um separador visual
print('~^'*50)

# Loop principal: continua até que o usuário escolha 'N'
while True:
    # Lê o nome e o preço do produto
    s = str(input("Nome do produto: "))
    n = float(input('Qual o valor: '))

    # Incrementa o contador de produtos
    r += 1

    # Calcula o produto mais barato
    if n < me:
        me = n
        C = s  # Armazena o nome do produto mais barato

    # Acumula o valor total da compra
    A = A + n

    # Conta quantos produtos custam mais de R$1000
    if n > 1000:
        B += 1

    # Pergunta se o usuário quer continuar
    c = str(input('Você quer continuar[S/N]?:')).strip().upper()[0]

    # Validação da entrada do usuário
    while c not in "SsNn":
        c = str(input("""Dados invalidos.
Você quer continuar[S/N]?:""")).strip().upper()[0]

    # Imprime um separador visual
    print('~^' * 50)

    # Se o usuário digitar 'N', sai do loop
    if c in 'Nn':
        break

# Imprime os resultados
print(f'''O total gasto na compra R${A}0.
Tem {B} produtos custam mais de R$1000,00.
O nome do produto mais barato é {C} que custa R${me}0. ''')

# Imprime um separador visual
print('~^'*50)

```
~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^
Nome do produto: Televisão
Qual o valor: 1500
Você quer continuar[S/N]?: S
~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~
Nome do produto: Notebook
Qual o valor: 2000
Você quer continuar[S/N]?: S
~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~
Nome do produto: Mouse
Qual o valor: 50
Você quer continuar[S/N]?: N
~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~
O total gasto na compra R$35500.
Tem 2 produtos custam mais de R$1000,00.
O nome do produto mais barato é Mouse que custa R$500. 
~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (71).md
### Última modificação: 2024-08-08 18:17:41

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Imprime o cabeçalho do programa
print('='*30)
print('{:^30}'.format('BANCO CEV'))
print('='*30)

# Pede ao usuário o valor a ser sacado e converte para inteiro
valor = int(input('Que valor você quer sacar? R$:'))

# Inicializa a variável total com o valor a ser sacado
total = valor

# Define o valor da cédula inicial como R$50
ced = 50

# Inicializa a contagem de cédulas da cédula atual
totced = 0

# Loop principal para distribuir as cédulas
while True:
    # Verifica se o valor total é maior ou igual ao valor da cédula atual
    if total >= ced:
        # Se sim, subtrai o valor da cédula do total
        total -= ced
        # Incrementa a contagem de cédulas da cédula atual
        totced += 1
    else:
        # Se não, verifica se já foram distribuídas cédulas da cédula atual
        if totced > 0:
            # Se sim, imprime a quantidade de cédulas distribuídas
            print(f'Total de {totced} cédulas de R$:{ced}')

        # Define o valor da próxima cédula a ser distribuída
        if ced == 50:
            ced = 20
        elif ced == 20:
            ced = 10
        elif ced == 10:
            ced = 1

        # Reinicia a contagem de cédulas para a próxima cédula
        totced = 0

        # Se o valor total for zero, o loop termina
        if total == 0:
            break

# Imprime o rodapé do programa
print('='*30)
print('Volte sempre ao BANCO CEV! Tenha um Bom dia!')

```
Que valor você quer sacar? R$: 173
Total de 3 cédulas de R$:50
Total de 1 cédulas de R$:20
Total de 1 cédulas de R$:10
Total de 3 cédulas de R$:1

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (72).md
### Última modificação: 2024-08-08 18:19:33

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Cria uma tupla chamada 'n' com as palavras por extenso de zero a vinte.
n = ('zero', 'um', 'dois', 'três', 'quatro', 'cinco', 'seis', 'sete', 'oito', 'nove', 'dez', 'onze', 'doze', 'treze', 'quatorze', 'quinze', 'dezesseis', 'dezessete', 'dezoito', 'dezenove', 'vinte')

# Loop principal que roda enquanto o usuário não digitar 'N' ou 'n'.
while True:
    # Solicita ao usuário que digite um número.
    c = int(input('Qual número você quer que eu escreva por extenso: '))

    # Loop que valida a entrada do usuário, garantindo que o número esteja entre 0 e 20.
    while True:
        # Se o número estiver entre 0 e 20, sai do loop.
        if c >= 0 and c <= 20:
            break
        # Caso contrário, solicita novamente a entrada do usuário.
        else:
            c = int(input('Qual número você quer que eu escreva por extenso: '))

    # Imprime o número por extenso usando a tupla 'n'.
    print(f'Seu número por extenso é: {n[c]}')

    # Solicita ao usuário se deseja continuar.
    n1 = str(input('Você quer continuar [S/N]? '))

    # Se o usuário digitar 'N' ou 'n', sai do loop principal.
    if n1 in 'Nn':
        break

```
Qual numeor voce quer que eu escreva por estenço:67
Qual numeor voce quer que eu escreva por estenço:8
Seu numero por extenço é:oito
Você quer continuar[S/N]s    
Qual numeor voce quer que eu escreva por estenço:18
Seu numero por extenço é:dezoito
Você quer continuar[S/N]n       

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (73).md
### Última modificação: 2024-08-08 18:21:23

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Define a tupla com os 20 primeiros colocados do Brasileirão
f = ('Palmeiras', 'Bragantino', 'Atlético-MG', 'Fortaleza EC', 'Athletico-PR', 'Bahia', 'Fluminense',
     'Flamengo', 'Santos', 'Atlético',  'Ceará', 'Corinthians', 'Juventude', 'São Paulo', 'Internacional',
     'América-MG', 'Sport', 'Cuiabá', 'Chapecoense', 'Grêmio')

# Imprime os 5 primeiros times
# f[0:5] retorna uma fatia da tupla do índice 0 (inclusive) até 5 (exclusive)
print('Os 5 primeiros times são:', f[0:5])

# Imprime os últimos 4 colocados
# f[-4:] retorna uma fatia da tupla dos últimos 4 elementos
print('Os últimos 4 colocados:', f[-4:])

# Imprime os times em ordem alfabética
# sorted(f) cria uma nova lista com os elementos da tupla em ordem alfabética
print('Times em ordem alfabética:', sorted(f))

# Imprime a posição da Chapecoense
# f.index('Chapecoense') retorna o índice da Chapecoense na tupla
# Adicionamos 1 para mostrar a posição real, já que o índice começa em 0
print(f'''Em que posição está o time da Chapecoense:{f.index('Chapecoense')+1}º.''')

```
Os 5 primeiros times são: ('Palmeiras', 'Bragantino', 'Atlético-MG', 'Fortaleza EC', 'Athletico-PR')
Os últimos 4 colocados: ('Sport', 'Cuiabá', 'Chapecoense', 
'Grêmio')
Times em ordem alfabética: ['América-MG', 'Athletico-PR', 'Atlético', 'Atlético-MG', 'Bahia', 'Bragantino', 'Ceará', 'Chapecoense', 'Corinthians', 'Cuiabá', 'Flamengo', 'Fluminense', 'Fortaleza EC', 'Grêmio', 'Internacional', 'Juventude', 'Palmeiras', 'Santos', 'Sport', 'São Paulo']
Em que posição está o time da Chapecoense:19º.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (74).md
### Última modificação: 2024-08-08 18:22:15

---
tags: 
data: 2024-08-06
nivel:
---
```Python

import random  # Importa a biblioteca 'random' para gerar números aleatórios.

# Gera uma lista de números aleatórios.
# random.sample(population, k)  
# - population:  A sequência da qual os elementos serão amostrados.  Aqui usamos [1, 2, 3, 4, 5, 6, 7, 8, 9], que é uma lista de números de 1 a 9.
# - k: O número de elementos a serem amostrados. Aqui usamos 5, então serão gerados 5 números aleatórios.
p = random.sample([1, 2, 3, 4, 5, 6, 7, 8, 9], k=5)

# Imprime os valores sorteados.
print(f'Os valores sorteados são: {p}')

# Imprime o maior e o menor valor da tupla.
# max(p) retorna o maior valor dentro da tupla 'p'.
# min(p) retorna o menor valor dentro da tupla 'p'.
print(f'''O maior valor foi: {max(p)}
O menor valor foi: {min(p)}''')

```
Os valores sorteados são: [8, 2, 7, 3, 1]
O maior valor foi: 8
O menor valor foi: 1

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (75).md
### Última modificação: 2024-08-08 18:23:22

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Declaração da tupla
p = (
    int(input('Digite um numero: ')),  # Lê o primeiro número e o converte para inteiro
    int(input('Digite outro numero: ')),  # Lê o segundo número e o converte para inteiro
    int(input('Digite mais um numero: ')),  # Lê o terceiro número e o converte para inteiro
    int(input('Digite o último numero: '))  # Lê o quarto número e o converte para inteiro
)

# Imprime a tupla e a quantidade de vezes que o valor 9 aparece
print(f'''{p}
O valor 9 apareceu {p.count(9)} vezes.''')

# Verifica se o valor 3 está na tupla e imprime sua posição, caso contrário, imprime uma mensagem
if 3 in p:
    print(f'O valor 3 apareceu na {p.index(3)+1}ª posição.')
else:
    print('O numero 3 não foi digitado')

# Imprime os números pares da tupla
print('Os valores pares digitados foram:', end='')
for c in range(4):  # Itera sobre cada elemento da tupla
    if p[c] // 2 == p[c] / 2:  # Verifica se o número é par (divisível por 2 sem resto)
        print(p[c], end=' ')  # Imprime o número par

```
Digite um numero: 5
Digite outro numero: 9
Digite mais um numero: 3
Digite o último numero: 2
(5, 9, 3, 2)
O valor 9 apareceu 1 vezes.
O valor 3 apareceu na 3ª posição.
Os valores pares digitados foram: 2 

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (76).md
### Última modificação: 2024-08-08 18:29:12

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Cria uma tupla chamada "p" contendo nomes de produtos e seus preços alternados.
p = ('Lapis', 1.75, 'Borracha', 2.00, 'Caderno', 15.00, 'Estojo', 25.00, 'Transferidor', 4.20,
     'Compasso', 9.99, 'Mochila', 120.32, 'Canetas', 22.30, 'Livro', 34.90)

# Imprime uma linha horizontal de 39 caracteres.
print('-' * 39)

# Imprime o título "LISTAGEM DE PREÇOS" centralizado em 40 caracteres.
print(f'{"LISTAGEM DE PREÇOS":^40}')

# Imprime outra linha horizontal de 39 caracteres.
print('-' * 39)

# Itera sobre a tupla "p" usando um loop for, com a variável "c" representando o índice.
for c in range(0, len(p)):
    # Verifica se o índice "c" dividido por 2 é igual ao resultado da divisão inteira de "c" por 2.
    # Isso significa que "c" é um número par.
    if c/2 == c//2:
        # Se "c" é par, imprime o nome do produto (índice "c") alinhado à esquerda em 30 caracteres, seguido de um espaço.
        print(f"{p[c]:.<30}", end='')
    else:
        # Se "c" é ímpar, imprime o preço do produto (índice "c") formatado com "R$" e duas casas decimais, alinhado à direita.
        print(f'R${p[c]:>7.2f}')

# Imprime a última linha horizontal de 39 caracteres.
print('-' * 39)

```
---------------------------------------
        LISTAGEM DE PREÇOS         
---------------------------------------
Lapis........................... R$  1.75
Borracha......................... R$  2.00
Caderno.......................... R$ 15.00
Estojo.......................... R$ 25.00
Transferidor...................... R$  4.20
Compasso......................... R$  9.99
Mochila......................... R$ 120.32
Canetas......................... R$ 22.30
Livro........................... R$ 34.90
--------------------------------------- 

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (77).md
### Última modificação: 2024-08-08 18:32:36

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Define uma tupla chamada 'p' com várias palavras, sem acentos.
p = ('Lapis', 'Borracha', 'Caderno', 'Estojo', 'Transferidor',
     'Compasso', 'Mochila', 'Canetas', 'Livro')

# Itera sobre cada palavra da tupla 'p' usando um loop 'for'.
# O range(0, len(p)) gera um intervalo de 0 até o tamanho da tupla 'p',
# acessando cada índice da tupla.
for c in range(0, len(p)):

    # Imprime a palavra em maiúsculas com um espaço antes e depois.
    print(f'\nNa palavra {p[c].upper() } temos: ', end='')

    # Itera sobre cada caractere da palavra atual usando um loop 'for'.
    # O range(0, len(p[c])) gera um intervalo de 0 até o tamanho da palavra atual.
    for x in range(0, len(p[c])):

        # Verifica se o caractere atual é uma vogal, considerando maiúsculas e minúsculas.
        if p[c][x].lower() in 'aeiou':
            # Se for uma vogal, imprime a vogal em minúsculas com um espaço após.
            print(p[c][x].lower(), end=' ')


```
 Exemplo de funcionamento:

  

 Na palavra LAPIS temos: a i

 Na palavra BORRACHA temos: o a a

 Na palavra CADERNO temos: a e o

 Na palavra ESTOJO temos: e o

 Na palavra TRANSFERIDOR temos: a e i o

 Na palavra COMPASSO temos: o a o

 Na palavra MOCHILA temos: o i a

 Na palavra CANETAS temos: a e a

 Na palavra LIVRO temos: i o

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (78).md
### Última modificação: 2024-08-08 18:26:32

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Cria uma lista vazia para armazenar os números.
l = []

# Inicializa as variáveis para o maior e o menor valor como o primeiro número da lista.
# Assume-se que o primeiro número será o maior e o menor até que outros sejam comparados.
ma = me = 0

# Loop para ler 5 números do usuário.
for c in range(0, 5):
    # Lê um número do usuário e o converte para inteiro.
    l.append(int(input('Digite o numero: ')))

    # Se este for o primeiro número (c == 0), ele será tanto o maior quanto o menor.
    if c == 0:
        ma = l[c]  # Atribui o primeiro número como o maior.
        me = l[c]  # Atribui o primeiro número como o menor.

    # Caso contrário, compara o número atual com o maior e o menor valores encontrados até agora.
    else:
        # Se o número atual for maior que o maior valor atual (ma), atualiza ma.
        if l[c] > ma:
            ma = l[c]

        # Se o número atual for menor que o menor valor atual (me), atualiza me.
        if l[c] < me:
            me = l[c]

# Imprime o maior valor e suas posições na lista.
print(f'O maior numero {ma}, sua posição é: ', end='')  # Imprime a mensagem inicial.
# Loop para iterar sobre a lista e encontrar as posições do maior valor.
for c, v in enumerate(l):
    # Se o valor atual (v) for igual ao maior valor (ma), imprime a posição (c + 1).
    if v == ma:
        print(c+1, end=" ")

# Imprime uma nova linha para formatar a saída.
print()

# Imprime o menor valor e suas posições na lista.
print(f'O menor numero {me}, sua posição é: ', end='')  # Imprime a mensagem inicial.
# Loop para iterar sobre a lista e encontrar as posições do menor valor.
for c, v in enumerate(l):
    # Se o valor atual (v) for igual ao menor valor (me), imprime a posição (c + 1).
    if v == me:
        print(c+1, end=" ")

```
- 5
- 2
- 8
- 1
- 3
O maior numero 8, sua posição é: 3 
O menor numero 1, sua posição é: 4 

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (79).md
### Última modificação: 2024-08-08 18:33:37

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Inicializa a lista para armazenar os números únicos
l = []

# Define a variável 'x' para controlar se é a primeira vez que um número é adicionado
x = 0

# Define a variável 'teste' para verificar se o número já está na lista
teste = 0

# Inicia um loop infinito para receber a entrada do usuário
while True:
    # Solicita ao usuário que digite um número
    l1 = int(input('Digite o número: '))

    # Verifica se é a primeira vez que um número é adicionado
    if x == 0:
        # Se for a primeira vez, adiciona o número à lista
        # Incrementa a variável 'teste' para indicar que o número foi adicionado
        teste += 1
        l.append(l1)
        print('Valor adicionado com sucesso...')
    else:
        # Se não for a primeira vez, verifica se o número já está na lista
        # Itera sobre todos os números na lista
        for f in range(0, len(l)):
            # Se o número atual da lista for diferente do número digitado, incrementa a variável 'teste'
            if l[f] != l1:
                teste += 1
        # Se o número de vezes que o número foi diferente dos números da lista for igual ao tamanho da lista
        # Significa que o número digitado não está na lista
        if teste == len(l):
            # Se o número não está na lista, adiciona-o à lista
            l.append(l1)
            print('Valor adicionado com sucesso...')
        else:
            # Se o número já está na lista, avisa o usuário
            print('Valor duplicado! Não vou adicionar...')
    # Incrementa a variável 'x' para indicar que pelo menos um número já foi adicionado
    x += 1
    # Reseta a variável 'teste' para 0 para a próxima iteração
    teste = 0
    # Solicita ao usuário se ele deseja continuar
    c = str(input('Você quer continuar[S/N]?:')).strip().upper()[0]
    # Valida a entrada do usuário
    while c not in "SsNn":
        c = str(input("""Dados inválidos....
    Você quer continuar[S/N]?:""")).strip().upper()[0]
    # Se o usuário digitar 'N', sai do loop
    if c in 'Nn':
        break

# Ordena a lista em ordem crescente
l.sort()

# Imprime a lista com os números únicos em ordem crescente
print(l)

```
Digite o número: 5
Valor adicionado com sucesso...
Você quer continuar[S/N]?:s
Digite o número: 10
Valor adicionado com sucesso...
Você quer continuar[S/N]?:s
Digite o número: 5
Valor duplicado! Não vou adicionar...
Você quer continuar[S/N]?:s
Digite o número: 2
Valor adicionado com sucesso...
Você quer continuar[S/N]?:n
[2, 5, 10]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (8).md
### Última modificação: 2024-08-07 14:43:56

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Solicita ao usuário que digite um número inteiro
n = int(input('Qual o numero?: '))

# Imprime a tabuada do número fornecido pelo usuário
# A linha a seguir calcula e imprime a multiplicação do número por 1
print('1 x', n, '=', n * 1)
# A linha a seguir calcula e imprime a multiplicação do número por 2
print('2 x', n, '=', n * 2)
# A linha a seguir calcula e imprime a multiplicação do número por 3
print('3 x', n, '=', n * 3)
# A linha a seguir calcula e imprime a multiplicação do número por 4
print('4 x', n, '=', n * 4)
# A linha a seguir calcula e imprime a multiplicação do número por 5
print('5 x', n, '=', n * 5)
# A linha a seguir calcula e imprime a multiplicação do número por 6
print('6 x', n, '=', n * 6)
# A linha a seguir calcula e imprime a multiplicação do número por 7
print('7 x', n, '=', n * 7)
# A linha a seguir calcula e imprime a multiplicação do número por 8
print('8 x', n, '=', n * 8)
# A linha a seguir calcula e imprime a multiplicação do número por 9
print('9 x', n, '=', n * 9)
# A linha a seguir calcula e imprime a multiplicação do número por 10
print('10 x', n, '=', n * 10)

```
1 x 5 = 5
2 x 5 = 10
3 x 5 = 15
4 x 5 = 20
5 x 5 = 25
6 x 5 = 30
7 x 5 = 35
8 x 5 = 40
9 x 5 = 45
10 x 5 = 50

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (80).md
### Última modificação: 2024-08-08 18:41:16

---
tags: 
data: 2024-08-06
nivel:
---
```Python

l = []  # Cria uma lista vazia para armazenar os números.

for x in range(0, 5):  # Loop que se repete 5 vezes para receber 5 números do usuário.
    n = int(input('Digite um valor: '))  # Pede ao usuário para digitar um número inteiro e o armazena na variável 'n'.

    # Verifica se a lista está vazia (primeiro elemento) ou se o número digitado é maior que o último elemento da lista.
    if x == 0 or n > l[-1]: 
        l.append(n)  # Se a lista estiver vazia ou o número for maior que o último, adiciona-o ao final da lista.
        print('Adicionado ao final da lista')  # Imprime uma mensagem informando a posição de inserção.
    else:  # Caso o número não seja o primeiro e não seja maior que o último, busca a posição correta na lista.
        pos = 0  # Inicializa uma variável 'pos' para armazenar a posição de inserção.
        while pos < len(l):  # Loop que percorre a lista até encontrar a posição correta.
            if n <= l[pos]:  # Se o número digitado for menor ou igual ao elemento atual da lista:
                l.insert(pos, n)  # Insere o número na posição 'pos' da lista.
                print(f'Adicionado na posição {pos} da lista')  # Imprime a posição de inserção.
                break  # Sai do loop 'while' após encontrar a posição correta.
            pos += 1  # Incrementa a posição para continuar a busca na lista.

print('=-'* 40)  # Imprime uma linha separadora.
print(f'Os valores digitados em ordem foram: {l}')  # Imprime a lista ordenada.

```
Digite um valor5
Adicionado ao final da lista
Digite um valor3
Adicionado na posição 0 da lista
Digite um valor22
Adicionado ao final da lista
Digite um valor99
Adicionado ao final da lista
Digite um valor23
Adicionado na posição 3 da lista
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
Os valores digitados em ordem foram[3, 5, 22, 23, 99]  

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (81).md
### Última modificação: 2024-08-08 18:42:40

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Inicializa uma lista vazia para armazenar os números digitados pelo usuário.
l = []

# Loop para ler os números do usuário até que ele digite 'N' ou 'n'.
while True:
    # Lê um número do usuário e o converte para inteiro.
    l.append(int(input('Digite um valor:')))

    # Pergunta ao usuário se ele deseja continuar inserindo números.
    r = str(input('Quer continuar(S/N):'))

    # Se o usuário digitar 'N' ou 'n', o loop termina.
    if r in "Nn":
        break

# Imprime uma linha em branco para melhor visualização.
print()

# Imprime a quantidade de números digitados pelo usuário.
print(f'Você digitou {len(l)} de elemento')

# Ordena a lista em ordem decrescente.
l.sort(reverse=True)

# Imprime a lista ordenada em ordem decrescente.
print(f'Os valores em ordem decrescente são:{l}')

# Verifica se o número 5 está presente na lista.
if 5 in l:
    print('O valor 5 faz parte da lista.')
else:
    print('O valor 5 não faz parte da lista.')

```
Digite um valor: 10
Quer continuar(S/N): S
Digite um valor: 5
Quer continuar(S/N): S
Digite um valor: 2
Quer continuar(S/N): N
Você digitou 3 de elemento
Os valores em ordem decrescente são:[10, 5, 2]
O valor 5 faz parte da lista.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (82).md
### Última modificação: 2024-08-08 18:45:06

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Inicializa as listas para armazenar os números, pares e ímpares
numeros = []  # Lista para armazenar todos os números digitados
pares = []   # Lista para armazenar os números pares
impares = [] # Lista para armazenar os números ímpares

# Loop para coletar números do usuário até que ele digite 'N'
while True:
    # Lê um número do usuário e converte para inteiro
    numero = int(input('Digite um valor: '))
    # Adiciona o número à lista de todos os números
    numeros.append(numero)

    # Solicita ao usuário se ele deseja continuar
    continuar = input('Você quer continuar [S/N]?: ').strip().upper()
    # Valida a entrada do usuário
    while continuar not in "SN":
        continuar = input("""Dados inválidos...
Você quer continuar [S/N]?: """).strip().upper()
    # Se o usuário digitar 'N', sai do loop
    if continuar == 'N':
        break

# Percorre a lista de números
for numero in numeros:
    # Verifica se o número é par
    if numero % 2 == 0:
        # Se for par, adiciona à lista de pares
        pares.append(numero)
    else:
        # Se não for par (ímpar), adiciona à lista de ímpares
        impares.append(numero)

# Imprime as listas resultantes
print(f'''A lista é: {numeros}
Os números pares da lista são: {pares}
Os números ímpares da lista são: {impares}''')

```
- Digite um valor: 5
    
- Você quer continuar [S/N]?: S
    
- Digite um valor: 12
    
- Você quer continuar [S/N]?: S
    
- Digite um valor: 7
    
- Você quer continuar [S/N]?: S
    
- Digite um valor: 4
    
- Você quer continuar [S/N]?: N
A lista é: [5, 12, 7, 4]
Os números pares da lista são: [12, 4]
Os números ímpares da lista são: [5, 7]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (83).md
### Última modificação: 2024-08-08 18:46:42

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Solicita ao usuário que insira a fórmula
e = str(input('Digite sua formula:'))

# Inicializa uma lista para armazenar os parênteses de abertura
p = []

# Itera sobre cada caractere da fórmula
for s in e:
    # Se o caractere for um parêntese de abertura, adiciona-o à lista
    if s == "(":
        p.append("(")
    # Se o caractere for um parêntese de fechamento, verifica se há um parêntese de abertura correspondente na lista
    elif s == ")":
        # Se houver um parêntese de abertura na lista, remove-o
        if len(p) > 0:
            p.pop()
        # Caso contrário, a fórmula é inválida (parêntese de fechamento sem correspondente)
        else:
            p.append(")")
            break

# Se a lista estiver vazia, todos os parênteses foram abertos e fechados corretamente
if len(p) == 0:
    print('Sua expressao esta valida')
# Caso contrário, a fórmula é inválida (parênteses desbalanceados)
else:
    print('Sua expressao esta errada')

```
**Entrada:** (a+b)*c)

**Saída:** Sua expressao esta errada

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (84).md
### Última modificação: 2024-08-08 18:48:28

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Inicializa duas listas:
# - 'd' para armazenar os dados de cada pessoa (nome e peso)
# - 'g' para armazenar os dados de uma pessoa temporariamente durante a leitura
d = []  # Lista para armazenar os dados de todas as pessoas
g = []  # Lista temporária para armazenar os dados de uma pessoa

# Inicializa as variáveis para o maior e menor peso
ma = 0  # Maior peso encontrado até o momento
me = 0  # Menor peso encontrado até o momento

# Loop para ler os dados das pessoas
while True:
    # Lê o nome da pessoa
    g.append(str(input('Qual nome: ')))  
    # Lê o peso da pessoa e converte para float
    g.append(float(input('Qual a peso: '))) 

    # Verifica se é a primeira pessoa adicionada à lista
    if len(d) == 0:
        # Se for a primeira pessoa, define o maior e menor peso como o peso atual
        ma = me = g[1]  
    else:
        # Se não for a primeira pessoa, compara o peso atual com o maior e menor peso
        if g[1] > ma:
            ma = g[1]  # Atualiza o maior peso se o peso atual for maior
        if g[1] < me:
            me = g[1]  # Atualiza o menor peso se o peso atual for menor

    # Adiciona os dados da pessoa atual à lista 'd'
    d.append(g[:]) 
    # Limpa a lista 'g' para a próxima pessoa
    g.clear() 

    # Pergunta se o usuário deseja continuar
    c = str(input('Você quer continuar[S/N]?:')).strip().upper()
    # Valida a entrada do usuário (S/N)
    while c not in "SsNn":
        c = str(input("""Dados invalidos....
        Você quer continuar[S/N]?:""")).strip().upper()
    # Se o usuário digitar 'N' ou 'n', sai do loop
    if c in 'Nn':
        break

# Imprime o número de pessoas na lista
print(f'''Tem {len(d)} pessoas na lista.
O maior peso foi de {ma:.1f}Kg Peso de: ''', end='')
# Imprime os nomes das pessoas com o maior peso
for x in d:
    if x[1] == ma:
        print(f'{x[0]} ', end='')
# Imprime o menor peso e os nomes das pessoas com o menor peso
print(f'\nO maior peso foi de {me:.1f}Kg Peso de: ', end='')
for x in d:
    if x[1] == me:
        print(f'{x[0]} ', end='')
print()

```
1. **Entrada:**
    
    - Nome: João
        
    - Peso: 80
        
    - Nome: Maria
        
    - Peso: 65
        
    - Nome: Pedro
        
    - Peso: 80
        
    - Continuar? N
        
2. **Saída:**
    
    - Tem 3 pessoas na lista.
        
    - O maior peso foi de 80.0Kg Peso de: João Pedro
        
    - O maior peso foi de 65.0Kg Peso de: Maria

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (85).md
### Última modificação: 2024-08-08 18:50:41

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Cria uma lista de listas (l) para armazenar os números pares e ímpares.
# A primeira sublista (l[0]) armazenará os números pares,
# e a segunda sublista (l[1]) armazenará os números ímpares.
l = [[], []]

# Itera 7 vezes, pedindo ao usuário para inserir um número em cada iteração.
for x in range(0, 7):
    # Solicita ao usuário para digitar um valor e converte-o para inteiro.
    v = int(input('Digite um valor: '))

    # Verifica se o número digitado é par.
    if v % 2 == 0:
        # Se o número for par, ele é adicionado à lista de pares (l[0]).
        l[0].append(v)
    else:
        # Se o número for ímpar, ele é adicionado à lista de ímpares (l[1]).
        l[1].append(v)

# Imprime uma linha de separação.
print('=-'*30)

# Imprime os números pares e ímpares em ordem crescente.
# A função sorted() ordena as listas antes de serem impressas.
print(f'''Os números pares da lista são: {sorted(l[0])}                         
Os números ímpares da lista são: {sorted(l[1])}''')

```
Digite um valor:2
Digite um valor:3
Digite um valor:4
Digite um valor:5
Digite um valor:7
Digite um valor:89
Digite um valor:5
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
Os numeros pares da lista são:[2, 4]

Os numeros impares da lista são:[3, 5, 5, 7, 89]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (86).md
### Última modificação: 2024-08-08 18:52:00

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Cria uma matriz 3x3 com todos os elementos inicializados com 0
l = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]

# Laço externo: itera pelas linhas da matriz (0, 1, 2)
for x in range(0, 3):
    # Laço interno: itera pelas colunas da matriz (0, 1, 2)
    for c in range(0, 3):
        # Lê um valor do teclado e o converte para inteiro
        # O f-string "{x}, {c}" exibe as coordenadas da posição atual na matriz
        l[x][c] = int(input(f'Digite um valor para [{x}, {c}]:'))

# Imprime uma linha de separação na tela
print('-=' * 30)

# Laço externo: itera pelas linhas da matriz (0, 1, 2)
for x in range(0, 3):
    # Laço interno: itera pelas colunas da matriz (0, 1, 2)
    for c in range(0, 3):
        # Imprime o valor da matriz na posição atual, formatado com 5 espaços
        # O f-string "{l[x][c]:^5}" formata o valor com 5 espaços, centralizando o número
        print(f'[{l[x][c]:^5}]', end='')
    # Após cada linha, pula para a próxima linha
    print()

```
Digite um valor para [0, 0]: 1
Digite um valor para [0, 1]: 2
Digite um valor para [0, 2]: 3
Digite um valor para [1, 0]: 4
Digite um valor para [1, 1]: 5
Digite um valor para [1, 2]: 6
Digite um valor para [2, 0]: 7
Digite um valor para [2, 1]: 8
Digite um valor para [2, 2]: 9
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
[   1] [   2] [   3]
[   4] [   5] [   6]
[   7] [   8] [   9]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (87).md
### Última modificação: 2024-08-08 18:53:32

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Cria uma matriz 3x3 de zeros
l = [[0, 0, 0],
     [0, 0, 0],
     [0, 0, 0]]

# Inicializa as variáveis que serão usadas para calcular as somas e o maior valor
s = 0  # Soma dos valores pares
v3 = 0  # Soma dos valores da terceira coluna
m3 = 0  # Maior valor da segunda linha

# Loop para preencher a matriz com valores digitados pelo usuário
for x in range(0, 3):  # Itera pelas linhas da matriz (0 a 2)
    for c in range(0, 3):  # Itera pelas colunas da matriz (0 a 2)
        l[x][c] = int(input(f'Digite um valor para [{x}, {c}]: '))  # Lê o valor digitado e atribui à posição da matriz

# Imprime a matriz formatada
print('-=' * 30)
for x in range(0, 3):  # Itera pelas linhas da matriz
    for c in range(0, 3):  # Itera pelas colunas da matriz
        print(f'[{l[x][c]:^5}]', end='')  # Imprime o valor da célula formatado com 5 espaços
        if l[x][c] % 2 == 0:  # Verifica se o valor é par
            s += l[x][c]  # Se for par, soma ao valor de 's'
    print()  # Pula para a próxima linha após imprimir cada linha da matriz

# Calcula a soma dos valores da terceira coluna
for x in range(0, 3):  # Itera pelas linhas da matriz
    v3 += l[x][2]  # Soma o valor da terceira coluna (índice 2) à variável 'v3'

# Encontra o maior valor da segunda linha
for x in range(0, 3):  # Itera pelas colunas da matriz
    if c == 0:  # Se for a primeira coluna (índice 0), inicializa 'm3' com o valor da célula
        m3 = l[1][x]
    elif l[1][x] > m3:  # Se o valor da célula da segunda linha (índice 1) for maior que 'm3', atualiza 'm3'
        m3 = l[1][x]

# Imprime os resultados
print('-=' * 30)
print(f'''A soma dos valores pares é {s}
A soma dos valores da terceira coluna é:{v3}
O maior valor da segunda linha é :{m3}''')

```
Digite um valor para [0, 0]: 1
Digite um valor para [0, 1]: 2
Digite um valor para [0, 2]: 3
Digite um valor para [1, 0]: 4
Digite um valor para [1, 1]: 5
Digite um valor para [1, 2]: 6
Digite um valor para [2, 0]: 7
Digite um valor para [2, 1]: 8
Digite um valor para [2, 2]: 9
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
[   1]   [   2]   [   3]
[   4]   [   5]   [   6]
[   7]   [   8]   [   9]
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
A soma dos valores pares é 20
A soma dos valores da terceira coluna é:18
O maior valor da segunda linha é :6

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (88).md
### Última modificação: 2024-08-08 18:56:37

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# """088: Faça um programa que ajude um jogador da MEGA SENA a criar palpites.
# O programa vai perguntar quantos jogos serão gerados e vai sortear 6 números
# entre 1 e 60 para cada jogo, cadastrando tudo em uma lista composta.."""

print('-=' * 30)
print('{:^60}'.format('JOGO DA MEGA SENA'))  # Imprime o título do programa centralizado
print('-=' * 30)

from random import randint  # Importa a função randint do módulo random para gerar números aleatórios
from time import sleep  # Importa a função sleep do módulo time para criar pausas no programa

lista = []  # Cria uma lista vazia para armazenar os números sorteados para cada jogo
jogos = list()  # Cria uma lista vazia para armazenar todos os jogos gerados
tot = 1  # Inicializa a variável tot com 1 para controlar a quantidade de jogos gerados
quant = int(input('Quantos jogos você quer que eu sorteie? '))  # Lê a quantidade de jogos que o usuário deseja gerar

# Laço while para gerar a quantidade de jogos solicitada
while tot <= quant:
    cont = 0  # Inicializa a variável cont com 0 para controlar a quantidade de números sorteados para cada jogo
    # Laço while para gerar 6 números aleatórios distintos para cada jogo
    while True:
        num = randint(1, 60)  # Gera um número aleatório entre 1 e 60
        if num not in lista:  # Verifica se o número já foi sorteado para o jogo atual
            lista.append(num)  # Adiciona o número à lista de números sorteados para o jogo atual
            cont += 1  # Incrementa o contador de números sorteados para o jogo atual
        if cont >= 6:  # Verifica se já foram sorteados 6 números para o jogo atual
            break  # Sai do laço while se já foram sorteados 6 números
    lista.sort()  # Ordena a lista de números sorteados para o jogo atual
    jogos.append(lista[:])  # Copia a lista de números sorteados para o jogo atual para a lista de jogos
    lista.clear()  # Limpa a lista de números sorteados para o jogo atual
    tot += 1  # Incrementa o contador de jogos gerados
# Laço for para imprimir os jogos gerados
for i, l in enumerate(jogos):  # Itera sobre a lista de jogos, acessando o índice e a lista de números de cada jogo
    print(f'Jogo {i+1}:{l}')  # Imprime o número do jogo e a lista de números sorteados
    sleep(0.5)  # Cria uma pausa de 0.5 segundos antes de imprimir o próximo jogo

```
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
                     JOGO DA MEGA SENA

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Quantos jogos você quer que eu sorteie?10
Jogo 1:[2, 17, 18, 28, 40, 43]
Jogo 2:[25, 29, 32, 35, 51, 60]
Jogo 3:[4, 12, 20, 25, 26, 54]
Jogo 4:[7, 13, 16, 19, 29, 60]
Jogo 5:[8, 17, 32, 36, 55, 60]
Jogo 6:[3, 28, 30, 44, 51, 54]
Jogo 7:[13, 16, 19, 39, 41, 47]
Jogo 8:[16, 20, 25, 43, 44, 52]
Jogo 9:[19, 26, 33, 35, 49, 50]
Jogo 10:[7, 11, 29, 49, 50, 51]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (89).md
### Última modificação: 2024-08-08 18:57:42

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Cria uma lista composta para armazenar as informações dos alunos.
ficha = list()

# Loop para adicionar os dados dos alunos.
while True:
    # Pede o nome do aluno.
    nome = str(input('Nome: '))
    # Pede a primeira nota do aluno.
    nota1 = float(input('Nota 1: '))
    # Pede a segunda nota do aluno.
    nota2 = float(input('Nota 2: '))
    # Calcula a média das notas do aluno.
    media = (nota1 + nota2) / 2
    # Adiciona o nome, as notas e a média do aluno na lista composta 'ficha'.
    ficha.append([nome, [nota1, nota2], media])
    # Pergunta se o usuário quer continuar adicionando alunos.
    resp = str(input('Quer continuar? [S/N] '))
    # Se a resposta for 'N' ou 'n', o loop é encerrado.
    if resp in 'Nn':
        break

# Imprime um cabeçalho para o boletim.
print('-=' * 30)
print(f'{"No.":<4}{"Nome":<10}{"Média":>8}')
print('-=' * 30)

# Imprime o boletim com o nome e a média de cada aluno.
for i, a in enumerate(ficha):
    # Imprime o número do aluno, o nome e a média.
    print(f'{i:<4}{a[0]:<10}{a[2]:>8.1f}')

# Loop para mostrar as notas de alunos individuais.
while True:
    # Imprime uma linha separadora.
    print('-' * 35)
    # Pede ao usuário o número do aluno que ele quer ver as notas.
    opc = int(input('Mostrar notas de qual aluno? (999 interrompe): '))
    # Se o usuário digitar 999, o loop é encerrado.
    if opc == 999:
        print('FINALIZANDO...')
        break
    # Se o número do aluno for válido, as notas são exibidas.
    if opc <= len(ficha) - 1:
        # Imprime as notas do aluno.
        print(f'Notas de {ficha[opc][0]} são {ficha[opc][1]}')

# Mensagem de encerramento.
print('<<< VOLTE SEMPRE >>>')

```
Nome: João
Nota 1: 7.5
Nota 2: 8.0
Quer continuar? [S/N] S
Nome: Maria
Nota 1: 9.0
Nota 2: 8.5
Quer continuar? [S/N] N
------------------------------
No.   Nome      Média
------------------------------
0     João       7.8
1     Maria      8.8
------------------------------
Mostrar notas de qual aluno? (999 interrompe): 0
Notas de João são [7.5, 8.0]
------------------------------
Mostrar notas de qual aluno? (999 interrompe): 1
Notas de Maria são [9.0, 8.5]
------------------------------
Mostrar notas de qual aluno? (999 interrompe): 999
FINALIZANDO...
<<< VOLTE SEMPRE >>>

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (9).md
### Última modificação: 2024-08-07 14:45:05

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Este programa lê um valor em metros e o converte para centímetros e milímetros.

# Pede ao usuário para inserir um valor em metros e armazena na variável 'n'
n = int(input('Número em metros:'))

# Multiplica o valor em metros por 100 para obter o valor em centímetros
# e imprime o resultado
print('Em centímetros:', n * 100)

# Multiplica o valor em metros por 1000 para obter o valor em milímetros
# e imprime o resultado
print('Em milímetros:', n * 1000)

```
Número em metros: 2
Em centímetros: 200
Em milímetros: 2000

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (90).md
### Última modificação: 2024-08-08 18:59:31

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Este programa lê o nome e a média de um aluno, calcula a situação e armazena os dados em um dicionário.

# Cria um dicionário vazio para armazenar as informações do aluno.
d = {}

# Solicita o nome do aluno e armazena no dicionário.
d['Nome'] = str(input('Nome: '))

# Solicita a média do aluno e armazena no dicionário.
d['média'] = float(input((f'Média de {d["Nome"]}: ')))

# Imprime uma linha separadora para melhorar a organização da saída.
print("=-" * 15)

# Verifica a situação do aluno com base na média e armazena no dicionário.
if d['média'] > 7:
    d['situação'] = 'aprovado'
elif d['média'] > 3:
    d['situação'] = 'recuperação'
else:
    d['situação'] = 'reprovado'

# Percorre o dicionário e imprime cada chave e valor.
for x, v in d.items():
    print(f'    -{x} é igual a {v}.')

``` 
Nome: João
Média de João: 6.5
=-=-=-=-=-=-=-=-=-=-=-=-=
    -Nome é igual a João.
    -média é igual a 6.5.
    -situação é igual a recuperação.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (91).md
### Última modificação: 2024-08-08 19:17:32

---
tags: 
data: 2024-08-06
nivel:
---
```Python

from random import randint  # Importa a função randint do módulo random para gerar números aleatórios
from time import sleep  # Importa a função sleep do módulo time para inserir pausas no programa
from operator import itemgetter  # Importa a função itemgetter do módulo operator para facilitar a ordenação do dicionário

# Cria um dicionário chamado 'jogo' para armazenar os resultados dos jogadores.
# A chave é o nome do jogador e o valor é o número sorteado no dado.
jogo = {'jogador1': randint(1, 6),
        'jogador2': randint(1, 6),
        'jogador3': randint(1, 6),
        'jogador4': randint(1, 6)}

# Imprime os valores sorteados para cada jogador com uma pausa de 0.5 segundos entre cada impressão.
print('Valore sorteados:')
for k, v in jogo.items():
    print(f'{k} tirou {v} no dado')
    sleep(0.5)

# Ordena o dicionário 'jogo' em ordem decrescente de acordo com os valores (números sorteados).
# A função 'sorted' recebe o dicionário como argumento e utiliza 'itemgetter(1)' para ordenar pelas chaves,
# que são os valores do dicionário, e 'reverse=True' para ordenar em ordem decrescente.
# O resultado é uma lista de tuplas, onde cada tupla contém o nome do jogador e o número sorteado.
ranking = sorted(jogo.items(), key=itemgetter(1), reverse=True)

# Imprime o ranking dos jogadores com uma pausa de 0.5 segundos entre cada impressão.
print('-=' * 30)
print(' ==RANKING DOS JOGADORES ==')
for i, v in enumerate(ranking):
    print(f'       {i + 1}º lugar:{v[0]} com {v[1]}.')
    sleep(0.5)

```
Valore sorteados:
jogador1 tirou 3 no dado
jogador2 tirou 5 no dado
jogador3 tirou 1 no dado
jogador4 tirou 2 no dado
------------------------------------------------------------
 ==RANKING DOS JOGADORES ==
       1º lugar:jogador2 com 5.
       2º lugar:jogador1 com 3.
       3º lugar:jogador4 com 2.
       4º lugar:jogador3 com 1.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (92).md
### Última modificação: 2024-08-08 19:18:51

---
tags: 
data: 2024-08-06
nivel:
---
```Python

from datetime import date  # Importa a biblioteca 'date' para trabalhar com datas

# Cria um dicionário vazio para armazenar as informações do usuário
d = {}

# Obtem os dados do usuário
d['Nome'] = str(input('Nome: '))
Ano_de_nascimento = int(input('Ano de Nascimento: '))
d['Cateira de Trabalho'] = int(input('Carteira de Trabalho (0 ñ tem): '))

# Calcula a idade do usuário
data = date.today().year  # Obtém o ano atual
d['Idade'] = data - Ano_de_nascimento

# Verifica se o usuário possui carteira de trabalho
if d['Cateira de Trabalho'] != 0:
    # Se possui, obtem as informações de contratação e salário
    d['Ano de contratação'] = int(input('Ano de Contratação: '))
    d['Salário'] = int(input('Salário: R$'))

    # Calcula o ano de aposentadoria, considerando 30 anos de contribuição
    d['Aposentadoria'] = (d['Ano de contratação'] - data) + 30

# Imprime as informações do usuário de forma organizada
print('-=' * 30)
for q, w in d.items():
    print(f'{q} é {w}')

```
Nome: João da Silva
Ano de Nascimento: 1980
Carteira de Trabalho (0 ñ tem): 123456789
Ano de Contratação: 2000
Salário: R$ 5000

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Nome é João da Silva
Idade é 43
Cateira de Trabalho é 123456789
Ano de contratação é 2000
Salário é 5000
Aposentadoria é 2030

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (93).md
### Última modificação: 2024-08-08 19:20:03

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Cria um dicionário vazio para armazenar os dados do jogador
d = {}

# Cria uma lista vazia para armazenar a quantidade de gols em cada partida
gols = []

# Inicializa a variável total de gols com 0
total = 0

# Lê o nome do jogador e armazena no dicionário 'd'
d['nome'] = str(input('Nome do jogador: '))

# Lê a quantidade de partidas jogadas e armazena no dicionário 'd'
partidas = int(input(f'Quantas partidas o {d["nome"]} jogou? '))

# Adiciona a lista 'gols' ao dicionário 'd'
d['gols'] = gols

# Inicializa o total de gols no dicionário 'd' com 0
d['total'] = 0

# Loop para ler a quantidade de gols em cada partida
for q in range(1, partidas + 1):
    # Lê a quantidade de gols na partida atual e adiciona à lista 'gols'
    gols.append(int(input(f'Quantos gols na partida {q}: ')))

# Calcula o total de gols e armazena no dicionário 'd'
d['total'] = sum(gols)

# Imprime uma linha de separação
print('-=' * 30)

# Imprime o dicionário 'd' com todos os dados do jogador
print(d)

# Imprime outra linha de separação
print('-=' * 30)

# Loop para imprimir cada chave e valor do dicionário 'd'
for w, e in d.items():
    # Imprime a chave e o valor correspondente
    print(f'O campo {w} tem o valor {e}.')

# Imprime outra linha de separação
print('-=' * 30)

# Imprime o nome do jogador e a quantidade de partidas jogadas
print(f'O jogador {d["nome"]} jogou {len(d["gols"])} partidas.')

# Loop para imprimir a quantidade de gols em cada partida
for c, v in enumerate(d['gols']):
    # Imprime o número da partida e a quantidade de gols
    print(f'   => Na partida {c + 1}, fez {v} gols. ')

# Imprime o total de gols do jogador
print(f'Foi um total de {d["total"]} gols.')

```
Nome do jogador: Cristiano Ronaldo
Quantas partidas o Cristiano Ronaldo jogou? 5
Quantos gols na partida 1: 2
Quantos gols na partida 2: 1
Quantos gols na partida 3: 0
Quantos gols na partida 4: 3
Quantos gols na partida 5: 1
------------------------------------------------------------
{'nome': 'Cristiano Ronaldo', 'gols': [2, 1, 0, 3, 1], 'total': 7}
------------------------------------------------------------
O campo nome tem o valor Cristiano Ronaldo.
O campo gols tem o valor [2, 1, 0, 3, 1].
O campo total tem o valor 7.
------------------------------------------------------------
O jogador Cristiano Ronaldo jogou 5 partidas.
   => Na partida 1, fez 2 gols. 
   => Na partida 2, fez 1 gols. 
   => Na partida 3, fez 0 gols. 
   => Na partida 4, fez 3 gols. 
   => Na partida 5, fez 1 gols. 
Foi um total de 7 gols.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (94).md
### Última modificação: 2024-08-08 19:20:54

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Inicializa uma lista para armazenar os dados de cada pessoa
pessoas = []

# Inicializa a soma das idades e a contagem de pessoas
media = 0
cont = 0

# Loop para cadastrar as pessoas
while True:
    # Cria um dicionário para armazenar os dados de uma pessoa
    pessoas.append({"nome": input("Nome: ").title().strip()})

    # Lê o sexo e valida a entrada
    pessoas[cont]["sexo"] = input("Sexo [F/M]: ").upper().strip()
    while pessoas[cont]["sexo"] not in "FM":
        print("ERRO! Por favor, digite apenas M ou F.")
        pessoas[cont]["sexo"] = input("Sexo [F/M]: ").upper().strip()

    # Lê a idade e adiciona à soma das idades
    pessoas[cont]["idade"] = int(input("Idade: "))
    media += pessoas[cont]["idade"]

    # Incrementa o contador de pessoas
    cont += 1

    # Pergunta se o usuário deseja continuar
    es = input("Quer continuar? [S/N]: ").strip()
    while es not in "snSN":
        print("ERRO! Responda apenas S ou N.")
        es = input("Quer continuar? [S/N]: ").strip()
    if es == "n":
        break

# Calcula a média de idade
media /= len(pessoas)

# Imprime os resultados
print("=-"*35)
print(f"A) Foram cadastradas {len(pessoas)} pessoas.")
print(f"B) A média de idade é de {media} anos..")
print("C) As mulheres cadastradas foram: ", end=" ")

# Imprime a lista de mulheres
for c in pessoas:
    if c["sexo"] == "F":
        print(c["nome"], end=" ")
print()

# Imprime a lista de pessoas com idade acima da média
print("D) Lista de pessoas com a idade acima da média:")
for c in pessoas:
    if c["idade"] > media:
        # Imprime os dados da pessoa
        for k, v in c.items():
            print(f"{k:>8} = {v:<14}", end="")
        print()

print("<< ENCERRADO >>")

```
Nome: João
Sexo [F/M]: M
Idade: 25
Quer continuar? [S/N]: S
Nome: Maria
Sexo [F/M]: F
Idade: 30
Quer continuar? [S/N]: S
Nome: Pedro
Sexo [F/M]: M
Idade: 20
Quer continuar? [S/N]: N
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
A) Foram cadastradas 3 pessoas.
B) A média de idade é de 25.0 anos..
C) As mulheres cadastradas foram:  Maria 
D) Lista de pessoas com a idade acima da média:
     nome = João       
     idade = 25       
     nome = Maria      
     idade = 30       
<< ENCERRADO >>

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (95).md
### Última modificação: 2024-08-08 19:22:01

---
tags: 
data: 2024-08-06
nivel:
---
```Python

# Cria duas listas:
# - jogador: armazenará os dados de cada jogador em dicionários
# - jo: um dicionário temporário para armazenar dados de um jogador
jogador, jo = [], {}

# Loop principal para cadastrar jogadores
while True:
    print("-" * 40)  # Imprime uma linha de separação

    # Coleta dados do jogador
    jo = {
        "Jogador": input("Nome do Jogador:").title(),  # Nome do jogador, com a primeira letra maiúscula
        "gols": [],  # Lista para armazenar gols em cada partida
        "total": 0  # Total de gols do jogador
    }

    # Coleta a quantidade de partidas jogadas e os gols em cada partida
    for c in range(0, int(input(f"Quantas prtidas {jo['Jogador']} jogou?:"))):
        jo["gols"].append(int(input(f"Quantos gols na {c + 1}º partida?: ")))
        jo["total"] += jo["gols"][c]

    # Adiciona o dicionário do jogador à lista de jogadores
    jogador.append(jo.copy())  # Usa copy() para evitar modificações na lista original

    # Verifica se o usuário deseja continuar
    es = input("Quer continuar?:").strip()
    if es in "Nn":  # Se o usuário digitar "N" ou "n", o loop termina
        break

# Imprime a tabela com os dados de todos os jogadores
print("=-" * 40)
print(f"cod {'nome':<18}{'gols':<30}total")  # Cabeçalho da tabela
print("-" * 80)  # Linha de separação

# Itera sobre cada jogador na lista 'jogador'
for d, c in enumerate(jogador):
    print(f"{d:>3}", end=" ")  # Imprime o código do jogador (índice na lista)

    # Imprime nome e gols do jogador
    for k, v in c.items():
        if k == "gols":
            print(f"{str(v):<30}", end="")  # Imprime a lista de gols
        else:
            print(f"{v:<18}", end="")  # Imprime o nome do jogador

    print()  # Pula para a próxima linha

# Loop para mostrar dados de um jogador específico
while True:
    print("-" * 50)
    num = int(input("Mostrar dados de que jogador?(999 para parar):"))

    # Verifica se o usuário deseja parar
    if num == 999:
        break

    # Valida se o código do jogador é válido
    if num > len(jogador):
        print(f"ERRO! Não existe jogador com código {num}! Tente novamente.")
    else:
        # Imprime dados do jogador selecionado
        print(f"-- LEVANTAMENTO DO JOGADOR {jogador[num]['Jogador']}")
        for e, n in enumerate(jogador[num]["gols"]):
            print(f"{'=>':>5}No {e + 1}º jogo, fez {n} gols. ")

print("<< VOLTE SEMPRE >>")

```
>>> Nome do Jogador: Cristiano Ronaldo
>>> Quantas prtidas Cristiano Ronaldo jogou?: 3
>>> Quantos gols na 1º partida?: 2
>>> Quantos gols na 2º partida?: 1
>>> Quantos gols na 3º partida?: 3
>>> Quer continuar?: s
>>> Nome do Jogador: Lionel Messi
>>> Quantas prtidas Lionel Messi jogou?: 2
>>> Quantos gols na 1º partida?: 4
>>> Quantos gols na 2º partida?: 2
>>> Quer continuar?: n
>>> =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
>>> cod nome              gols                         total
>>> --------------------------------------------------------------------------------
>>>   0 Cristiano Ronaldo   [2, 1, 3]                  6
>>>   1 Lionel Messi        [4, 2]                     6
>>> Mostrar dados de que jogador?(999 para parar): 0
>>> -------- LEVANTAMENTO DO JOGADOR Cristiano Ronaldo
>>>     =>No 1º jogo, fez 2 gols. 
>>>     =>No 2º jogo, fez 1 gols. 
>>>     =>No 3º jogo, fez 3 gols. 
>>> Mostrar dados de que jogador?(999 para parar): 999
>>> << VOLTE SEMPRE >>
>>> 

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (96).md
### Última modificação: 2024-08-08 19:23:07

---
tags: 
data: 2024-08-06
nivel:
---
```Python

"""
096: Faça um programa que tenha uma função chamada área(),
 que receba as dimensões de um terreno retangular (largura e comprimento) e mostre a área do terreno.
"""

def area(a, b):
    """
    Calcula a área de um terreno retangular.

    Args:
        a (float): Largura do terreno em metros.
        b (float): Comprimento do terreno em metros.

    Returns:
        None: Imprime a área do terreno.
    """

    # Calcula a área do terreno
    area_terreno = a * b

    # Imprime a área do terreno
    print(f'A área de um terreno {a} X {b} é de {area_terreno}m².')


# Solicita ao usuário a largura do terreno
a = float(input('LARGURA (M): '))

# Solicita ao usuário o comprimento do terreno
b = float(input('COMPRIMENTO (M): '))

# Chama a função área() para calcular e imprimir a área do terreno
area(a, b)

```
LARGURA (M): 10
COMPRIMENTO (M): 20
A área de um terreno 10.0 X 20.0 é de 200.0m².

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (97).md
### Última modificação: 2024-08-08 19:24:37

---
tags: 
data: 2024-08-06
nivel:
---
```Python

def escreva(texto):
  """
  Esta função recebe um texto como parâmetro e o exibe em um bloco com bordas de '~'.
  O tamanho do bloco se adapta ao comprimento do texto.

  Args:
    texto: O texto a ser exibido.
  """

  tamanho = len(texto) + 4  # Calcula o tamanho do bloco (comprimento do texto + 4 para os espaços e bordas)
  print('~' * tamanho)  # Imprime a linha superior do bloco
  print(f' {texto} ')  # Imprime o texto com um espaço de indentação
  print('~' * tamanho)  # Imprime a linha inferior do bloco

# Exemplo de uso da função
escreva('Olá, Mundo!')

```
 Saída:
 ~~~~~~~~~
  Olá, Mundo!
 ~~~~~~~~~

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (98).md
### Última modificação: 2024-08-08 19:26:25

---
tags: 
data: 2024-08-06
nivel:
---
```Python

from time import sleep

# Define a função 'contagem' que recebe três parâmetros: início, fim e passo.
def contagem(a, b, c):
    # Verifica se o passo é negativo e corrige para positivo se for.
    if c < 0:
        c += -1
    # Verifica se o passo é zero e define como 1 se for.
    if c == 0:
        c = 1
    # Imprime um cabeçalho para a contagem.
    print('-=~' * 20)
    print(f'Contagem de {a} até {b} de {c} em {c}.')

    # Verifica se o início é menor que o fim.
    if a < b:
        # Se o início for menor que o fim, a contagem é crescente.
        cont = a  # Inicializa o contador com o valor de início.
        # Loop que continua enquanto o contador for menor ou igual ao fim.
        while cont <= b:
            # Imprime o valor do contador.
            print(f'{cont}', end=' ')
            # Incrementa o contador com o valor do passo.
            cont += c
            # Espera 0.2 segundos antes de imprimir o próximo valor.
            sleep(0.2)
        # Imprime 'FIM!' para indicar o final da contagem.
        print('FIM!')
    else:
        # Se o início for maior que o fim, a contagem é decrescente.
        cont = a  # Inicializa o contador com o valor de início.
        # Loop que continua enquanto o contador for maior ou igual ao fim.
        while cont >= b:
            # Imprime o valor do contador.
            print(f'{cont}', end=' ')
            # Decrementa o contador com o valor do passo.
            cont -= c
            # Espera 0.2 segundos antes de imprimir o próximo valor.
            sleep(0.2)
        # Imprime 'FIM' para indicar o final da contagem.
        print('FIM')

# Executa a função 'contagem' com alguns exemplos pré-definidos.
contagem(1, 10, 0)  # Contagem de 1 até 10 com passo 1.
contagem(10, 0, 2)  # Contagem de 10 até 0 com passo 2.

# Solicita ao usuário que insira os valores de início, fim e passo.
inicio = int(input("Início: "))
fim = int(input("Fim: "))
passo = int(input("Passo: "))

# Executa a função 'contagem' com os valores inseridos pelo usuário.
contagem(inicio, fim, passo)

```
 -=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~
Contagem de 1 até 10 de 1 em 1.
1 2 3 4 5 6 7 8 9 10 FIM!
-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~
Contagem de 10 até 0 de 2 em 2.
10 8 6 4 2 0 FIM
Início: 10
Fim: 4
Passo: 1
-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~
Contagem de 10 até 4 de 1 em 1.
10 9 8 7 6 5 4 FIM

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Aula (99).md
### Última modificação: 2024-08-08 19:28:43

---
tags: 
data: 2024-08-06
nivel:
---
```Python

"""99: Faça um programa que tenha uma função chamada maior(),
que receba vários parâmetros com valores inteiros.
Seu programa tem que analisar todos os valores e dizer qual deles é o maior."""

from time import sleep

# Define a função maior() que recebe um número variável de argumentos
# usando o operador *
def maior(*num):
    print('-=~' * 20)  # Imprime um separador visual
    print(f'Analizando os calores passados...')  # Informa que a análise está em andamento
    sleep(0.5)  # Pausa a execução por 0.5 segundos para melhor visualização

    # Inicializa as variáveis ma (maior) e cont (contador)
    ma = cont = 0

    # Itera sobre os valores passados como argumentos
    for v in num:
        print(f'{v}', end=' ')  # Imprime cada valor na mesma linha
        # Se for o primeiro valor, atribui ele à variável ma
        if cont == 0:
            ma = v
        else:
            # Se o valor atual for maior que ma, atualiza ma com o valor atual
            if v > ma:
                ma = v
        cont += 1  # Incrementa o contador

    # Imprime os resultados da análise
    print(f'''Foram informados {cont} valores ao todo.
O maior valor informado foi {ma}.''')


# Chama a função maior() com diferentes conjuntos de números
analize(2, 9, 7, 6, 4, 6, 7)
analize(5, 3, 4, 5, 6)
analize(12, 4, 56)
analize()  # Chama a função sem passar nenhum argumento

```
-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~
Analizando os calores passados...
2 9 7 6 4 6 7 Foram informados 7 valores ao todo.
O maior valor informado foi 2.
-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~
Analizando os calores passados...
5 3 4 5 6 Foram informados 5 valores ao todo.
O maior valor informado foi 5.
-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~
Analizando os calores passados...
12 4 56 Foram informados 3 valores ao todo.
O maior valor informado foi 12.
-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~-=~
Analizando os calores passados...
Foram informados 0 valores ao todo.
O maior valor informado foi 0.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Aulas\Curso em video\Python Code for Finding the Successor of an Integer.md
### Última modificação: 2024-08-09 23:08:40

---
tags: 
data: 2024-08-06
nivel:
---
```Python
# Solicita ao usuário que digite um número inteiro e armazena o valor na variável "num".
num = int(input('Qual numero?:'))

# Imprime na tela uma mensagem formatada com o número digitado e seu sucessor.
# A função "format()" substitui os "{}" pela variável "num" e "num + 1", respectivamente.
print('O sucessor de {} é {}'.format(num, num + 1))

# Imprime na tela uma mensagem formatada com o número digitado e seu antecessor.
# A função "format()" substitui os "{}" pela variável "num" e "num - 1", respectivamente.
print('O antecessor de {} é {}'.format(num, num - 1))

```
**Exemplo de funcionamento:**

1. **Entrada:** O usuário digita o número 5.
    
2. **Processamento:** O programa armazena o número 5 na variável num.
    
    - Calcula o sucessor: num + 1 = 5 + 1 = 6
        
    - Calcula o antecessor: num - 1 = 5 - 1 = 4
        
3. **Saída:** O programa imprime as seguintes mensagens na tela:
    
    - "O sucessor de 5 é 6"
        
    - "O antecessor de 5 é 4"



reescreva e faça comentários minuciosos do programa acima e faça um exemplo simples do funcionamento.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Comandos\,get.md
### Última modificação: 2024-11-13 19:18:19

---
tags:
  - Python
  - Programação
  - Comando
data: 2024-11-13
---
`get` facilita o tratamento de chaves ausentes em dicionários sem gerar erros, permitindo o uso de um valor padrão ou `None`.

```python
alunos = {'Maria': 9.5, 'João': 8.0}

# Usando get para buscar uma chave que existe
nota_maria = alunos.get('Maria')  # Retorna 9.5

# Usando get para buscar uma chave que não existe, com valor padrão
nota_pedro = alunos.get('Pedro', 0)  # Retorna 0, pois 'Pedro' não está no dicionário

# Sem valor padrão, retorna None
nota_ana = alunos.get('Ana')  # Retorna None, pois 'Ana' não está no dicionário
```


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Comandos\@atributo.setters e getters.md
### Última modificação: 2024-08-16 00:37:09

---
tags:
  - POO
  - Python
  - Programação
data: 2024-08-15
nivel:
---
Os [[Decorador|decoradores]] setters e getters são oque seu significado do português então: *get and set* -> obter e definir.
Então quando se usa o `@atributo.setter` ele permite que seja mudado o [[Atributos|Atributo]]. 
E quando se usa o `@atributo.getter` permite ver o atributo, pelo `return` por exemplo.

# Exemplos
```python
class Pessoa:
    def __init__(self, idade):
        self._idade = idade

    @property
    def idade(self):
        return self._idade  # Getter: retorna o valor de _idade

    @idade.setter
    def idade(self, valor):
        if valor < 0:
            raise ValueError("Idade não pode ser negativa")  # Setter: valida o valor antes de definir _idade
        self._idade = valor

```
```python
p = Pessoa(30)         # Cria um objeto com idade inicial de 30
print(p.idade)         # Usa o getter, imprime 30

p.idade = 25           # Usa o setter, define a idade para 25
print(p.idade)         # Usa o getter, imprime 25
```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Comandos\@property.md
### Última modificação: 2024-08-15 23:33:54

---
tags:
  - Python
  - POO
  - Programação
data: 2024-08-15
nivel:
---
O `@property` é um [[Decorador]] em Python que permite definir [[Métodos]] de uma [[Classe]] que se comportam como [[Atributos]]. Ele fornece uma maneira de acessar métodos da classe como se fossem atributos, sem precisar chamar explicitamente o método.

# Exemplo
Com o @property
```python
c = Circulo(5)
print(c.raio)  # Acessa o método raio como um atributo
print(c.area)  # Acessa o método area como um atributo
c.raio = 10    # Usa o setter para definir o valor do raio
```
Sem
```python
c = Circulo(5)
print(c.get_raio())        # Chama o método para acessar o raio
print(c.calcular_area())   # Chama o método para calcular a área
c.set_raio(10)             # Chama o método para alterar o raio
```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Comandos\Argumento.md
### Última modificação: 2024-11-16 00:02:07

---
tags:
  - Conceito
  - Python
data: 2024-11-15
---
É passar um valor para o [[Parâmetro|parâmetro]] de uma [[Função|função]].

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Comandos\Decorador.md
### Última modificação: 2024-08-16 00:27:58

---
tags:
  - Python
  - POO
  - Programação
data: 2024-08-15
nivel:
---
- [[@property]]
- [[@atributo.setters e getters]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Comandos\Função.md
### Última modificação: 2024-11-15 23:52:02

---
tags:
  - Comando
  - Python
data: 2024-11-14
---
![[Pasted image 20241114161235.png]]
[[Argumento]]
Nome
Resultado
[[Parâmetro]]


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Comandos\math,factorial.md
### Última modificação: 2025-01-04 21:23:13

---
tags:
  - Comando
data: 2025-01-04
---
Retorna o fatorial de um numero. 
```python
import math
math.factorial(3)
```
6

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Comandos\Parâmetro.md
### Última modificação: 2024-11-16 00:03:55

---
tags:
  - Conceito
  - Python
data: 2024-11-15
---
Parâmetro é uma variável definida em uma função para receber valores quando ela é chamada.

```python
def saudacao(nome):
    print(f"Olá, {nome}!")

saudacao("Maria")  # Saída: Olá, Maria!
```
**Explicação**:

- `nome` é o **parâmetro** da [[Função]] `saudacao`.
- `"Maria"` é um [[Argumento]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Comandos\pptint().md
### Última modificação: 2024-08-26 01:20:22

---
tags:
  - Programação
  - Python
data: 2024-08-26
nivel:
---
# Exemplo
```python
import pprint

my_dict = {'name': 'João', 'idade': 30, 'cidade': 'São Paulo'}

print(my_dict)  # Saída: {'name': 'João', 'idade': 30, 'cidade': 'São Paulo'}

pprint.pprint(my_dict)  # Saída:
                      # {'cidade': 'São Paulo',
                      #  'idade': 30,
                      #  'name': 'João'}
```



### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Comandos\Private em python.md
### Última modificação: 2024-08-13 23:42:51

---
tags:
  - Python
  - POO
  - Programação
data: 2024-08-13
nivel:
---
Em Python, o uso de dois underscores (`__`) no início de um nome de atributo (`__nome`) aciona o _name mangling_, que altera internamente o nome do atributo para `_Pessoa__nome`, dificultando o acesso acidental. No entanto, isso não impede totalmente o acesso, apenas desencoraja o uso direto.
```python
class Pessoa:
    def __init__(self, nome, idade):
        self.__nome = nome  # Usando dois underlines para indicar "privado"
        self.idade = idade

    # Método público para acessar o nome
    def get_nome(self):
        return self.__nome

    # Método público para modificar o nome
    def set_nome(self, nome):
        self.__nome = nome

p = Pessoa("Carlos", 25)

# Acesso ao atributo nome via método getter
print(p.get_nome())

# Tentativa de acesso direto ao atributo privado (resulta em erro)
# print(p.__nome)  # Erro: AttributeError

# Acesso "indireto" ao atributo privado usando o nome "mangling"
print(p._Pessoa__nome)  # Funciona, mas não é recomendado.

```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Comandos\__dict__.md
### Última modificação: 2024-08-13 23:30:27

---
tags:
  - Python
  - Programação
  - POO
data: 2024-08-13
nivel:
---
O `__dict__` é um atributo especial em Python que armazena todos os [[Atributos]]  de um [[Objetos]] em um [[dicionário]]. Ele é utilizado principalmente para objetos de [[Classe]] personalizadas.
funciona igual ao `vars()`
# Exemplo

``` python
class Pessoa:
    def __init__(self, nome, idade):
        self.nome = nome
        self.idade = idade

# Criando uma instância da classe Pessoa
p = Pessoa("Maria", 30)

# Acessando o __dict__ do objeto
print(p.__dict__) #     vars(p)

```

Neste exemplo, `p.__dict__` retornaria:

`{'nome': 'Maria', 'idade': 30}`

Isso significa que o dicionário `__dict__` contém as variáveis `nome` e `idade`, com seus respectivos valores.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Conceitos\to int.md
### Última modificação: 2024-12-26 20:42:49

---
tags:
  - Conceito
data: 2024-12-26
---
# Float to int
1. Verifique se quando transformar não vai causar nenhum problema [[,array_equal]] [[,astype]]
2. Caso não ter problemas apenas transforme , se houver verifique a viabilidade ou a possibilidade.[[,astype]]
3. e verifique [[,info]] or [[,dtypes]]
# Object to int

Verifique a viabilidade da mudança e a faça
[[,to_numeric]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Matplotlib\Comandos\,'hist'.md
### Última modificação: 2024-12-20 19:56:59

---
tags: 
data: 2024-12-20
---
O histograma é um gráfico de barras onde o eixo Y representa a frequência (quantidade de repetições) dos valores agrupados em intervalos (`bins=`) no eixo X
Cria um [[Histograma]].
[[bind=]]
```python
df[df['male'] == 1]['height'].plot(kind='hist', bins=30)
df[df['male'] == 0]['height'].plot(kind='hist', bins=30, alpha=0.8) 
plt.legend(['Male', 'Female']) 
plt.show()
```
![[Pasted image 20241220193915.png]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Matplotlib\Comandos\,bar.md
### Última modificação: 2024-12-29 23:11:10

---
tags:
  - Comando
data: 2024-12-29
---
No **matplotlib**, a função `bar()` é usada para criar gráficos de barras, que são úteis para comparar valores entre diferentes categorias. Ela desenha barras verticais ou horizontais, onde a altura (ou comprimento, no caso de barras horizontais) de cada barra representa o valor associado a uma categoria específica. Este tipo de gráfico é ideal para representar dados categóricos ou comparações entre diferentes grupos.

```PYTHON
import matplotlib.pyplot as plt

# Dados
categorias = ['A', 'B', 'C', 'D']
valores = [10, 15, 7, 20]

# Criando o gráfico de barras
plt.bar(categorias, valores)

# Adicionando título e rótulos
plt.title('Exemplo de Gráfico de Barras')
plt.xlabel('Categorias')
plt.ylabel('Valores')

# Exibindo o gráfico
plt.show()

```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Matplotlib\Comandos\,legend.md
### Última modificação: 2024-12-18 21:58:37

---
tags:
  - Comando
data: 2024-12-18
---
```python
plt.plot([1, 2, 3], [4, 5, 6], label='Linha 1')
plt.plot([1, 2, 3], [6, 5, 4], label='Linha 2')
plt.legend(["Descendo", "Subindo"])  # Adiciona a legenda
plt.show()
```
![[Pasted image 20241218215829.png|200]]


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Matplotlib\Comandos\,plot.md
### Última modificação: 2024-12-17 22:55:08

---
tags:
  - Gráfico
  - Comando
data: 2024-12-14
---
[[,title=]]: é o parâmetro para definir o título do gráfico.
[[Marcador]]: é o parâmetro para alterar o estilo do marcador do gráfico.
[[x= e y=]]: são os parâmetros para construir duas colunas relacionadas entre si.
[[xlabel= e ylabel=]]: são os parâmetros para definir as legendas dos eixos.
[[,xlim= e ,ylim=]]: são os parâmetros para definir os limites dos eixos.
[[grid=]]: é o parâmetro para adicionar linhas de grade.
[[figsize=]]: é o parâmetro para definir o tamanho do gráfico.
[[legend=]]: é o parâmetro para adicionar ou remover a legenda do gráfico.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Matplotlib\Comandos\,scatter_matrix.md
### Última modificação: 2024-12-20 20:57:34

---
tags:
  - Comando
data: 2024-12-20
---
O `scatter_matrix()` cria uma matriz de gráficos de dispersão entre as colunas de um DataFrame para analisar relações e distribuições de dados.
```python
import pandas as pd
import matplotlib.pyplot as plt
from pandas.plotting import scatter_matrix

# Criando um DataFrame de exemplo
data = {
    "A": [1, 2, 3, 4, 5],
    "B": [2, 3, 4, 5, 6],
    "C": [5, 4, 3, 2, 1]
}
df = pd.DataFrame(data)

# Criando a matriz de dispersão
scatter_matrix(df, alpha=0.8, figsize=(6, 6), diagonal='hist')
plt.show()
```
![[Pasted image 20241220205729.png|400]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Matplotlib\Comandos\,show.md
### Última modificação: 2024-12-14 22:27:08

---
tags:
  - Gráfico
  - Comando
data: 2024-12-14
---

```python
df.show()
```
mostra o todos os graficos pre configurados


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Matplotlib\Comandos\,title=.md
### Última modificação: 2024-12-17 22:20:17

---
tags:
  - Gráfico
  - Comando
data: 2024-12-14
---
Nomeia o título do gráfico.
```python
df.plot(title='A e B')
```
![[Pasted image 20241217222012.png|200]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Matplotlib\Comandos\,xlabel= or ,ylabel=.md
### Última modificação: 2024-12-17 22:51:42

---
tags:
  - Gráfico
  - Comando
data: 2024-12-14
---
Métodos para renomear os eixos.
```python
plt.xlabel("Oi, sou B")
plt.ylabel("Oi, sou A")

df.plot(xlabel="Oi, sou B", 
		ylabel="Oi, sou A")
```

![[Pasted image 20241217225117.png|200]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Matplotlib\Comandos\,xlim= e ,ylim=.md
### Última modificação: 2024-12-17 22:53:03

---
tags:
  - Gráfico
data: 2024-12-14
---
Parâmetro que limita a quantidade dos eixos
```python
x = [1, 2, 3, 4, 5]
y = [1, 4, 9, 16, 25]

plt.plot(x, y)
plt.xlim(0, 6)  # Limita o eixo X entre 0 e 6
plt.ylim(0, 30)  # Limita o eixo Y entre 0 e 30
plt.show()
```
![[Pasted image 20241217225228.png|200]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Matplotlib\Comandos\alpha=.md
### Última modificação: 2024-12-17 23:32:40

---
tags:
  - Comando
data: 2024-12-17
---
O parâmetro `alpha` controla a transparência de um gráfico, onde `alpha=1` é totalmente opaco e `alpha=0` é totalmente transparente.
![[fvg.gif|200]]


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Matplotlib\Comandos\bind=.md
### Última modificação: 2024-12-20 19:33:10

---
tags:
  - Comando
data: 2024-12-20
---


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Matplotlib\Comandos\figsize=.md
### Última modificação: 2024-12-17 22:59:43

---
tags:
  - Gráfico
  - Comando
data: 2024-12-14
---
Parâmetro que diz o tamanho em **polegadas** (_inches_)

```python
df = pd.DataFrame({'a':[2, 3, 4, 5], 'b':[4, 9, 16, 25]}) 
df.plot(x='b', y='a', style='o', xlim=[0, 30], figsize=[2, 2]) 
df.plot(x='b', y='a', style='o', xlim=[0, 30], figsize=[10, 4]) plt.show()
```
![[Pasted image 20241217225857.png|200]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Matplotlib\Comandos\grid=.md
### Última modificação: 2024-12-14 21:52:04

---
tags:
  - Gráfico
  - Comando
data: 2024-12-14
---
Parâmetro que diz se tera linhas, ou grades.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Matplotlib\Comandos\kind=.md
### Última modificação: 2024-12-17 23:35:50

---
tags:
  - Gráfico
  - Conceito
data: 2024-12-17
---
| **Valor de `kind`**    | **Tipo de Gráfico**                     | **Descrição**                                                                                                 |
| ---------------------- | --------------------------------------- | ------------------------------------------------------------------------------------------------------------- |
| `'line'`               | [[Gráfico de Linha]]                    | O gráfico padrão, conectando os pontos com uma linha.                                                         |
| `'bar'`                | [[Gráfico de Barras Verticais]]         | Um gráfico de barras verticais.                                                                               |
| `'barh'`               | [[Gráfico de Barras Horizontais]]       | Um gráfico de barras horizontais.                                                                             |
| `'hist'`               | [[Histograma]]                          | Um gráfico de distribuição de dados, representando a frequência de valores.                                   |
| `'box'`                | [[Diagrama de Caixa]] (Boxplot)         | Um gráfico que mostra a distribuição de dados com quartis.                                                    |
| `'kde'` ou `'density'` | [[Gráfico de Densidade]]                | Representação da densidade de probabilidade dos dados, também conhecido como Kernel Density Estimation (KDE). |
| `'area'`               | [[Gráfico de Área]]                     | Similar ao gráfico de linha, mas a área sob a linha é preenchida.                                             |
| `'pie'`                | [[Gráfico de Pizza]]                    | Um gráfico circular que representa a proporção de cada categoria.                                             |
| `'scatter'`            | [[Gráfico de Dispersão ]](Scatter Plot) | Um gráfico de dispersão, que plota pontos individuais em um plano cartesiano.                                 |

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Matplotlib\Comandos\legend=.md
### Última modificação: 2024-12-17 23:02:38

---
tags:
  - Gráfico
  - Comando
data: 2024-12-14
---
O parâmetro **`legend`** do método **`plot()`** em pandas controla a exibição da legenda no gráfico. Quando **`legend=True`**, a legenda é mostrada automaticamente.
```python
data = {'x': [1, 2, 3], 'y': [4, 5, 6], 'z': [7, 8, 9]}
df = pd.DataFrame(data)

df.plot(x='x', y=['y', 'z'], legend=True)
df.plot(x='x', y=['y', 'z'], legend=False)

plt.show()
```
![[Pasted image 20241217230128.png|200]] ![[Pasted image 20241217230147.png|200]] 


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Matplotlib\Comandos\Marcador.md
### Última modificação: 2024-12-18 19:29:32

---
tags:
  - Gráfico
  - Comando
data: 2024-12-14
---
```python
plt.plot(df['c'], df['a'], 'o')
df.plot(style='o')
```
![[Pasted image 20241217224459.png|200]]

| **Estilo** | **Significado**                | **Exemplo**                                           |
| ---------- | ------------------------------ | ----------------------------------------------------- |
| **`'-'`**  | Linha contínua (padrão)        | ![m00](https://matplotlib.org/stable/_images/m00.png) |
| **`'--'`** | Linha tracejada                | `style='--'`                                          |
| **`':'`**  | Linha pontilhada               | `style=':'`                                           |
| **`'-.'`** | Linha pontilhada e tracejada   | `style='-.'`                                          |
| **`'o'`**  | Marcador de círculo            | `style='o'`                                           |
| **`'s'`**  | Marcador quadrado              | `style='s'`                                           |
| **`'^'`**  | Marcador triangular para cima  | `style='^'`                                           |
| **`'v'`**  | Marcador triangular para baixo | `style='v'`                                           |
| **`'p'`**  | Marcador pentagonal            | `style='p'`                                           |
| **`'*'`**  | Marcador em forma de estrela   | `style='*'`                                           |
| **`'+'`**  | Marcador de mais (+)           | `style='+'`                                           |
| **`'x'`**  | Marcador em forma de X         | `style='x'`                                           |
| **`'d'`**  | Marcador em forma de diamante  | `style='d'`                                           |
| **`'r'`**  | Cor vermelha                   | `style='r'`                                           |
| **`'g'`**  | Cor verde                      | `style='g'`                                           |
| **`'b'`**  | Cor azul                       | `style='b'`                                           |
| **`'c'`**  | Cor ciano                      | `style='c'`                                           |
| **`'m'`**  | Cor magenta                    | `style='m'`                                           |
| **`'y'`**  | Cor amarela                    | `style='y'`                                           |
| **`'k'`**  | Cor preta                      | `style='k'`                                           |
| **`'w'`**  | Cor branca                     | `style='w'`                                           |

| symbol               | description                                           |                                                                                  |
| -------------------- | ----------------------------------------------------- | -------------------------------------------------------------------------------- |
| `"."`                | ![m00](https://matplotlib.org/stable/_images/m00.png) | point                                                                            |
| `","`                | ![m01](https://matplotlib.org/stable/_images/m01.png) | pixel                                                                            |
| `"o"`                | ![m02](https://matplotlib.org/stable/_images/m02.png) | circle                                                                           |
| `"v"`                | ![m03](https://matplotlib.org/stable/_images/m03.png) | triangle_down                                                                    |
| `"^"`                | ![m04](https://matplotlib.org/stable/_images/m04.png) | triangle_up                                                                      |
| `"<"`                | ![m05](https://matplotlib.org/stable/_images/m05.png) | triangle_left                                                                    |
| `">"`                | ![m06](https://matplotlib.org/stable/_images/m06.png) | triangle_right                                                                   |
| `"1"`                | ![m07](https://matplotlib.org/stable/_images/m07.png) | tri_down                                                                         |
| `"2"`                | ![m08](https://matplotlib.org/stable/_images/m08.png) | tri_up                                                                           |
| `"3"`                | ![m09](https://matplotlib.org/stable/_images/m09.png) | tri_left                                                                         |
| `"4"`                | ![m10](https://matplotlib.org/stable/_images/m10.png) | tri_right                                                                        |
| `"8"`                | ![m11](https://matplotlib.org/stable/_images/m11.png) | octagon                                                                          |
| `"s"`                | ![m12](https://matplotlib.org/stable/_images/m12.png) | square                                                                           |
| `"p"`                | ![m13](https://matplotlib.org/stable/_images/m13.png) | pentagon                                                                         |
| `"P"`                | ![m23](https://matplotlib.org/stable/_images/m23.png) | plus (filled)                                                                    |
| `"*"`                | ![m14](https://matplotlib.org/stable/_images/m14.png) | star                                                                             |
| `"h"`                | ![m15](https://matplotlib.org/stable/_images/m15.png) | hexagon1                                                                         |
| `"H"`                | ![m16](https://matplotlib.org/stable/_images/m16.png) | hexagon2                                                                         |
| `"+"`                | ![m17](https://matplotlib.org/stable/_images/m17.png) | plus                                                                             |
| `"x"`                | ![m18](https://matplotlib.org/stable/_images/m18.png) | x                                                                                |
| `"X"`                | ![m24](https://matplotlib.org/stable/_images/m24.png) | x (filled)                                                                       |
| `"D"`                | ![m19](https://matplotlib.org/stable/_images/m19.png) | diamond                                                                          |
| `"d"`                | ![m20](https://matplotlib.org/stable/_images/m20.png) | thin_diamond                                                                     |
| `"\|"`               | ![m21](https://matplotlib.org/stable/_images/m21.png) | vline                                                                            |
| `"_"`                | ![m22](https://matplotlib.org/stable/_images/m22.png) | hline                                                                            |
| (`TICKLEFT`)         | ![m25](https://matplotlib.org/stable/_images/m25.png) | tickleft                                                                         |
| (`TICKRIGHT`)        | ![m26](https://matplotlib.org/stable/_images/m26.png) | tickright                                                                        |
| (`TICKUP`)           | ![m27](https://matplotlib.org/stable/_images/m27.png) | tickup                                                                           |
| (`TICKDOWN`)         | ![m28](https://matplotlib.org/stable/_images/m28.png) | tickdown                                                                         |
| (`CARETLEFT`)        | ![m29](https://matplotlib.org/stable/_images/m29.png) | caretleft                                                                        |
| (`CARETRIGHT`)       | ![m30](https://matplotlib.org/stable/_images/m30.png) | caretright                                                                       |
| (`CARETUP`)          | ![m31](https://matplotlib.org/stable/_images/m31.png) | caretup                                                                          |
| (`CARETDOWN`)        | ![m32](https://matplotlib.org/stable/_images/m32.png) | caretdown                                                                        |
| (`CARETLEFTBASE`)    | ![m33](https://matplotlib.org/stable/_images/m33.png) | caretleft (centered at base)                                                     |
| (`CARETRIGHTBASE`)   | ![m34](https://matplotlib.org/stable/_images/m34.png) | caretright (centered at base)                                                    |
| (`CARETUPBASE`)      | ![m35](https://matplotlib.org/stable/_images/m35.png) | caretup (centered at base)                                                       |
| (`CARETDOWNBASE`)    | ![m36](https://matplotlib.org/stable/_images/m36.png) | caretdown (centered at base)                                                     |
| `"none"` or `"None"` |                                                       | nothing                                                                          |
| `" "` or `""`        |                                                       | nothing                                                                          |
| `"$...$"`            | ![m37](https://matplotlib.org/stable/_images/m37.png) | Render the string using mathtext. E.g `"$f$"` for marker showing the letter `f`. |

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Matplotlib\Comandos\rot=.md
### Última modificação: 2024-12-18 21:30:04

---
tags: 
data: 2024-12-18
---
Rotacional a legenda.
```python
df.plot(x='date', y='open', legend=False, title='Starbucks market open', xlabel='Date', ylabel='Share price / USD', rot=45) plt.show()
```
![[Pasted image 20241218212959.png|200]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Matplotlib\Comandos\savefig().md
### Última modificação: 2024-12-14 22:26:31

---
tags:
  - Gráfico
  - Comando
data: 2024-12-14
---

```python

```
```python

```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Matplotlib\Comandos\x= e y=.md
### Última modificação: 2024-12-17 22:47:21

---
tags:
  - Gráfico
  - Comando
data: 2024-12-14
---
No método **`plot()`**, o parâmetro **`x`** define os valores no eixo horizontal (x), enquanto **`y`** define os valores no eixo vertical (y).
```python
import matplotlib.pyplot as plt

x = [1, 2, 3, 4]
y = [10, 20, 25, 30]

plt.plot(x,y)
plt.show()
```


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Nympy\array.shape.md
### Última modificação: 2024-08-19 20:08:18

---
tags: 
data: 2024-08-19
nivel:
---
Responde tamanho do array
```python
array([[ 0,  1,  2],
       [ 3,  4,  5],
       [ 6,  7,  8],
       [ 9, 10, 11],
       [12, 13, 14],
       [15, 16, 17],
       [18, 19, 20],
       [21, 22, 23],
       [24, 25, 26]])
```
`array.shape`
(9, 3)

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Nympy\Comandos\,array_equal.md
### Última modificação: 2024-12-21 20:57:04

---
tags:
  - Comando
data: 2024-12-21
---
A função `array_equal` compara dois arrays e retorna `True` se forem exatamente iguais em forma e conteúdo, e `False` caso contrário.
```python
d = {'col1': [1.0, 2.0, 3.0, 4.0], 'col2': [5.0, 6.01, 7.0, 8.0]} 
df = pd.DataFrame(data=d) 
# verifique se a conversão de 'col2' é segura 
np.array_equal(df['col2'], df['col2'].astype('int'))
```



### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Nympy\Comandos\,cov.md
### Última modificação: 2025-01-03 20:41:40

---
tags: 
data: 2025-01-03
---
Ele faz a [[Covariância]] de 2 [[Series]]

```python
np.cov(x,y)
```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Nympy\Comandos\,sqrt.md
### Última modificação: 2025-01-03 20:58:48

---
tags:
  - Conceito
data: 2025-01-03
---
Retorna a raiz quadrada. Para medir o [[desvio padrão]] de uma [[variância]].
sqrt  = square root
```python
np.sqrt(variance)
```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Nympy\Comandos\,std.md
### Última modificação: 2025-01-03 20:56:12

---
tags:
  - Comando
data: 2025-01-03
---
Diz o [[Desvio padrão]]
```python
np.std(x)
```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Nympy\Comandos\,var.md
### Última modificação: 2025-01-03 20:40:52

---
tags:
  - Comando
data: 2025-01-03
---
Ele faz a [[Variância]] do conjunto.

```python
np.var(x)
```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Nympy\Comandos\Comandos.md
### Última modificação: 2024-08-21 22:08:19

---
tags:
  - Programação
  - Bibliotecas
data: 2024-08-19
nivel:
---
Basicamente é um sistema de arrays matrizes. 
### 1. **Criação de arrays**:

- `np.array()`: Cria arrays a partir de listas ou outras coleções.
- `np.zeros()`: Cria um array cheio de zeros.
- `np.ones()`: Cria um array cheio de uns.
- `np.arange()`: Gera uma sequência de números.
- `np.linspace()`: Gera números espaçados uniformemente em um intervalo.

### 2. **Manipulação de arrays**:

- `np.reshape()`: Muda a forma (dimensão) do array.
- `np.ravel()`: Achata o array.
- `np.transpose()`: Transpõe o array.
- `np.concatenate()`: Junta arrays ao longo de um eixo.
- `np.split()`: Divide arrays em partes.

### 3. **Operações matemáticas elementares**:

- `np.add()`, `np.subtract()`, `np.multiply()`, `np.divide()`: Operações básicas entre arrays.
- `np.dot()`: Produto escalar ou produto matricial.
- `np.sqrt()`: Raiz quadrada de cada elemento.
- `np.exp()`: Exponencial de cada elemento.
- `np.log()`: Logaritmo de cada elemento.

### 4. **Funções estatísticas**:

- `np.mean()`: Média dos elementos.
- `np.median()`: Mediana dos elementos.
- `np.std()`: Desvio padrão dos elementos.
- `np.var()`: Variância dos elementos.
- `np.sum()`: Soma dos elementos.
- `np.min()`, `np.max()`: Mínimo e máximo do array.

### 5. **Indexação e fatiamento**:

- Indexação simples e avançada com `[]`.
- Fatiamento com `[:]`.
- Máscaras booleanas para filtragem de elementos.

### 6. **Transformações lineares**:

- `np.linalg.inv()`: Inversa de uma matriz.
- `np.linalg.eig()`: Autovalores e autovetores.
- `np.linalg.svd()`: Decomposição em valores singulares (SVD).

### 7. **Broadcasting**:

- Operações automáticas com arrays de diferentes formas/dimensões que são ajustados automaticamente pelo NumPy.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\01.md
### Última modificação: 2024-12-09 00:25:52


tags: 
data: 2024-12-08

### Dados Duplicados

Ao trabalhar com conjuntos de dados, é comum encontrar **dados duplicados** que podem distorcer as análises. Para identificar e remover duplicatas, utilizamos o comando **`drop_duplicates`**, que elimina linhas repetidas, garantindo que cada registro seja único. Se for necessário checar o número de registros antes e depois da remoção, o comando **`duplicated`** pode ser útil para identificar as duplicatas previamente.
### Importação de Dados

O primeiro passo em qualquer projeto de análise é **importar os dados**. Para isso, utilizamos comandos como **`read_csv`** para arquivos CSV e **`read_excel`** para planilhas do Excel. Esses comandos permitem carregar os dados para o ambiente de trabalho, possibilitando o início das manipulações e análises.
### Organização e Ordenação
Uma vez com os dados carregados, é importante organizá-los. O comando **`sort_values`** é útil para ordenar os dados com base em uma ou mais colunas, enquanto o **`sort_index`** organiza as linhas com base nos índices. Esses comandos tornam mais fácil localizar tendências ou padrões.
### Análise de Dados

Para realizar uma **análise exploratória**, utilizamos comandos como **`describe`**, que fornece um resumo estatístico das colunas numéricas, e **`info`**, que exibe o tipo de dado de cada coluna e se há valores nulos. Se quisermos observar uma amostra aleatória dos dados, o comando **`sample`** pode ser usado para visualizar uma parte do conjunto de forma prática.



### Dados Nulos

Valores nulos podem afetar a análise, sendo necessário identificá-los e tratá-los. Para verificar se há dados nulos, usamos **`isna`** ou **`isnull`**, que retornam um DataFrame indicando onde os valores estão ausentes. Após a identificação, é possível eliminá-los com **`dropna`**, ou preenchê-los com valores específicos utilizando **`fillna`**, garantindo maior consistência no conjunto de dados.



### Agrupamentos e Unicidade

Para **análises agrupadas**, o comando **`groupby`** é extremamente poderoso, permitindo calcular estatísticas específicas (como médias ou somas) baseadas em categorias. Já para explorar valores únicos em colunas específicas, utilizamos **`unique`**, que retorna uma lista dos valores distintos, ou **`nunique`**, que fornece o número de valores únicos.



### Modificação e Renomeação

Muitas vezes, é necessário ajustar o formato ou os nomes das colunas. O comando **`rename`** possibilita renomear colunas de forma simples e eficiente, garantindo clareza e padronização no conjunto de dados.



### Alterações no Local

Sempre que modificamos um DataFrame, podemos decidir se as mudanças serão aplicadas no próprio objeto ou se será criada uma nova cópia. Isso é controlado pelo parâmetro **`inplace=`**, que, se definido como `True`, aplica as alterações diretamente no DataFrame original.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Agrupamento.md
### Última modificação: 2024-11-24 19:36:54

---
tags:
  - Conceito
  - DataAnalyst
data: 2024-11-24
---
Estágios do agrupamento.
[[,groupby]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\DataFrame X Series.md
### Última modificação: 2024-12-10 20:50:36

---
tags:
  - Conceito
data: 2024-12-10
---
[[Series]] é uma unica coluna e alguns codigos servem apenas para DF Series
```python
import pandas as pd

serie = pd.Series(["Pandas", "Python", "Data"])
print(serie.str.upper())  
```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\DataFrame.md
### Última modificação: 2024-11-20 18:02:36

---
tags:
  - Projetos
  - Bibliotecas
data: 2024-08-21
nivel: 
aliases:
  - DataFrame
  - dataframe
---
### Dataframe
Um **DataFrame** é uma estrutura de dados bidimensional fornecida pela biblioteca Pandas no Python, amplamente utilizada para manipulação e análise de dados. Ele pode ser comparado a uma tabela em uma planilha Excel ou em um banco de dados, onde os dados estão organizados em linhas e colunas.

### Características principais:

- **Linhas e colunas**: Um DataFrame contém linhas e colunas, onde cada coluna pode ter um tipo de dado diferente (inteiros, floats, strings, etc.).
- **Indexação**: As linhas e colunas têm rótulos (índices) que podem ser utilizados para acessar, manipular e referenciar os dados. As colunas têm nomes, e as linhas possuem um índice que, por padrão, é numérico.
- **Dados heterogêneos**: Cada coluna de um DataFrame pode armazenar diferentes tipos de dados (números, strings, datas, etc.), mas todos os valores dentro de uma coluna devem ser do mesmo tipo.

### Exemplo de um DataFrame:

```python
import pandas as pd

# Criando um DataFrame a partir de um dicionário
data = {
    'Nome': ['Alice', 'Bob', 'Charlie'],
    'Idade': [25, 30, 35],
    'Cidade': ['SP', 'RJ', 'BH']
}

df = pd.DataFrame(data)

print(df)
```
**Saída**:
```
      Nome  Idade Cidade
0    Alice     25     SP
1      Bob     30     RJ
2  Charlie     35     BH

```
### Estrutura:

- **Colunas**: `Nome`, `Idade`, `Cidade`
- **Linhas**: As linhas numeradas de 0 a 2
- **Dados**: Cada célula contém um dado, como `'Alice'`, `25`, `'SP'`, etc.

### Vantagens:

- Fácil de manipular e analisar dados tabulares.
- Permite operações rápidas, como filtragem, agregação e transformação.
- Suporte robusto para manipulação de dados faltantes.
- Integração com outras bibliotecas de ciência de dados e aprendizado de máquina.

### Aplicações:

- Manipulação de dados em tabelas.
- Análise estatística e resumo de dados.
- Preparação de dados para aprendizado de máquina.
- Visualização e exploração de dados de grandes datasets.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Duplicatas.md
### Última modificação: 2024-11-24 16:38:21

---
tags: 
data: 2024-11-24
---
Para garantir um [[DataFrame|dataframe]] limpo e sem duplicatas, começamos verificando valores ausentes com [[,isna ou isnull|,isna]]() e preenchendo-os com valores apropriados usando [[,fillna]](), depois removemos as linhas ou colunas vazias com [[,dropna]](); em seguida, identificamos as duplicatas com [[,duplicated]]() e as eliminamos usando [[,drop_duplicates]](), reorganizando o índice com [[,reset_index]](); por fim, usamos [[,unique]]() para listar os valores distintos em uma coluna específica e [[,nunique]]() para contar quantos valores únicos existem, confirmando a limpeza dos dados.


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Filtragem condicional.md
### Última modificação: 2024-11-22 22:34:54

---
tags: 
data: 2024-11-22
---
É o uso de uma [[Máscara booleana]] para mostrar as linhas `True`.


```python
          artist     genre  plays
0  Taylor Swift      pop   1500
1         Drake  hip hop   1200
2         Adele      pop   2000
3       Beyoncé      R&B   1800
```
```python
pop_music = df[df['genre'] == 'pop'] 
print(pop_music)
```
```python
          artist genre  plays
0  Taylor Swift   pop   1500
2         Adele   pop   2000
```


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Indexação Booleana.md
### Última modificação: 2024-11-22 22:34:06

---
tags:
  - Pandas
  - Python
  - Conceito
data: 2024-11-18
---
A ideia principal é criar uma [[Máscara booleana]], que é uma Series ou [[DataFrame]] contendo _True_ para os elementos que atendem a uma condição e _False_ para os demais. Essa máscara é usada como índice para acessar os elementos desejados.
```python
import pandas as pd

data = {
    'nome': ['Ana', 'Bruno', 'Carlos', 'Daniela'],
    'idade': [22, 35, 18, 29],
    'cidade': ['São Paulo', 'Rio de Janeiro', 'São Paulo', 'Curitiba']
}

df = pd.DataFrame(data)
print(df)
```
```
     nome  idade          cidade
0     Ana     22     São Paulo
1   Bruno     35  Rio de Janeiro
2  Carlos     18     São Paulo
3 Daniela     29       Curitiba

```


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Máscara booleana.md
### Última modificação: 2024-11-22 23:43:54

---
tags:
  - Conceito
data: 2024-11-22
---
```python
condicao = df['idade'] > 20
print(condicao)
```
```python
0     True
1     True
2    False
3     True
Name: idade, dtype: bool
```
```python
df_filtrado = df[condicao] print(df_filtrado)
```
```python
     nome  idade          cidade
0     Ana     22     São Paulo
1   Bruno     35  Rio de Janeiro
3 Daniela     29       Curitiba
```

# que utilizam o conceito.
### Operações Lógicas
Comparações:
` ==`  : Igualdade.
`!=`: Diferença.
`<`: Menor que.
`<=`: Menor ou igual a.
`>`: Maior que.
`>=`: Maior ou igual a.
Combinações Lógicas:
`&`: E lógico.
`|`: Ou lógico.
`~`: Negação lógica.
### Métodos de Filtragem
Esses métodos criam máscaras booleanas ao verificar condições em colunas ou linhas:

1. [[,duplicated]](): Verifica se uma linha é duplicada.
2. [[,isna ou isnull]](): Identifica valores nulos (NaN).
3. [[,notna]]() ou [[,notnull]](): Identifica valores não nulos.
4. [[,between]](lower, upper): Verifica se valores estão dentro de um intervalo.
5. str.[[,contains]]('pattern'): Verifica se strings contêm um padrão específico.
6. str.[[,startswith]]('prefix'): Verifica se strings começam com um prefixo.
7. str.[[,endswith]]('suffix'): Verifica se strings terminam com um sufixo.
8. str.[[,match]]('regex'): Verifica se strings correspondem a uma expressão regular.
9. [[,isin]](values): Verifica se valores estão em uma lista.
10. [[,eval]]('expression'): Avalia uma expressão booleana.
11. [[,query]]('expression'): Filtra linhas com base em uma expressão.
###  Métodos Estatísticos

Estes métodos comparam valores com estatísticas do DataFrame:

1. [[,idxmax]]() e [[,idxmin]](): Índice do valor máximo ou mínimo (pode ser usado para criar máscaras).
2. [[,rank]](): Cria rankings, útil para filtros condicionais.
3. [[,quantile]](): Cria máscaras baseadas em percentis.
### Métodos Específicos para Séries Numéricas
abs() > x: Verifica valores absolutos maiores que x.
round(decimals) == x: Arredonda e compara valores.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\NaN nulo.md
### Última modificação: 2024-12-21 19:34:06

---
tags: 
data: 2024-12-21
---
O NaN é oque indica valor nulo no pandas porém é do tipo float.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Ordenar.md
### Última modificação: 2024-11-24 19:39:43

---
tags:
  - Conceito
  - DataAnalyst
data: 2024-11-24
---
Ordenar os dados na análise é fundamental para identificar padrões, facilitar comparações e garantir que as informações relevantes sejam apresentadas de forma clara e lógica, otimizando a interpretação dos resultados.
E utilizando o [[,sort_values]], pode se ordenar em crescente e descrecente.


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Pré-processamento de dados.md
### Última modificação: 2024-11-24 16:34:46

---
tags:
  - Conceito
data: 2024-11-20
---
Pré-processamento de dados no Pandas é o processo de transformar e preparar dados brutos em um formato limpo, consistente e estruturado, envolvendo etapas como tratamento de valores nulos, remoção de duplicatas, conversão de tipos de dados, normalização, e criação de novas colunas, para facilitar análises e modelagens.

#### Valores nulos
![[Valores ausentes]] 
#### Remoção de duplicatas
![[Duplicatas]] 
#### Conversão de tipos de dados
#### Normalização
![[Normalizar nomes de colunas]]
#### Criação de novas colunas





### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Split Apply Combine.md
### Última modificação: 2024-12-28 19:53:45

---
tags:
  - Conceito
data: 2024-12-28
---
Separar, aplicar uma função e combinar os resultados. 
![[Pasted image 20241228195332.png|500]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\types.md
### Última modificação: 2024-11-14 22:24:11

---
tags:
  - Comando
data: 2024-11-14
---
- int64 (Inteiros)
Exemplo: 0, 150, -300
- float64 (Flutuantes)
Exemplo: 3.1415, -20.0, 100.5
- object (Texto ou String)
Exemplo: "Hello", "Data Science", "1234"
- bool (Booleano)
Exemplo: True, False
- datetime64 (Datas e Horas)
Exemplo: 2023-01-01, 2024-10-05 15:30:00
- timedelta[ns] (Diferença de Tempo)
Exemplo: 5 days, 2 hours, 30 minutes
- category (Categorias)
Exemplo: `["Masculino", "Feminino"], ["Pequeno", "Médio", "Grande"]`


### relação do types pandas x python

|                       | Python type | Pandas type |
| --------------------- | ----------- | ----------- |
| string                | [[str]]     | object      |
| integer               | [[int]]     | int64       |
| floating-point number | [[float]]   | float64     |
| logical data type     | [[bool]]    | bool        |


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Valores ausentes.md
### Última modificação: 2024-12-06 17:06:19

---
tags:
  - Conceito
  - DataAnalyst
data: 2024-11-20
---
O processamento de valores ausentes no Pandas envolve identificar ([[,isna ou isnull]]), preencher ([[,fillna]]) ou remover ([[,dropna]]) os valores nulos em um DataFrame ou Series, garantindo que análises e operações sejam realizadas sem erros ou vieses causados por dados incompletos.


- Chamando `info()` em um DataFrame
- Chamando `isna().sum()` em um DataFrame ou objeto Series
- Chamando `value_counts(dropna=False)` em um objeto Series

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Window functions.md
### Última modificação: 2024-12-26 21:17:01



### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,agg.md
### Última modificação: 2024-12-28 20:37:09

---
tags:
  - Conceito
data: 2024-12-28
---
é um [[,apply]] com varias funções. 

```python
agg_dict = {'critic_score': 'mean', 'jp_sales': 'sum'} 
grp = df.groupby(['platform', 'genre']) 
print(grp.agg(agg_dict))
```

| Platform | Genre         | Critic Score | JP Sales |
|----------|---------------|--------------|----------|
| 3DS      | Action        | 63.73        | 6.60     |
| 3DS      | Adventure     | 68.33        | 0.66     |
| 3DS      | Fighting      | 68.86        | 0.46     |
| 3DS      | Misc          | 69.10        | 1.22     |
| 3DS      | Platform      | 72.44        | 5.94     |
| ...      | ...           | ...          | ...      |
| XOne     | Role-Playing  | 80.78        | 0.01     |
| XOne     | Shooter       | 77.90        | 0.13     |
| XOne     | Simulation    | 53.00        | 0.00     |
| XOne     | Sports        | 71.94        | 0.02     |
| XOne     | Strategy      | 70.00        | 0.00     |




### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,apply.md
### Última modificação: 2024-12-28 16:07:52

---
tags:
  - Comando
data: 2024-12-27
---
Faz uma função percorrer todo  uma [[Series]] ou [[DataFrame]], porém cuidado quando for df, verifique as células
O parâmetro [[axis=]] no método `.apply()` do Pandas indica como a função será aplicada:
- **`axis=0`** (ou seja, ao longo das colunas): A função será aplicada em cada **coluna** do DataFrame.
- **`axis=1`** (ou seja, ao longo das linhas): A função será aplicada em cada **linha** do DataFrame.
```python
import pandas as pd

# Criando o DataFrame
df = pd.DataFrame({
    'nome': ['João', 'Maria', 'Pedro', 'Ana'],
    'idade': [25, 12, 35, 8]
})

# Função para classificar idades
def classificar_idade(idade):
    return 'adulto' if idade >= 18 else 'criança'

# Usando apply para criar uma nova coluna
df['categoria'] = df['idade'].apply(classificar_idade)

print(df)
```
```
    nome  idade categoria
0   João     25   adulto
1  Maria     12  criança
2  Pedro     35   adulto
3    Ana      8  criança

```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,astype.md
### Última modificação: 2024-12-22 00:10:04

---
tags:
  - Comando
data: 2024-12-21
---
O método `.astype` é usado para converter os dados de uma coluna ou array para um tipo específico, como inteiro, float, string, etc.

```python
import pandas as pd

data = {'coluna': [1.1, 2.2, 3.3]}
df = pd.DataFrame(data)

# Convertendo a coluna para o tipo inteiro
df['coluna'] = df['coluna'].astype(int)

print(df)
```
```python
   coluna
0       1
1       2
2       3
```
```python

```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,columns.md
### Última modificação: 2024-12-28 22:59:59

---
tags:
  - Comando
data: 2024-12-28
---
Recebe uma lista que renomeia todas as colunas com os itens da lista.
```python
df.columns = ['avg_critic_score', 'total_sales']
```

| Publisher       | Avg Critic Score | Total Sales |
| --------------- | ---------------- | ----------- |
| 10TACLE Studios | 42.000000        | 0.11        |
| 1C Company      | 73.000000        | 0.08        |
| mixi, Inc       | NaN              | 0.87        |
| responDESIGN    | NaN              | 0.13        |


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,concat.md
### Última modificação: 2024-12-28 23:23:37

---
tags: 
data: 2024-12-28
---
O método **`concat`** combina objetos do Pandas (como DataFrames ou Series) ao longo de um eixo (linhas ou colunas), permitindo unir dados de forma flexível.
[[axis=]]
```python
import pandas as pd

df1 = pd.DataFrame({'A': [1, 2], 'B': [3, 4]})
df2 = pd.DataFrame({'A': [5, 6], 'B': [7, 8]})

# Concatenar por linhas (padrão)
result = pd.concat([df1, df2])

print(result)
```

```python
   A  B
0  1  3
1  2  4
0  5  7
1  6  8
```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,corr.md
### Última modificação: 2024-12-18 20:05:39

---
tags:
  - Comando
data: 2024-12-18
---
Calcula o coeficiente de correlação
```python
ah_corr = df['height'].corr(df['age'])
```
```python
0.010042046516844344
```
## Matriz de correlação
```python
print(df.corr())
```
```python
          height    weight       age      male
height  1.000000  0.916526  0.010042  0.760690
weight  0.916526  1.000000  0.228538  0.785218
age     0.010042  0.228538  1.000000  0.004750
male    0.760690  0.785218  0.004750  1.000000
```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,describe.md
### Última modificação: 2024-12-05 19:16:43

---
tags: 
data: 2024-12-05
---
```python
data.describe()
```
![[Pasted image 20241205191001.png|300]]
Se chamar o describe em uma serie com dados não numericos:
- `'count'`: O número de valores não nulos
- `'unique'`: O número de valores unívocos
- `'top'`: O valor que ocorre com mais frequência
- `'freq'`: O número de vezes que o valor mais frequente ocorre

# include=
Para incluir tambem as colunas não numéricas no discribe completo.
`all`(para pegar todas as colunas) `object`(para incluir object)


[[Importância do grafico]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,drop.md
### Última modificação: 2024-12-29 19:47:45

---
tags: 
data: 2024-12-29
---
Em Python, o método `.drop()` é usado principalmente com **pandas** para remover linhas ou colunas de um DataFrame. Ele é útil quando você deseja eliminar dados irrelevantes ou indesejados. Para remover linhas, você usa o argumento `index`, e para colunas, o argumento `columns`. Além disso, você pode definir `inplace=True` para alterar o DataFrame original diretamente (caso contrário, ele retorna uma nova versão modificada).

```python
import pandas as pd

# Criando um DataFrame
data = {'Nome': ['Ana', 'João', 'Maria'], 'Idade': [25, 30, 22], 'Cidade': ['SP', 'RJ', 'BH']}
df = pd.DataFrame(data)

# Removendo a coluna "Cidade"
df_sem_cidade = df.drop(columns='Cidade')

print(df_sem_cidade)
```

```python
    Nome  Idade
0    Ana     25
1   João     30
2  Maria     22

```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,dropna.md
### Última modificação: 2024-11-22 00:49:17

---
tags:
  - Comando
data: 2024-11-21
---
Remove linhas ou coluna([[axis=]]) com valores ausentes. caso queria apenas remover linhas com valores ausentes de colunas especificas basta [[Lista|listar]] no [[Parâmetro|parâmetro]] [[subset=]]. Caso queria faze uma atribuição pode usar o parâmetro [[inplace=]].

|A|B|C|
|---|---|---|
|1.0|NaN|0|
|2.0|5.0|1|
|0.0|6.0|2|
|NaN|7.0|3|
```python
df_cleaned = df.dropna(subset=['A', 'B'])
print(df_cleaned)
```
|A|B|C|
|---|---|---|
|2.0|5.0|1|
|0.0|6.0|2|



### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,drop_duplicates.md
### Última modificação: 2024-11-25 17:24:09

---
tags:
  - Comando
  - DataAnalyst
data: 2024-11-24
---
O comando `drop_duplicates()` remove linhas duplicadas de um DataFrame, mantendo apenas a primeira ocorrência por padrão.
```python
| Nome  | Idade |
|-------|-------|
| Ana   | 25    |
| Bruno | 30    |
| Ana   | 25    |
| Carla | 28    |
```
```python
df.drop_duplicates(inplace=True)
```
```python
| Nome  | Idade |
|-------|-------|
| Ana   | 25    |
| Bruno | 30    |
| Carla | 28    |
```
![[Pasted image 20241125172408.png]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,dt.md
### Última modificação: 2024-12-27 18:37:26

---
tags:
  - Comando
data: 2024-12-27
---
**`.dt`**: Permite acessar propriedades como `.day` (dia) e `.hour` (hora) de cada elemento da série

O atributo `.dt` em pandas é usado para acessar elementos específicos de dados temporais em colunas de um DataFrame ou Series, como ano, mês, dia, hora, entre outros. Ele é útil quando lidamos com colunas que contêm objetos `datetime` ou dados que foram convertidos para o tipo `datetime64`. Já os métodos [[,tz_convert() e ,tz_localize()]] são utilizados para trabalhar com fuso horário: o primeiro atribui um fuso horário a um objeto de data e hora que ainda não possui um, enquanto o segundo converte um objeto com um fuso horário definido para outro.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,dtypes.md
### Última modificação: 2024-12-22 00:09:57

---
tags:
  - Comando
data: 2024-12-21
---
```python
import pandas as pd

data = {'nome': ['João', 'Maria', 'José'], 'idade': [25, 30, 35]}
df = pd.DataFrame(data)

print(df.dtypes)
```
```python
nome     object
idade     int64
dtype: object
```
Aqui, a coluna `'nome'` tem tipo `object` (string) e a coluna `'idade'` tem tipo `int64` (inteiro).

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,duplicated.md
### Última modificação: 2024-12-06 17:09:20

---
tags:
  - Comando
data: 2024-11-22
---
```python
     Nome  Idade          Cidade
0     Ana     25      São Paulo
1   Bruno     30  Rio de Janeiro
2  Carlos     22  Belo Horizonte
3     Ana     25      São Paulo
```
```Python
df.duplicated()
```
```python
0    False
1    False
2    False
3     True
dtype: bool
```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,fillna.md
### Última modificação: 2024-12-14 20:08:53

---
tags:
  - Comando
data: 2024-11-20
---
O método `fillna` substitui valores ausentes (`NaN`) em um DataFrame ou Series por um valor especificado.
Caso queria faze uma atribuição pode usar o parâmetro [[inplace=]].

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,groupby.md
### Última modificação: 2024-11-24 17:11:40

---
tags:
  - Comando
  - DataAnalyst
data: 2024-11-24
---
`groupby` é um comando que agrupa uma tabela mediante aos [[,unique]] de uma coluna especificada. Ele cria um [[DataFrameGroupby]] e é possível visualizar-lo pelo método [[,groups]].

|Categoria|Valor|
|---|---|
|A|10|
|A|15|
|B|10|
|B|20|
|C|25|
```python
grupo = df.groupby("Categoria")
print(grupo.groups)
```
```Python
{'A': [0, 1], 'B': [2, 3], 'C': [4]}
```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,head.md
### Última modificação: 2024-11-22 20:07:01

---
tags:
  - Comando
data: 2024-11-22
---
[[Método]] que vê os primeiros 5 linhas por padrão. 

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,iloc.md
### Última modificação: 2024-12-13 20:23:39

---
tags:
  - Comando
data: 2024-12-13
---
| Comando                     | Descrição                                                       | Exemplo              |
| --------------------------- | --------------------------------------------------------------- | -------------------- |
| `df.iloc[i]`                | Acessa uma linha específica.                                    | `df.iloc[1]`         |
| `df.iloc[i, j]`             | Acessa um valor específico (linha e coluna).                    | `df.iloc[1, 2]`      |
| `df.iloc[start:stop, :]`    | Acessa várias linhas (todas as colunas).                        | `df.iloc[0:2, :]`    |
| `df.iloc[:, start:stop]`    | Acessa todas as linhas para um intervalo de colunas.            | `df.iloc[:, 1:3]`    |
| `df.iloc[start:stop, j]`    | Acessa várias linhas de uma coluna específica.                  | `df.iloc[0:2, 2]`    |
| `df.iloc[[i, k], :]`        | Acessa linhas específicas (todas as colunas).                   | `df.iloc[[0, 2], :]` |
| `df.iloc[:, [i, j]]`        | Acessa colunas específicas (todas as linhas).                   | `df.iloc[:, [0, 2]]` |
| `df.iloc[start:stop, step]` | Acessa linhas ou colunas com um passo (step).                   | `df.iloc[0:3:2, :]`  |
| `df.iloc[[-1], :]`          | Acessa a última linha (índice negativo).                        | `df.iloc[[-1], :]`   |
| `df.iloc[:, -1]`            | Acessa a última coluna (índice negativo).                       | `df.iloc[:, -1]`     |
| `df.iloc[start:stop, -j:]`  | Acessa as últimas colunas em um intervalo para todas as linhas. | `df.iloc[:, -2:]`    |
| `df.iloc[:, :]`             | Acessa o DataFrame completo (todas as linhas e colunas).        | `df.iloc[:, :]`      |


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,index.md
### Última modificação: 2024-12-22 00:02:34

---
tags:
  - Comando
data: 2024-12-12
---
```python
oceans = pd.Series(['Pacific', 'Atlantic', 'Indian', 'Southern', 'Arctic']) 
# oceans = pd.Series(['Pacific', 'Atlantic', 'Indian', 'Southern', 'Arctic'], index=['A', 'B', 'C', 'D', 'E'])
print(oceans.index)
```

```python
RangeIndex(start=0, stop=5, step=1)
```

# também pega o indice


   name   rating
0  John     6.5
1  Alice    5.0
2  Bob      7.2

```python
   name   rating
0  John     6.5
1  Alice    5.0
2  Bob      7.2

```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,info.md
### Última modificação: 2024-11-21 23:41:46

---
tags:
  - Comando
  - Python
data: 2024-11-14
---
O [[Método]] `info()` do Pandas exibe um resumo conciso de um DataFrame, mostrando informações sobre o índice, o número total de entradas, os nomes das colunas, os tipos de dados de cada coluna, o número de valores não nulos em cada coluna e a memória total usada pelo DataFrame.
Caso queria faze uma atribuição pode usar o parâmetro [[inplace=]].
![[Pasted image 20241114222841.png]]

'Bob Dylan' , 'Like A Rolling Stone'
'John Lennon' , 'Imagine'
'The Beatles' , 'Hey Jude'
'Nirvana' , 'Smells Like Teen Spirit'

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,isin.md
### Última modificação: 2024-12-13 23:13:58

---
tags: 
data: 2024-12-13
---
O método **`isin`** verifica se os valores de uma coluna ou DataFrame estão presentes em uma lista de valores especificados e retorna **True** ou **False** para cada elemento.
```python
df = pd.DataFrame({ "Nome": ["Ana", "João", "Maria", "Pedro"], "Idade": [25, 30, 22, 28] })
```
```python
df["Nome"].isin(["Ana", "Pedro"])
```
```python
0     True
1    False
2    False
3     True
Name: Nome, dtype: bool
```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,isna ou isnull.md
### Última modificação: 2024-11-21 23:41:46

---
tags:
  - Comando
data: 2024-11-20
---
Sinaliza com `True` ou `Falce` se algo é `null` ou `none`.
Caso queria faze uma atribuição pode usar o parâmetro [[inplace=]].
```python
df = pd.DataFrame({
    'Nome': ['Ana', 'Bruno', 'Carlos', None],
    'Idade': [22, 35, None, 18],
    'Cidade': ['São Paulo', None, 'Rio de Janeiro', 'Salvador']
})

# Identificar valores ausentes com isna() ou isnull
print(df.isna())
```
```python
    Nome  Idade  Cidade
0  False  False   False
1  False  False    True
2  False   True   False
3   True  False   False

```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,loc.md
### Última modificação: 2024-11-18 00:24:05

---
tags:
  - Comando
data: 2024-11-14
---
`loc` é um [[Atributo]] do pandas que permite selecionar dados de um [[DataFrame]] usando rótulos de índice e nomes de colunas.


| Tipo                                               | Amostra                        | Resultado esperado                                                                                                              |
| -------------------------------------------------- | ------------------------------ | ------------------------------------------------------------------------------------------------------------------------------- |
| Uma célula                                         | `.loc[7, 'genre']`             | Extrai o valor da célula localizada na coluna `'genre'` e na 8ª linha (que possui o índice `7`).                                |
| Uma coluna                                         | `.loc[:, 'genre']`             | Extrai os valores de todas as células na coluna `'genre'`.                                                                      |
| Múltiplas colunas                                  | `.loc[:, ['Artist', 'genre']]` | Extrai todos os valores de todas as células nas colunas `'Artist'` e `'genre'`.                                                 |
| Múltiplas colunas consecutivas (fatia)             | `.loc[:, 'user_id':'genre']`   | Extrai todos os valores de todas as células nas colunas começando com a coluna `'user_id'` e terminando com a coluna `'genre'`. |
| Uma linha                                          | `.loc[1]`                      | Extrai os valores da 2ª linha (com índice `1`).                                                                                 |
| Todas as linhas, começando pela linha especificada | `.loc[1:]`                     | Extrai todos os valores da segunda linha e vai até a última linha.                                                              |
| Todas as linhas, até a linha especificada          | `.loc[:3]`                     | Extrai todos os valores das quatro primeiras linhas (da linha com índice `0` até a linha com índice `3`).                       |
| Múltiplas linhas consecutivas (fatia)              | `.loc[2:5]`                    | Extrai todos os valores de célula entre a terceira e quinta linhas.                                                             |

| Tipo                                     | Amostra                          | Notação abreviada                  |
|------------------------------------------|-----------------------------------|-------------------------------------|
| Uma célula                               | `.loc[7, 'genre']`               | -                                   |
| Uma coluna                               | `.loc[:, 'genre']`               | `df['genre']`                      |
| Várias colunas                           | `.loc[:, ['genre', 'Artist']]`   | `df[['genre', 'Artist']]`          |
| Várias colunas consecutivas (fatia)      | `.loc[:, 'total play':'genre']`  | -                                   |
| Uma linha                                | `.loc[1]`                        | -                                   |
| Todas as linhas, começando pela linha determinada | `.loc[1:]`                  | `df[1:]`                           |
| Todas as linhas, até a linha especificada | `.loc[:3] incluindo 3`           | `df[:3] não incluindo 3`           |
| Múltiplas linhas consecutivas (fatia)    | `.loc[2:5] incluindo 5`          | `df[2:5] não incluindo 5`          |


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,merge.md
### Última modificação: 2024-12-29 00:16:58

---
tags:
  - Comando
data: 2024-12-28
Link: https://www.youtube.com/watch?v=h4hOPGo4UVU
---
# how=

| Merge Method | SQL Join Name      | Descrição                                     |
|--------------|--------------------|-----------------------------------------------|
| left         | LEFT OUTER JOIN    | Usa as chaves apenas do DataFrame da esquerda |
| right        | RIGHT OUTER JOIN   | Usa as chaves apenas do DataFrame da direita  |
| outer        | FULL OUTER JOIN    | Usa a união das chaves de ambos os DataFrames |
| inner        | INNER JOIN         | Usa a interseção das chaves de ambos os DataFrames |
| cross        | CROSS JOIN         | Cria o produto cartesiano das linhas de ambos os DataFrames |
# on=
# indicator=
# suffixes=


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,nan.md
### Última modificação: 2024-12-27 21:09:19



### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,nunique.md
### Última modificação: 2024-11-23 00:23:30

---
tags:
  - Comando
data: 2024-11-23
---
O método **`nunique()`** no Pandas retorna o número de valores únicos em uma **coluna** ou no **[[DataFrame]]**, ignorando valores nulos por padrão.

```python
valores_unicos_df = df.nunique()
```
```python
Nome       4
Idade      4
Cidade     3
dtype: int64
```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,pivot_table.md
### Última modificação: 2024-12-28 20:46:23

---
tags:
  - Conceito
data: 2024-12-28
---
O método `.pivot_table` no Pandas é usado para criar uma tabela dinâmica a partir de um DataFrame, permitindo reorganizar e resumir dados de forma eficiente. Ele é muito útil para agregar valores (como somar ou calcular médias) e estruturar os dados com base em índices e colunas personalizadas. Comumente, você especifica os índices (`index`), as colunas (`columns`), os valores (`values`) e a função de agregação (`aggfunc`), como `sum`, `mean`, etc.
# sintaxe
```python
df.pivot_table(values='Vendas', index='Categoria', columns='Região', aggfunc='sum', fill_value=0)
```
# exemplo
```python
data = {
    'Departamento': ['Vendas', 'Vendas', 'RH', 'RH', 'TI', 'TI'],
    'Funcionário': ['Ana', 'João', 'Maria', 'Carlos', 'Paulo', 'Juliana'],
    'Salário': [3000, 4000, 3500, 3200, 4500, 4700]
}
df = pd.DataFrame(data)

tabela_pivot = df.pivot_table(values='Salário', index='Departamento', aggfunc='mean')

print(tabela_pivot)
```
```python
               Salário
Departamento          
RH              3350.0
TI              4600.0
Vendas          3500.0
```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,query.md
### Última modificação: 2024-12-13 23:19:36

---
tags: 
data: 2024-12-13
---
```python
df_filtered = df.query("publisher == developer")['name', 'publisher', 'developer']
```
O código cria um novo DataFrame (**`df_filtered`**) contendo os nomes dos jogos (**`name`**) e informações do **publicador** (**`publisher`**) e do **desenvolvedor** (**`developer`**) **somente quando o publicador for o mesmo que o desenvolvedor**.

```python
df_filtered = df.query("genre not in @s_genres")[cols]
```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,read_csv.md
### Última modificação: 2024-12-05 23:04:53

---
tags:
  - Comando
data: 2024-11-29
---
Basicamente lê um arquivo [[CSV]], [[TSV]], [[TAB]]

df = pd.read_csv(
    `'dados.csv'`,
    `sep=';', ` # Separador
	`names=['id_user', 'nome', 'data'] `# da nome a colunas(q n tem nome)
    `decimal=","` # No caso de numeros decimais separados com virgula. 
    `header=0`,  # Primeira linha como cabeçalho
    `usecols=['Nome', 'Idade'], ` # Apenas essas colunas
    `dtype={'Idade': 'int32'}, ` # Define o tipo de dados
    `na_values=['N/A', 'nulo'],`  # Valores considerados como ausentes
    `parse_dates=['Data']`,  # Converte a coluna Data
    `dayfirst=True`,  # Interpreta o formato dia/mês/ano
    `encoding='utf-8',`  # Codificação
    `keep_default_na=` # se falce ele iria deixar valores nulos em branco.
)
### header
aceita lista
`header='infe'` que tenta achar o nome das colunas, se não achar as ordena(0,1,2...)

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,read_excel.md
### Última modificação: 2024-11-29 20:54:40

---
tags:
  - Comando
data: 2024-11-29
---
parecido com o [[,read_csv]], porém tem:
`sheet_name="client_info"`, que diz qual das abas de planilhas pegar.
`sheet_name=0` mostra a primeira planilha, `sheet_name=1` a segunda, e assim por diante.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,rename.md
### Última modificação: 2024-11-25 16:06:21

---
tags:
  - Comando
data: 2024-11-25
---
O método `rename` do pandas permite renomear colunas ou índices de um [[DataFrame]], especificando os novos nomes como um dicionário no parâmetro `columns` ou `index`.

|Nome|Idade|Cidade|
|---|---|---|
|Alice|25|São Paulo|
|Bob|30|Rio de Janeiro|
```python
df = df.rename(columns={"Nome": "Nome Completo", "Idade": "Anos", "Cidade": "Localidade"})
```

|Nome Completo|Anos|Localidade|
|---|---|---|
|Alice|25|São Paulo|
|Bob|30|Rio de Janeiro|

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,reset_index.md
### Última modificação: 2024-11-24 16:44:48

---
tags:
  - Comando
  - DataAnalyst
data: 2024-11-24
---
O comando `reset_index()` é usado para redefinir o índice de um DataFrame, geralmente convertendo o índice atual em uma coluna e criando um novo índice numérico padrão.

|índice|Nome|Idade|
|---|---|---|
|a|Ana|25|
|b|João|30|
|c|Maria|22|
```python
df_res = df.reset_index()
```
||index|Nome|Idade|
|---|---|---|---|
|0|a|Ana|25|
|1|b|João|30|
|2|c|Maria|22|


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,sample.md
### Última modificação: 2024-11-30 00:48:46

---
tags:
  - Comando
data: 2024-11-30
---
Diz linhas aleatorias do [[DataFrame]].
```python
df.sample(5)
```
`random_state=` e configurá-lo para algum valor inteiro de sua escolha (qualquer número inteiro entre 0 e 4294967295)

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,Series.md
### Última modificação: 2024-12-12 23:55:40

---
tags:
  - Comando
data: 2024-12-12
---
```python
oceans = pd.Series(['Pacific', 'Atlantic', 'Indian', 'Southern', 'Arctic']) print(oceans)
```
```python
0 Pacific 
1 Atlantic 
2 Indian 
3 Southern 
4 Arctic 
dtype: object
```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,set_index.md
### Última modificação: 2024-12-13 21:19:14

---
tags:
  - Comando
data: 2024-12-13
---


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,shape.md
### Última modificação: 2024-11-14 23:56:09

---
tags:
  - Comando
  - Python
data: 2024-11-14
---

```python
df.shape
# (2342, 5) 
#linhas  colunas
```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,sort_index.md
### Última modificação: 2024-12-05 19:56:37

---
tags:
  - Comando
data: 2024-12-05
---
Ele organiza os dados com base nos **índices**, e não nos valores das colunas.

```python
     Nome  Idade
2     Ana     25
0  Carlos     30
1  Beatriz    22
```
```python
df.sort_index()
```
```python
     Nome  Idade
0  Carlos     30
1  Beatriz    22
2     Ana     25
```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,sort_values.md
### Última modificação: 2024-11-24 17:59:21

---
tags:
  - Conceito
data: 2024-11-24
---
O comando `sort_values()` é utilizado para ordenar os dados de um [[DataFrame]] de acordo com os valores de uma ou mais colunas.
# sintaxi
```python
df.sort_values(by='Valor', ascending=False, inplace=True)
```
# exemplo

|Vendedor|Produto|Valor|
|---|---|---|
|Ana|Produto A|200|
|João|Produto B|150|
|Maria|Produto C|300|
```python
df_sorted = df.sort_values(by='Valor')
```
|Vendedor|Produto|Valor|
|---|---|---|
|João|Produto B|150|
|Ana|Produto A|200|
|Maria|Produto C|300|

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,tail.md
### Última modificação: 2024-11-29 21:53:03

---
tags: 
data: 2024-11-29
---
Imprime as ultimas 5 linhas. mas pode almentar o diminuir esse numero.

```python
df.tail(12) # mostra as ultimas 12 linhas.
```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,to_datetime.md
### Última modificação: 2024-12-27 16:46:02

---
tags:
  - Comando
data: 2024-12-26
Link: https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior
---
2019-02-04T13:22:34
```python
position['timestamp'] = pd.to_datetime(position['timestamp'], format='%Y-%m-%dT%H:%M:%S')
```
```
timestamp  level   page_id
0 2019-02-04 13:22:34      1  6ukoNykP
1 2019-02-06 15:30:54      1  Q62R1Ue7
2 2019-02-08 14:53:45      1  GmfSxgPs
3 2019-02-10 16:50:22      2  M56OK96C
4 2019-02-12 14:16:28      1  q2fqVqPc
```

| Formato | Descrição                                           | Exemplo de Valor           | Exemplo de Formatação        |
| ------- | --------------------------------------------------- | -------------------------- | ---------------------------- |
| `%Y`    | Ano com 4 dígitos                                   | `2024`                     | `"2024"`                     |
| `%y`    | Ano com 2 dígitos                                   | `24`                       | `"24"`                       |
| `%m`    | Mês com 2 dígitos                                   | `01` (Janeiro)             | `"01"`                       |
| `%d`    | Dia do mês com 2 dígitos                            | `05`                       | `"05"`                       |
| `%H`    | Hora (formato 24h) com 2 dígitos                    | `14`                       | `"14"`                       |
| `%I`    | Hora (formato 12h) com 2 dígitos                    | `02`                       | `"02"`                       |
| `%p`    | AM ou PM                                            | `AM` ou `PM`               | `"AM"`                       |
| `%M`    | Minuto com 2 dígitos                                | `45`                       | `"45"`                       |
| `%S`    | Segundo com 2 dígitos                               | `30`                       | `"30"`                       |
| `%f`    | Microsegundos com 6 dígitos                         | `123456`                   | `"123456"`                   |
| `%z`    | Deslocamento de fuso horário                        | `+0100` ou `-0300`         | `"+0100"`                    |
| `%Z`    | Nome do fuso horário                                | `UTC` ou `EST`             | `"UTC"`                      |
| `%j`    | Dia do ano (de 001 a 366)                           | `034`                      | `"034"`                      |
| `%U`    | Semana do ano (domingo como primeiro dia da semana) | `07`                       | `"07"`                       |
| `%W`    | Semana do ano (segunda-feira como primeiro dia)     | `06`                       | `"06"`                       |
| `%c`    | Representação local de data e hora                  | `Thu Dec 26 14:30:00 2024` | `"Thu Dec 26 14:30:00 2024"` |
| `%x`    | Representação local da data                         | `12/26/24` (nos EUA)       | `"12/26/24"`                 |
| `%X`    | Representação local da hora                         | `14:30:00`                 | `"14:30:00"`                 |
| `%%`    | Caractere literal `%`                               | `%`                        | `"%"`                        |


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,to_numeric.md
### Última modificação: 2024-12-22 00:10:00

---
tags:
  - Comando
data: 2024-12-21
---
A função `to_numeric` do pandas converte dados para o tipo numérico (int ou float), tratando strings que representam números e substituindo valores inválidos por NaN, se configurado

```python
import pandas as pd

data = pd.Series(['10', '20', 'abc', '30'])
numeric_data = pd.to_numeric(data, errors='coerce')
print(numeric_data)
```
```python
0    10.0
1    20.0
2     NaN
3    30.0
dtype: float64
```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,tz_convert() e ,tz_localize().md
### Última modificação: 2024-12-27 18:07:21

---
tags:
  - Comando
data: 2024-12-27
---
O método `.tz_convert()` é usado em séries ou DataFrames com um índice datetime que já possui informações de fuso horário (timezone-aware) para converter os dados de um fuso horário para outro. 
O `.tz_localize()` é utilizado para definir um fuso horário em dados que inicialmente estão "ingênuos" (sem informação de fuso horário).

| Índice  | InvoiceDate                |
|---------|----------------------------|
| 33553   | 2010-12-17 12:38:00+00:00 |
| 9427    | 2010-12-06 09:58:00+00:00 |
| 199     | 2010-12-01 13:21:00+00:00 |
| 12447   | 2010-12-06 16:57:00+00:00 |
| 39489   | 2010-12-21 15:19:00+00:00 |
Name: InvoiceDate, dtype: datetime64[ns, UTC]
```python
import pandas as pd 
df = pd.read_csv('OnlineRetail.csv') 
df['InvoiceDate'] = pd.to_datetime(df['InvoiceDate'], format='%Y-%m-%dT%H:%M:%SZ') 
df['InvoiceDate'] = df['InvoiceDate'].dt.tz_localize('UTC') 
df['InvoiceDate_NYC'] = df['InvoiceDate'].dt.tz_convert('America/New_York')
print(df['InvoiceDate_NYC'].sample(5, random_state=42))
```

| Índice  | Data e Hora               |
|---------|---------------------------|
| 33553   | 2010-12-17 07:38:00-05:00 |
| 9427    | 2010-12-06 04:58:00-05:00 |
| 199     | 2010-12-01 08:21:00-05:00 |
| 12447   | 2010-12-06 11:57:00-05:00 |
| 39489   | 2010-12-21 10:19:00-05:00 |

Name: InvoiceDate_NYC, dtype: datetime64[ns, America/New_York]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,unique.md
### Última modificação: 2024-12-13 23:09:24

---
tags:
  - Comando
data: 2024-11-23
---
O [[Método]] **`unique()`** no Pandas retorna os valores únicos de uma coluna[[Series]] ou de um array.
```python
valores_unicos = df['fruta'].unique()
```
```python
['maçã' 'banana' 'laranja']
```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,value_count or nunique or duplicates.md
### Última modificação: 2024-12-14 20:42:15

[[]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,value_counts.md
### Última modificação: 2024-12-22 00:09:53

---
tags:
  - Comando
data: 2024-12-22
---
O método **`value_counts`** conta a frequência de valores únicos em uma série.
```python
data = pd.Series(['a', 'b', 'a', 'c', 'b', 'a'])
print(data.value_counts())
```
```python
a    3
b    2
c    1
dtype: int64
```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\,where.md
### Última modificação: 2024-12-14 18:30:06

---
tags: 
data: 2024-12-14
---
O método **`where`** substitui valores que **não atendem a uma condição** por um valor especificado (ou `NaN`, por padrão), mantendo os valores que atendem à condição.
```python
data = pd.Series([10, 15, 20, 25])
result = data.where(data > 15, 0)  # Substitui valores ≤ 15 por 0
```
```python
0     0    False
1     0    False
2    20    True
3    25    True
dtype: int64

```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\axis=.md
### Última modificação: 2024-11-22 00:48:26

---
tags: 
data: 2024-11-22
---
- **`axis=0`**: Operação feita nas **linhas** (padrão em muitos métodos).
- **`axis=1`**: Operação feita nas **colunas**.

```python
# Remover uma coluna (axis=1)
df_without_column = df.drop('A', axis=1)
print("DataFrame sem a coluna 'A' (axis=1):")
print(df_without_column)

# Remover uma linha (axis=0)
df_without_row = df.drop(0, axis=0)
print("\nDataFrame sem a linha 0 (axis=0):")
print(df_without_row)
```
```python
DataFrame sem a coluna 'A' (axis=1):
   B  C
0  4  7
1  5  8
2  6  9

DataFrame sem a linha 0 (axis=0):
   A  B  C
1  2  5  8
2  3  6  9
```
# funções que usam
|**Método**|**Explicação**|
|---|---|
|[[,drop]]|Remove linhas ou colunas de um DataFrame, dependendo do valor de `axis`.|
|[[,sum]]|Calcula a soma dos valores ao longo de linhas (`axis=0`) ou colunas (`axis=1`).|
|[[,mean]]|Calcula a média dos valores ao longo de linhas (`axis=0`) ou colunas (`axis=1`).|
|[[,apply]]|Aplica uma função ao longo de linhas (`axis=0`) ou colunas (`axis=1`).|
|[[,applymap]]|Aplica uma função element-wise em cada valor do DataFrame, geralmente com `axis=1`.|
|[[,cumsum]]|Calcula a soma acumulada ao longo de linhas (`axis=0`) ou colunas (`axis=1`).|
|[[,std]]|Calcula o desvio padrão ao longo de linhas (`axis=0`) ou colunas (`axis=1`).|
|[[,prod]]|Calcula o produto dos valores ao longo de linhas (`axis=0`) ou colunas (`axis=1`).|
|[[,max]]|Encontra o valor máximo ao longo de linhas (`axis=0`) ou colunas (`axis=1`).|
|[[,min]]|Encontra o valor mínimo ao longo de linhas (`axis=0`) ou colunas (`axis=1`).|
|[[,count]]|Conta o número de elementos não nulos ao longo de linhas (`axis=0`) ou colunas (`axis=1`).|
|[[,sort_values]]|Ordena os valores de um DataFrame ao longo de colunas (`axis=1`) ou linhas (`axis=0`).|
|[[,sort_index]]|Ordena os índices de um DataFrame ao longo de linhas (`axis=0`) ou colunas (`axis=1`).|
|[[,reset_index]]|Restaura o índice de um DataFrame, o que pode envolver linhas (`axis=0`).|
|[[,rename]]|Renomeia colunas ou índices de um DataFrame ao longo de colunas (`axis=1`) ou linhas (`axis=0`).|
|[[,drop_duplicates]]|Remove linhas ou colunas duplicadas dependendo do valor de `axis`.|
|[[,reindex]]|Reorganiza o índice de um DataFrame ao longo de linhas (`axis=0`) ou colunas (`axis=1`).|
|[[,update]]|Atualiza valores no DataFrame ao longo de colunas (`axis=1`) ou linhas (`axis=0`).|

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\Comandos.md
### Última modificação: 2024-11-20 18:04:05

---
tags:
  - Programação
  - Bibliotecas
data: 2024-08-21
nivel:
---
Ele cria manipula dados de excel e csv por meio de dicionários. 
Os comandos mais uteis são:
[[01 - Progetos/zData Analyst/Python/Pandas/Comandos/Comandos#1. **Leitura e escrita de dados**]]
[[01 - Progetos/zData Analyst/Python/Pandas/Comandos/Comandos#2. **Criação de DataFrames e Series**]]
[[01 - Progetos/zData Analyst/Python/Pandas/Comandos/Comandos#3. **Exploração e visualização inicial**]]
[[01 - Progetos/zData Analyst/Python/Pandas/Comandos/Comandos#4. **Seleção e filtragem de dados**]]
[[01 - Progetos/zData Analyst/Python/Pandas/Comandos/Comandos#5. **Manipulação de colunas e linhas**]]
[[01 - Progetos/zData Analyst/Python/Pandas/Comandos/Comandos#6. **Tratamento de valores ausentes**]]
[[01 - Progetos/zData Analyst/Python/Pandas/Comandos/Comandos#7. **Agrupamento e agregação**]]
[[01 - Progetos/zData Analyst/Python/Pandas/Comandos/Comandos#8. **Ordenação e classificação**]]
[[01 - Progetos/zData Analyst/Python/Pandas/Comandos/Comandos#9. **Mesclagem e junção de DataFrames**]]
[[01 - Progetos/zData Analyst/Python/Pandas/Comandos/Comandos#10. **Transformações e operações aplicadas em colunas**]]
[[01 - Progetos/zData Analyst/Python/Pandas/Comandos/Comandos#11. **Operações de datas e tempos**]]
### 1. **Leitura e escrita de dados**:
#### Comandos

- `pd.read_csv()`: Leitura de arquivos CSV.
- `pd.to_csv()`: Escrita de [[DataFrame#Dataframe|Dataframe]] em arquivos CSV.
- `pd.read_excel()`: Leitura de arquivos Excel.
- `pd.to_excel()`: Escrita de DataFrames em arquivos Excel.
- `pd.read_json()`: Leitura de arquivos JSON.
- `pd.read_sql()`: Leitura de dados a partir de um banco de dados SQL.

#### Exemplos
``` python
import pandas as pd

# Leitura de um arquivo CSV
df = pd.read_csv('dados.csv')  # Lê um arquivo CSV chamado 'dados.csv'
print(df.head())  # Exibe as primeiras 5 linhas do DataFrame

# Escrita de um DataFrame em um arquivo CSV
df.to_csv('saida.csv', index=False)  # Escreve o DataFrame em um arquivo CSV sem o índice
```
```
   coluna1  coluna2
0        1       10
1        2       20
2        3       30
```
### 2. **Criação de DataFrames e Series**:
#### Comandos

- `pd.DataFrame()`: Cria um DataFrame a partir de dicionários, listas ou arrays.
- `pd.Series()`: Cria uma Series (coluna unidimensional de dados).

#### Exemplos
``` python
# Criação de um DataFrame a partir de um dicionário
data = {'nome': ['Alice', 'Bob', 'Charlie'], 'idade': [25, 30, 35]}
df = pd.DataFrame(data)
print(df)

# Criação de uma Series
s = pd.Series([10, 20, 30])
print(s)

```
``` 
      nome  idade
0    Alice     25
1      Bob     30
2  Charlie     35

0    10
1    20
2    30
dtype: int64
```
### 3. **Exploração e visualização inicial**:
#### Comandos

- `df.head()`: Visualiza as primeiras linhas de um DataFrame.
- `df.tail()`: Visualiza as últimas linhas de um DataFrame.
- `df.info()`: Mostra informações sobre o DataFrame, como tipos de dados e valores nulos.
- `df.describe()`: Estatísticas descritivas dos dados numéricos.

#### Exemplos

``` python
# Explorando o DataFrame com algumas funções
print(df.head())  # Primeiras 5 linhas
print(df.info())  # Informação sobre o DataFrame
print(df.describe())  # Estatísticas descritivas dos dados numéricos

```

```
      nome  idade
0    Alice     25
1      Bob     30
2  Charlie     35

<class 'pandas.core.frame.DataFrame'>
RangeIndex: 3 entries, 0 to 2
Data columns (total 2 columns):
 #   Column  Non-Null Count  Dtype 
---  ------  --------------  ----- 
 0   nome    3 non-null      object
 1   idade   3 non-null      int64  
dtypes: int64(1), object(1)
memory usage: 176.0+ bytes

           idade
count   3.000000
mean   30.000000
std     5.000000
min    25.000000
25%    27.500000
50%    30.000000
75%    32.500000
max    35.000000

```
### 4. **Seleção e filtragem de dados**:
#### Comandos

- `df[]`: Seleção de colunas por nome.
- `df.loc[]`: Seleção de linhas e colunas por rótulo.
- `df.iloc[]`: Seleção de linhas e colunas por índice.
- Filtragem com condições booleanas, como `df[df['coluna'] > valor]`.

#### Exemplos

``` python
# Selecionando colunas
print(df['nome'])

# Filtrando linhas com base em uma condição
print(df[df['idade'] > 30])

```

```
0      Alice
1        Bob
2    Charlie
Name: nome, dtype: object

      nome  idade
2  Charlie     35

```
### 5. **Manipulação de colunas e linhas**:
#### Comandos
- `df.drop()`: Remove colunas ou linhas.
- `df.rename()`: Renomeia colunas.
- `df.insert()`: Insere uma nova coluna no DataFrame.
- `df.assign()`: Cria uma nova coluna no DataFrame de forma funcional.
#### Exemplos
``` python
# Removendo uma coluna
df = df.drop('idade', axis=1)
print(df)

# Inserindo uma nova coluna
df['idade'] = [25, 30, 35]
print(df)

# Renomeando colunas
df = df.rename(columns={'nome': 'Nome', 'idade': 'Idade'})
print(df)
```

```
      nome
0    Alice
1      Bob
2  Charlie

      nome  idade
0    Alice     25
1      Bob     30
2  Charlie     35

      Nome  Idade
0    Alice     25
1      Bob     30
2  Charlie     35

```
### 6. **Tratamento de valores ausentes**:
#### Comandos
- `df.isna()`, `df.notna()`: Verifica valores ausentes.
- `df.fillna()`: Preenche valores ausentes com um valor específico.
- `df.dropna()`: Remove linhas ou colunas com valores ausentes.
#### Exemplos
``` python
# Adicionando valores ausentes
df.loc[1, 'Idade'] = None
print(df)

# Preenchendo valores ausentes
df['Idade'] = df['Idade'].fillna(0)
print(df)

```

```
      Nome  Idade
0    Alice   25.0
1      Bob    NaN
2  Charlie   35.0

      Nome  Idade
0    Alice   25.0
1      Bob    0.0
2  Charlie   35.0

```
### 7. **Agrupamento e agregação**:
#### Comandos
- `df.groupby()`: Agrupa dados por uma ou mais colunas.
- `df.agg()`: Agrega dados com funções estatísticas (como soma, média, contagem).
- `df.pivot_table()`: Cria tabelas dinâmicas com agregação.
#### Exemplos
``` python
# Agrupando e somando as idades por nome
grouped = df.groupby('Nome')['Idade'].sum()
print(grouped)
```
```
Nome
Alice      25.0
Bob         0.0
Charlie    35.0
Name: Idade, dtype: float64

```
### 8. **Ordenação e classificação**:
#### Comandos
- `df.sort_values()`: Ordena os dados com base em uma ou mais colunas.
- `df.rank()`: Classifica os dados com base nos valores.
#### Exemplos
``` python
# Ordenando os dados pela coluna 'Idade'
sorted_df = df.sort_values(by='Idade')
print(sorted_df)
```
```
      Nome  Idade
1      Bob    0.0
0    Alice   25.0
2  Charlie   35.0
```
### 9. **Mesclagem e junção de DataFrames**:
#### Comandos
- `pd.concat()`: Concatena DataFrames ao longo de um eixo.
- `pd.merge()`: Mescla/junta DataFrames com base em colunas comuns (similar a operações de join em SQL).
#### Exemplos
``` python
# Criando dois DataFrames
df1 = pd.DataFrame({'Nome': ['Alice', 'Bob'], 'Idade': [25, 30]})
df2 = pd.DataFrame({'Nome': ['Bob', 'Charlie'], 'Cidade': ['SP', 'RJ']})

# Mesclando os DataFrames
merged_df = pd.merge(df1, df2, on='Nome', how='outer')
print(merged_df)

```
```
      Nome  Idade Cidade
0    Alice   25.0    NaN
1      Bob   30.0     SP
2  Charlie    NaN     RJ

```
### 10. **Transformações e operações aplicadas em colunas**:
#### Comandos
- `df.apply()`: Aplica uma função personalizada a colunas ou linhas.
- `df.applymap()`: Aplica uma função a cada elemento de um DataFrame.
- `df.map()`: Mapeia valores de uma coluna usando um dicionário ou função.
#### Exemplos
``` python
# Aplicando uma função que dobra as idades
df['Idade'] = df['Idade'].apply(lambda x: x * 2)
print(df)

```
```
      Nome  Idade
0    Alice   50.0
1      Bob    0.0
2  Charlie   70.0

```
### 11. **Operações de datas e tempos**:
#### Comandos
- `pd.to_datetime()`: Converte dados para o formato datetime.
- Manipulações de tempo com `.dt`, como extração de ano, mês, dia, etc.
#### Exemplos
``` python
# Criando uma coluna de datas
df['Data'] = pd.to_datetime(['2022-01-01', '2022-02-01', '2022-03-01'])
print(df)

# Extraindo o ano das datas
df['Ano'] = df['Data'].dt.year
print(df)

```

```
      Nome  Idade       Data
0    Alice   50.0 2022-01-01
1      Bob    0.0 2022-02-01
2  Charlie   70.0 2022-03-01

      Nome  Idade       Data   Ano
0    Alice   50.0 2022-01-01  2022
1      Bob    0.0 2022-02-01  2022
2  Charlie   70.0 2022-03-01  2022

```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\filtragem simples.md
### Última modificação: 2024-12-14 20:22:27

---
tags: 
data: 2024-12-14
---
A filtragem simples no Pandas consiste em selecionar linhas de um DataFrame ou Series com base em condições lógicas. Ela retorna apenas as linhas que atendem à condição especificada.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\index=.md
### Última modificação: 2024-12-13 00:05:52

---
tags:
  - Comando
data: 2024-12-13
---
O parâmetro **`index=`** aparece em diversos métodos e funções no **pandas** para definir ou manipular os índices de objetos como DataFrames ou Series. Ele é usado principalmente para criar ou modificar o índice     que é a "etiqueta" que identifica as linhas.

- pd.Series()     
- pd.DataFrame()     
- set_index()     
- reset_index()     
- reindex()     
- to_csv(index=...)     
- read_csv(index_col=...)     
- to_excel(index=...)     
- from_dict(orient='index')    
- from_records(index=...)     
- merge(left_index=...     right_index=...)     
- concat(ignore_index=...)     
- pivot(index=...)     
- pivot_table(index=...)

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\inplace=.md
### Última modificação: 2024-11-22 00:38:47

---
tags:
  - Comando
data: 2024-11-21
---
- **`inplace=True`**: Modifica o objeto original.
- **`inplace=False`** (padrão): Retorna uma nova cópia do objeto com as mudanças.
```python
new_df = df.drop(columns=['A'])
```
```python
df.drop(columns=['A'], inplace=True)
```
# funções que usam
| **Método**           | **Explicação**                                                               |
| -------------------- | ---------------------------------------------------------------------------- |
| [[,drop]]            | Remove linhas ou colunas de um DataFrame.                                    |
| [[,fillna]]          | Substitui valores ausentes (`NaN`) por um valor especificado.                |
| [[,replace]]         | Substitui valores específicos por outros no DataFrame.                       |
| [[,sort_values]]     | Ordena o DataFrame com base nos valores de uma ou mais colunas.              |
| [[,sort_index]]      | Ordena o DataFrame pelo índice (linhas) de forma ascendente ou descendente.  |
| [[,rename]]          | Renomeia colunas ou índices no DataFrame.                                    |
| [[,reset_index]]     | Reseta o índice do DataFrame, transformando-o em uma coluna regular.         |
| [[,set_index]]       | Define uma ou mais colunas como o índice do DataFrame.                       |
| [[,update]]          | Atualiza o DataFrame com valores de outro DataFrame, substituindo os dados.  |
| [[,drop_duplicates]] | Remove linhas duplicadas no DataFrame.                                       |
| [[,rename_axis]]     | Renomeia o eixo (index ou colunas) do DataFrame.                             |
| [[,reindex]]         | Reorganiza o DataFrame com base em um novo índice ou colunas especificadas.  |
| [[,pop]]             | Remove e retorna uma coluna do DataFrame.                                    |
| [[,drop]]            | Remove elementos de uma Series (linhas ou valores) com base em um rótulo.    |
| [[,fillna]]          | Substitui valores ausentes (`NaN`) por um valor especificado em uma Series.  |
| [[,replace]]         | Substitui valores específicos por outros em uma Series.                      |
| [[,sort_values]]     | Ordena os valores de uma Series em ordem crescente ou decrescente.           |
| [[,sort_index]]      | Ordena a Series com base no índice.                                          |
| [[,rename]]          | Renomeia o índice ou valores de uma Series.                                  |
| [[,reset_index]]     | Reseta o índice de uma Series, transformando o índice em uma coluna regular. |
| [[,set_axis]]        | Define um novo eixo (índice ou valores) para a Series.                       |
| [[,update]]          | Atualiza os valores de uma Series com base em outra Series.                  |
| [[,drop_duplicates]] | Remove elementos duplicados de uma Series.                                   |
| [[,rename_axis]]     | Renomeia o eixo (index ou colunas) de uma Series.                            |
| [[,reindex]]         | Reorganiza a Series com base em um novo índice especificado.                 |

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\Normalizar nomes de colunas.md
### Última modificação: 2024-11-20 20:16:35

---
tags:
  - Comando
data: 2024-11-20
---
Este código retira espaços, deixa no minúsculo, e troca todos os espaços por [[undeline]]  

```python
new_col_names = [old_name.strip().lower().replace(' ', '_') for old_name in Mude_aqui.columns]
Mude_aqui.columns = new_col_names
```


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\Sem título.md
### Última modificação: 2024-12-27 21:10:33



### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\subset=.md
### Última modificação: 2024-11-22 00:55:42

---
tags: 
data: 2024-11-22
---
# funções que usam 
| **Método**       | **Explicação**                                                                                                                                                         |
| ---------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [[,dropna]]     | Remove linhas ou colunas contendo valores ausentes (`NaN`) em colunas específicas, definidas pelo parâmetro `subset`.                                                  |
| [[,duplicated]] | Retorna um DataFrame indicando as linhas duplicadas, considerando apenas as colunas especificadas no parâmetro `subset`.                                               |
| [[,loc]]        | Permite selecionar dados de um DataFrame com base em um índice ou condição específica, limitando a operação a um subconjunto de colunas através do parâmetro `subset`. |
| [[,replace]]    | Substitui valores específicos no DataFrame, podendo agir somente em um subconjunto de colunas definidas pelo parâmetro `subset`.                                       |


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\Pandas\Comandos\~.md
### Última modificação: 2024-12-05 20:32:21

---
tags: 
data: 2024-12-05
---
Ele nega o que vem aceguir

```python
df_logs[~df_logs['email'].isna()]
```
Diz quais os valores ausentes tem no df

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\SciPy\Comando\,cdf.md
### Última modificação: 2025-01-07 23:14:32

---
tags:
  - Comando
data: 2025-01-07
---
O `st.cdf` calcula a probabilidade acumulada até um certo valor em uma distribuição.
```python
from scipy import stats as st 
data = st.norm(5000, 1500) 
desired_cost = 4000 
probability = data.cdf(desired_cost) 
print(probability)
```
0.2524925375469229

As chances são maiores que 25%. Pelo menos é possível 😉!

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\SciPy\Comando\,norm.md
### Última modificação: 2025-01-07 23:06:23

---
tags:
  - Comando
data: 2025-01-07
---
Cria uma distribuição normal
```python
from scipy import stats as st 
st.norm(5000, 1500)
```
Dado a media e o sigma[[Desvio padrão]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\SciPy\Comando\,ppf.md
### Última modificação: 2025-01-07 23:11:23

---
tags:
  - Comando
data: 2025-01-07
---
O `st.ppf` encontra o valor exato em uma distribuição para uma certa porcentagem acumulada.

```python
from scipy import stats as st
data = st.norm(5000, 1500) 
target_level = 0.1 
cost = data.ppf(target_level) 
print(cost)
```
3077.6726516830995

Agora sabemos que 10% dos estudantes não gastam mais de $3.077 com os estudos. Eles realmente sabem como economizar dinheiro!

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\SciPy\Comando\,pvalue.md
### Última modificação: 2025-01-09 00:04:08

---
tags:
  - Comando
data: 2025-01-08
---
A função [[Valor-p|p-value]] retorna a probabilidade de que os resultados observados (ou mais extremos) aconteçam sob a hipótese nula (H0H_0H0​). Em termos simples, é uma medida que ajuda a decidir se rejeitamos ou não H0H_0H0​:

- **Se p≤αp \leq \alphap≤α**: Rejeitamos H0H_0H0​ (há evidência significativa).
- **Se p>αp > \alphap>α**: Não rejeitamos H0H_0H0​ (não há evidência significativa).

```python
from scipy import stats as st
import pandas as pd

scooters = pd.Series([15, 31, 10, 21, 21, 32, 30, 25, 21,
28, 25, 32, 38, 18, 33, 24, 26, 40, 24, 37, 20, 36, 28, 38,
24, 35, 33, 21, 29, 26, 13, 25, 34, 38, 23, 37, 31, 28, 32,
24, 25, 13, 38, 34, 48, 19, 20, 22, 38, 28, 31, 18, 21, 24,
31, 21, 28, 29, 33, 40, 26, 33, 33,  6, 27, 24, 17, 28,  7,
33, 25, 25, 29, 19, 30, 29, 22, 15, 28, 36, 25, 36, 25, 29,
33, 19, 32, 32, 28, 26, 18, 48, 15, 27, 27, 27,  0, 28, 39,
27, 25, 39, 28, 22, 33, 30, 35, 19, 20, 18, 31, 44, 20, 18,
17, 28, 17, 44, 40, 33,])

optimal_value = 30

alpha = 0.05

results = st.ttest_1samp(scooters, optimal_value)

print('valor-p: ',results.pvalue)
```
valor-p:  0.00033528259973700795

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\SciPy\Comando\,ttest_1samp.md
### Última modificação: 2025-01-09 00:03:50

---
tags:
  - Comando
data: 2025-01-08
---
A função **`ttest_1samp`** é usada para realizar um [[T teste|teste t]] de uma amostra, verificando se a média de uma amostra é estatisticamente diferente de um valor hipotético.

```python
from scipy.stats import ttest_1samp
horas_trabalho = [7.8, 8.1, 7.9, 8.0, 8.2, 7.7, 8.1, 7.9, 8.0, 8.3]
media_hipotetica = 8.0

t_stat, p_value = ttest_1samp(horas_trabalho, media_hipotetica)
t_stat, p_value 
```
(-3.076740298213703e-14, 0.9999999999999761)

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\SciPy\Comando\,ttest_ind.md
### Última modificação: 2025-01-09 19:49:30

---
tags:
  - Comando
data: 2025-01-09
---
O comando **`ttest_ind`** realiza um **teste t de Student para amostras independentes**, comparando as médias de duas amostras para determinar se há uma diferença estatisticamente significativa entre elas.

```python
turma_A = [85, 90, 78, 88, 76]
turma_B = [92, 88, 85, 94, 89]

stat, p_value = ttest_ind(turma_A, turma_B)
(stat, p_value)
```
(-1.9586544731803432, 0.08583640994522063)

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Python\SciPy\Comando\,ttest_rel.md
### Última modificação: 2025-01-09 19:55:55

---
tags:
  - Comando
data: 2025-01-09
---
O **`ttest_rel`** realiza um **teste t pareado (ou dependente)**, usado para comparar as médias de dois conjuntos de dados relacionados (ex.: antes e depois de um tratamento, ou medições do mesmo grupo em diferentes condições).
```python
antes = [70, 65, 80, 75, 60]
depois = [85, 80, 90, 88, 70]

stat, pvalue = st.ttest_rel(antes, depois)

print(f"Estatística t: {stat}")
print(f"Valor p: {pvalue}")
```
Estatística t: -11.224972160321824
Valor p: 0.00035873526037745164

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Amostragem.md
### Última modificação: 2025-01-09 20:02:36

---
tags:
  - Conceito
data: 2025-01-09
---
### **Amostragem Aleatória:**

- Seleciona elementos **ao acaso** de toda a população.
- Cada indivíduo tem a **mesma chance** de ser escolhido.
- Útil quando a população é homogênea ou não há subgrupos relevantes.

**Exemplo:** Selecionar 100 clientes aleatórios de uma base de 10.000 para uma pesquisa.

---

### **Amostragem Estratificada:**

- Divide a população em **subgrupos (estratos)** com características comuns.
- Realiza amostragem em cada estrato proporcionalmente ao seu tamanho na população.
- Garante representatividade de todos os subgrupos.

**Exemplo:** Em uma pesquisa com uma escola, dividir os alunos por séries (estratos) e selecionar proporcionalmente de cada série.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Análise de dados.md
### Última modificação: 2024-12-31 01:26:49

---
tags:
  - DataAnalyst
data: 2024-09-04
nivel:
---
O campo da análise de dados envolve extrair [[Insights|insights]] significativos de [[Dados brutos|dados brutos]] para conduzir processos de tomada de decisão. Inclui uma ampla gama de técnicas e disciplinas que vão desde a simples compilação de [[Dados|dados]] até [[Algoritimo|algoritmos]] avançados e [[Análise Estatística]]. Esse conhecimento permite que os analistas de dados apoiem as empresas na identificação de [[Tendência|tendências]], na tomada de decisões informadas, na [[Análise preditiva|previsão]] de resultados potenciais - desempenhando, portanto, um papel crucial na formação de estratégias de negócios.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Análise descritiva ou exploratória.md
### Última modificação: 2024-12-31 01:26:53

---
tags:
  - DataAnalyst
data: 2024-09-04
nivel:
---
A análise descritiva envolve a interpretação de [[Dados|dados]] **históricos** para compreender as **mudanças ocorridas** em um negócio. Ela utiliza [[Métricas|métricas]] financeiras como variações de preços e crescimento de vendas para comparar períodos ou empresas do mesmo setor. Essa análise é crucial para identificar áreas de **força** e **fraqueza**, informando estratégias de gestão com base em dados passados. Embora forneça insights valiosos sobre o desempenho passado, a análise descritiva **não prevê o futuro** e pode ser influenciada por viés na escolha das métricas analisadas.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Análise diagnóstica.md
### Última modificação: 2024-12-31 01:27:00

---
tags:
  - DataAnalyst
data: 2024-09-04
nivel:
---
A análise diagnóstica visa entender os motivos e as explicações dos dados obtidos na [[Análise descritiva ou exploratória|analise descritiva]].

![[Análise descritiva ou exploratória]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Análise Estatística.md
### Última modificação: 2024-09-04 21:48:45

---
tags:
  - DataAnalyst
data: 2024-08-25
nivel:
---
A análise estatística [[Coleta de dados|coleta]], examinar, interpretar e [[Apresentar dados|apresentar dados]], permitindo que os analistas de dados descubram [[Padrões|padões]], [[Tendências|tendências]] e relacionamentos, deduzam [[Insights]] e apoiem a tomada de decisões em vários campos.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Análise Explanatória.md
### Última modificação: 2024-12-31 01:27:06

---
tags:
  - DataAnalyst
data: 2024-09-05
nivel:
---
A analise explanatória segundo [[Storytelling com dados.pdf|o livro]] é por meio da [[Análise descritiva ou exploratória|análise exploratória]] focar nas hipóteses e nas maneiras de examinar importantes tirada da exploratória[[Storytelling com dados.pdf#page=30&selection=28,71,35,41|(...)]]. Assemelhando-se a [[Análise diagnóstica]]. [[]]




### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Análise preditiva.md
### Última modificação: 2024-12-31 01:27:09

---
tags:
  - DataAnalyst
data: 2024-09-04
nivel:
---
##### Análise preditiva
A análise preditiva é uma técnica avançada de análise de dados que utiliza [[Aprendizado de máquina|machine learning]], [[Estatística|estatística]] e [[Modelagem|modelagem]] para prever eventos futuros com base em [[Dados|dados]] históricos e atuais. É amplamente utilizada para prever [[Tendência|tendências]] de mercado, comportamentos de consumidores, necessidades de inventário, manutenção de equipamentos e muito mais, ajudando as organizações a tomar decisões estratégicas informadas. Essa abordagem é crucial em um contexto de [[Big Data]], onde grandes volumes de dados são analisados ​​para extrair [[Insights|insights]] preditivos precisos.
##### O que não faz:
- Entendimento Contextual e Interpretação
- Previsão de Eventos Extremos
- Viés e Ética
- Dependência de Dados de Qualidade
- Adaptação a Mudanças:

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Análise prescritiva.md
### Última modificação: 2024-12-31 01:27:13

---
tags:
  - DataAnalyst
data: 2024-09-04
nivel:
---
A análise prescritiva é a utilização da [[Análise preditiva]] para prescrever ações ou decisões a serem tomadas.
![[Análise preditiva#Análise preditiva]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Aprendizado de máquina.md
### Última modificação: 2024-08-25 20:56:05

---
tags:
  - DataAnalyst
data: 2024-08-25
nivel:
---
O aprendizado de máquina, um subconjunto da [[IA|inteligência artificia]]. Ele fornece a capacidade de aprender automaticamente, melhorar com a experiência e tomar decisões sem ser explicitamente programado.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Cauda longa vx Calda pesada.md
### Última modificação: 2025-01-03 23:03:41

---
tags:
  - Conceito
data: 2025-01-03
---
![[Pasted image 20250103225617.png]] [[histograma]]

![[Pasted image 20250103230302.png|300]]
No caso a cauda longa e 3, 4 e 5 e a calda pesada é a 1.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Coleta de dados.md
### Última modificação: 2024-08-25 19:37:40

---
tags:
  - DataAnalyst
data: 2024-08-25
nivel:
---
O processo sistemático de reunir e medir informações sobre variáveis-alvo. Permitindo que analistas de [[Dados|dados]] respondam perguntas relevantes e avaliem resultados.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Conceitos-chave de dados.md
### Última modificação: 2024-10-28 23:50:41

---
tags:
  - DataAnalyst
data: 2024-08-25
nivel:
---
![[Coleta de dados]]
![[Limpeza de dados]]
![[Exploração]]
![[Análise Estatística]]
![[Visualização de dados]]
![[Aprendizado de máquina]]



### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Covariância.md
### Última modificação: 2025-01-07 20:23:45

---
tags:
  - Conceito
data: 2025-01-03
---
A **covariância** é uma medida estatística que indica como duas variáveis mudam juntas. O número resultante da covariância revela a **relação linear** entre essas variáveis, mas não é uma medida padronizada, o que pode dificultar a interpretação direta.

---

### Interpretação do número da covariância:

1. **Sinal da covariância**:
    
    - **Positivo**: As variáveis tendem a aumentar juntas.  
    - **Negativo**: Quando uma variável aumenta, a outra tende a diminuir.  
    - **Próximo de zero**: Não há uma relação linear significativa entre as variáveis.
2. **Magnitude da covariância**:
    - A magnitude indica a força da relação, mas é difícil de interpretar diretamente porque a covariância depende das unidades das variáveis. Por exemplo:
        - Se medirmos altura em metros e peso em quilos, o valor será diferente de medir altura em centímetros e peso em gramas.
    - Portanto, a covariância é útil para identificar **tendências**, mas não para comparar diretamente relações entre diferentes conjuntos de dados.

### Formulas
$$Populacional = \frac{\sum_{i=1}^{n} (x_i - μ)(y_i - μ)}{nD}​$$$$Amostral = \frac{\sum_{i=1}^{n} (x_i - \bar{x})(y_i - \bar{y})}{n}​$$**Onde:** 
- $x_i - \bar{x}$: Cada valor do conjunto de dados. 
- $\bar{x}$: Média dos valores. 
- $n$: Número de itens no conjunto.
 
- Continuando com o exemplo, _xᵢ_ representa o tamanho de uma casa em metros quadrados, e _yᵢ_ representa o preço em dólares.
- _n_ é o número de valores no conjunto de dados (o número de casas e os respectivos preços).
- _Σ_ é o símbolo de soma.
- x̄ é o tamanho da média das casas no conjunto de dados.
- ȳ é a média dos preços das casas no conjunto de dados.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Dados assimétricos.md
### Última modificação: 2025-01-03 23:41:35

---
tags:
  - Conceito
data: 2025-01-03
---
![[Pasted image 20250103233938.png|200]]
Dados assimétricos são [[histograma]]s onde tem uma tendência a esquerda ou a direita. criando [[Cauda longa vx Calda pesada|caudas]].

![[Pasted image 20250103234115.png|200]]
Uma boa forma de descobrir é usando [[Boxplot]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Densidade de probabilidade.md
### Última modificação: 2025-01-09 20:24:43

---
tags:
  - Conceito
data: 2025-01-09
---
**Densidade de probabilidade** é uma função que descreve como os valores de uma variável contínua são distribuídos ao longo de seu domínio. É usada em estatística e probabilidade para representar a **probabilidade relativa** de a variável assumir determinado valor ou intervalo de valores.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Desvio médio absoluto.md
### Última modificação: 2025-01-03 20:20:34

---
tags: 
data: 2025-01-03
Link: https://www.youtube.com/watch?v=ar75_a8cxMk
---
# Desvio médio absoluto
O quanto os valores de um conjunto de dados estão distantes da média.

O desvio absoluto é o módulo da diferença da media.
1. primeiro se tira a [[Média]]
2. depois calcula-se a diferença da media dos itens da tabela
3. E assim se acha os desvios

### formula
$$\text{Desvio Médio Absoluto} = \frac{\sum_{i=1}^{n} |x_i - \bar{x}|}{n}$$
**Onde:** 
- $|x_i - \bar{x}|$: Cada valor do conjunto de dados. 
- $\bar{x}$: Média dos valores. 
- $n$: Número de itens no conjunto.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Desvio padrão.md
### Última modificação: 2025-01-07 22:19:08

---
tags:
  - Comando
data: 2025-01-03
aliases:
  - Standard desviation
---
É a raiz quadrada da [[Variância]]. Muito útil em analises de [[distribuição normal]]. [[histograma]]
###### Resumo do que o desvio padrão "quer dizer":

- **Valor baixo**: Menos variação, os dados estão mais próximos da média.
- **Valor alto**: Maior variação, os dados estão mais espalhados.
![[Pasted image 20250103211624.png|300]]
![[posiçãosda.gif|300]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Desvio.md
### Última modificação: 2025-01-07 20:09:20

---
tags:
  - Conceito
data: 2025-01-07
aliases:
  - desvios
---
$d_i =  x_i - \bar{x}$
![[Pasted image 20250107194657.png]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Dispersão.md
### Última modificação: 2025-01-06 23:30:44

---
tags:
  - Conceito
data: 2025-01-02
---
É a media da distancia dos dados.
#### Exemplo

**Cálculo das Distâncias Absolutas:** 
 |2 - 4| = 2 
 |4 - 4| = 0 
 |6 - 4| = 2 
***Cálculo da Distância Média:**
(2 + 0 + 2) / 3 = 4 / 3 ≈ 1.33

#### Formula
$$σ^2 = \frac{∑(x_i​−μ)}{n}$$
onde: 
- _σ²_ é a variância
- _Σ_ é o sinal de soma
- _xᵢ_ representa um valor do conjunto de dados
- _µ_ é a média
- _n_ é o número de valores no conjunto de dados

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Distribuição normal.md
### Última modificação: 2025-01-03 22:57:24

---
tags:
  - Conceito
data: 2025-01-03
aliases:
  - Distribuição Gaussiana
---
![[Pasted image 20250103212052.png|300]]
Basicamente e a distribuição cujo histograma tem formato de cino.[[histograma]]

[[Regra dos três sigmas]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\DMA vx Variância.md
### Última modificação: 2025-01-07 00:12:30

---
tags:
  - Conceito
data: 2025-01-07
---
A variância quantifica a dispersão ao quadrado, sendo sensível a outliers e útil em cálculos estatísticos avançados, mas difícil de interpretar diretamente devido às unidades quadráticas. Já o Desvio Médio Absoluto (DMA) fornece uma medida intuitiva de dispersão, menos sensível a valores extremos, mantendo a unidade original dos dados, o que o torna prático para análises exploratórias.

### **2. Sensibilidade a Outliers**

- **Variância** é muito sensível a outliers porque eleva ao quadrado as diferenças. Isso significa que valores extremos têm um grande impacto.
- **DMA** é menos sensível, pois considera apenas o valor absoluto das diferenças, sem amplificar os extremos.

---

### **3. Interpretação**

#### **Variância**

- Indica a **dispersão geral**, mas em uma escala difícil de interpretar diretamente (devido às unidades quadráticas).
- Geralmente é usada para cálculos adicionais, como o **desvio padrão**, que simplifica a interpretação ao trazer a unidade de volta ao formato original.

#### **DMA**

- Fornece uma noção mais **intuitiva** da dispersão média em torno da média, já que o resultado está na mesma unidade dos dados originais.

---

### **4. Uso Prático**

- **Variância**:  
    É mais usada em **estatísticas avançadas**, especialmente em modelagem, como regressão e análise de variabilidade. É útil para cálculos matemáticos e probabilísticos.
- **DMA**:  
    É mais usado para uma visão **simplificada e intuitiva** da dispersão, especialmente em análises exploratórias ou quando se quer minimizar o impacto de outliers.



### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Erro padrão & Desvio padrão.md
### Última modificação: 2025-01-09 19:26:22

---
tags:
  - Conceito
data: 2025-01-09
---
- O [[desvio padrão]] descreve a variabilidade dos **dados individuais** em torno da média.
- O [[erro padrão]] descreve a variabilidade da **média amostral** em relação à verdadeira média populacional.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Erro padrão.md
### Última modificação: 2025-01-09 19:25:28

---
tags: 
data: 2025-01-09
---
É calculado com base no [[desvio padrão]] da amostra e no tamanho da amostra (nnn). Mede a incerteza de que a média da amostra reflete a média real da população.

# formula
$$\text{Erro Padrão} = \frac{\text{Desvio Padrão}}{\sqrt{n}}$$


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Estatística Descritiva.md
### Última modificação: 2024-09-03 23:31:31

---
tags:
  - DataAnalyst
data: 2024-09-03
nivel:
---
A estatística descritiva é um ramo da [[Estatística|estatística]] que se concentra em descrever e resumir conjuntos de [[Dados|dados]]. Ela utiliza medidas numéricas e [[Gráficos|gráficos]] para apresentar informações sobre a [[Distribuição|distribuição]], [[Tendência|tendência]] central, [[Disperssão de dados|disperssão]] e [[Forma dos dados|forma]] dos dados. A estatística descritiva é crucial para entender [[Dados brutos|dados brutos]], identificar padrões e tirar [[Conclusões Preliminares|conclusões preliminares]].
[[Tipos de variáveis]]
[[Medidas]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Excel.md
### Última modificação: 2024-09-05 21:21:51

---
tags:
  - DataAnalyst
data: 2024-08-25
nivel:
---
O Excel é uma ferramenta poderosa utilizada por analistas de [[Dados]] em todo o mundo para armazenar, manipular e analisar dados. Ele oferece uma vasta gama de recursos, como [[Tabelas dinâmicas|tabelas dinâmicas]], gráficos e um poderoso conjunto de fórmulas e funções para ajudar a peneirar grandes conjuntos de dados.
[[Função.excel]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Exploração.md
### Última modificação: 2024-08-25 19:39:33

---
tags: 
data: 2024-08-25
nivel:
---
Exploração dos [[Dados|dados]] envolve discernir [[Padrões|padrões]], identificar anomalias, examinar estruturas subjacentes e testar [[Hipóteses]], o que geralmente é realizado por meio de  [[Estatística Descritiva|estatística descritiva]], métodos visuais ou [[Algoritimo|algoritimos]] sofisticados.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Indrodução.md
### Última modificação: 2024-12-31 01:28:35

---
tags:
  - DataAnalyst
data: 2024-08-25
nivel:
---
### O que é análise de dados?

A [[Análise de dados]] é o processo de examinar conjuntos de [[Dados|dados]] para descobrir [[Padrões|padrões]], [[Tendências|tendências]] e [[Insights]]. É uma ferramenta poderosa que pode ser usada para tomar decisões mais informadas em uma variedade de campos, como negócios, saúde, ciência e governo.

### Tipos de análise de dados

* [[Análise descritiva ou exploratória]]
	* [[Análise diagnóstica]]
* [[Análise preditiva]]
	* [[Análise prescritiva]]

[[Conceitos-chave de dados]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Insights.md
### Última modificação: 2024-12-31 01:28:40

---
tags:
  - DataAnalyst
data: 2024-09-04
nivel:
---
Insights em [[Análise de dados|análise de dados]] são descobertas valiosas e acionáveis, escondidas nos [[Dados|dados]], que revelam [[Padrões|padrões]], [[Tendências|tendências]] e [[Relações|relações]] que podem ser usados para resolver problemas e tomar decisões estratégicas. 


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Limpeza de dados.md
### Última modificação: 2024-08-25 19:38:33

---
tags:
  - DataAnalyst
data: 2024-08-25
nivel:
---
 Ela envolve o processo de inspecionar, limpar, transformar e [[Modelar dados|modelar dados]] para descobrir informações úteis, informar conclusões e dar suporte à tomada de decisões.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Mediana.md
### Última modificação: 2025-01-02 22:58:37

---
tags:
  - DataAnalyst
data: 2024-09-03
nivel:
---
é o Q2 das [[Medidas de variabilidade]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Medidas de Tendência Central.md
### Última modificação: 2024-12-31 01:29:18

---
tags:
  - DataAnalyst
data: 2024-09-03
nivel:
---
As Medidas de Tendência Central são ferramentas essenciais na [[Estatística Descritiva|estatística descritiva]], utilizadas para resumir um conjunto de [[Dados]] em um único valor que represente o centro da [[Distribuição]] dos dados. Em outras palavras, elas indicam onde os dados tendem a se concentrar.
# Exemplos
![[Média]]
![[Mediana]]
![[Moda]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Medidas.md
### Última modificação: 2024-12-31 01:29:14

---
tags:
  - DataAnalyst
data: 2024-09-03
nivel:
---
![[Medidas de Tendência Central]]
![[Medidas de Variabilidade]]
![[Medidas de posição]]


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Moda.md
### Última modificação: 2024-12-31 01:29:23

---
tags:
  - DataAnalyst
data: 2024-09-03
nivel:
---
### Para que serve a Moda?

A **moda** serve para identificar o valor ou valores que ocorrem com maior frequência em um conjunto de [[Dados|dados]]. Isso pode ser útil em várias situações

- [[Distribuições categóricas]]
- Análise de tendência
- Perfil de consumidores ou produtos
- [[Outliers]]

### Para que não serve a Moda?

Embora a moda seja uma medida simples e útil em alguns contextos, há situações onde ela não é apropriada

- [[Dados contínuos ]]
- [[Distribuições simétricas ]]ou normais
- [[Comparação de variabilidade ]]

### Vantagens da Moda

- Simplicidade 
- Adequada para dados categóricos 
- Não é afetada por valores extremos 
- Representativa de preferências 

### Desvantagens da Moda

- Pode não ser única 
- Pouca utilidade em dados contínuos 
- Não utiliza todos os dados 
- Pode não ser representativa 

### Conclusão

A moda é uma ferramenta útil para descrever distribuições em que se procura pelo valor mais frequente, especialmente em [[Dados Categóricos|dados categóricos]]. No entanto, para dados contínuos ou para distribuições complexas, ela pode ser limitada e menos representativa, sendo melhor complementada por outras medidas de tendência central, como média e mediana.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Média.md
### Última modificação: 2024-12-31 01:29:06

---
tags:
  - DataAnalyst
data: 2024-09-03
nivel:
---
[[Média Aritmética]]
[[Média Ponderada]]
[[Média Geométrica]]
[[Média Harmônica]]
[[Média Truncada(Trimean)]]
[[Média Recortada (Média Aparada)]]
[[Média Quadrática]]
[[Média Logarítima]]
[[Média Winsorizada]]
[[Média de Potência(Média de Hölder)]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Padrões & Tendências & Relações.md
### Última modificação: 2024-12-31 01:29:35

---
tags:
  - DataAnalyst
data: 2024-09-04
nivel:
---
Imagine um gráfico de vendas de sorvete. Um **[[Padrões|padrão]]** seria o aumento das vendas nos meses de verão. Uma **[[Tendência|tendência]]** seria um crescimento constante nas vendas ao longo de vários anos, indicando que o negócio está se expandindo. E uma [[Relação|relação]] entre temperatura e vendas


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Regra dos três sigmas.md
### Última modificação: 2025-01-03 22:57:14

---
tags:
  - Conceito
data: 2025-01-03
---
![[Pasted image 20250103212621.png|300]]

Basicamente a regra diz que em uma [[distribuição normal]] se se distanciar 3 sigmas([[desvio padrão]]) chega-se em 99,7% dos dados do conjunto. [[histograma]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Sem título.md
### Última modificação: 2024-08-28 23:01:55

### 1. **Introdução**

- O que é Analytics de Dados
- Tipos de Analytics de Dados (Descritivo, Diagnóstico, Preditivo, Prescritivo)

### 2. **Fundamentos**

- Conceitos-chave de Dados
- Coleta de Dados
- Limpeza de Dados
- Transformação de Dados
- Análise Estatística
- Visualização de Dados

### 3. **Habilidades de Programação**

- Aprender uma Linguagem de Programação
    - Python
    - R
- Bibliotecas para Manipulação de Dados
    - Pandas
    - Dplyr
- Bibliotecas para Visualização de Dados
    - Matplotlib
    - ggplot2
    - Seaborn

### 4. **SQL e Bancos de Dados**

- Aprender SQL
- Manipulação de Dados em SQL
- Trabalhar com Bancos de Dados

### 5. **Técnicas de Análise de Dados**

- [ ] organizar em funções

- Análise Descritiva
- Análise de Relações
- Testes de Hipóteses
- Análise de Correlação
- Análise de Regressão

### 6. **Visualização de Dados**

- Ferramentas e Técnicas
    - Tableau
    - Power BI
- Tipos de Gráficos
    - Gráficos de Barras
    - Histogramas
    - Gráficos de Linhas
    - Gráficos de Dispersão
    - Mapas de Calor
    - Gráficos de Funil

### 7. **Machine Learning**

- Conceitos Básicos
- Tipos de Aprendizado de Máquina
    - Aprendizado Supervisionado
    - Aprendizado Não Supervisionado
    - Aprendizado por Reforço
- Algoritmos Populares
    - Regressão Logística
    - Árvores de Decisão
    - KNN
    - Naive Bayes
    - Redes Neurais

### 8. **Big Data**

- Conceitos de Big Data
- Tecnologias de Armazenamento
    - Hadoop
    - Spark
- Processamento de Dados
    - MapReduce
    - Processamento Paralelo

### 9. **Projetos e Prática**

- Exemplo de Projetos
    - Previsão de Tendências de Vendas
    - Segmentação de Clientes
- Participar em Competições (Kaggle)

### 10. **Recursos Adicionais**

- Cursos e Certificações
- Plataformas de Aprendizado (Coursera, edX, Udemy, DataCamp)
- Networking e Comunidades

### 11. **Documentação e Compartilhamento**

- Compartilhar Progresso
- Acompanhar Progresso

### 12. **Relacionados**

- Roteiros Relacionados (Cientista de Dados, SQL, Python, PostgreSQL)
- Junte-se à Comunidade (Discord, GitHub)

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Significância.md
### Última modificação: 2025-01-09 20:58:03

---
tags: 
data: 2025-01-09
aliases: []
---


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\T teste.md
### Última modificação: 2025-01-09 00:07:33

---
tags:
  - Conceito
data: 2025-01-08
---
O **t-teste** é um teste estatístico usado para comparar médias de uma ou duas amostras e determinar se há uma diferença significativa entre elas, considerando a variabilidade dos dados e o tamanho da amostra.

## teste 
no caso de 5% de sgnificancia
![[Pasted image 20250109000729.png|400]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Teorema central do limite.md
### Última modificação: 2025-01-08 20:48:19

---
tags: 
data: 2025-01-08
aliases:
  - TCL
---
Quanto maior o tamanho da [[amostra]], mais a média da amostra tende a se aproximar da [[média]] verdadeira da [[população]], desde que a amostragem seja representativa e realizada de forma aleatória.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Tipos de variáveis.md
### Última modificação: 2024-09-03 22:21:55

---
tags:
  - DataAnalyst
data: 2024-09-03
nivel:
---
As variáveis ​​são características que podem variar entre indivíduos ou objetos em um conjunto de dados. Existem dois tipos principais de variáveis ​​em estatística descritiva:

![[Variáveis ​​Quantitativas]]

![[Variáveis ​​Qualitativas (ou Categóricas)]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Valor esperado = média.md
### Última modificação: 2025-01-08 20:15:55

---
tags: 
data: 2025-01-08
aliases: []
---
o [[valor esperado]] é a [[média]] de uma variável aleatória em termos probabilísticos. Ele representa o valor médio que se espera observar ao realizar infinitas repetições de um experimento.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Valor-p.md
### Última modificação: 2025-01-08 23:41:07

---
tags:
  - Conceito
data: 2025-01-08
---
O valor-p é a probabilidade de obter um resultado igual ou mais extremo que o observado, assumindo que a hipótese nula H0H_0H0​ é verdadeira.

Uma [[hipótese]] é uma suposição ou ideia que queremos testar usando dados.

A **hipótese nula ($H_0$​)** é a ideia padrão que assumimos como verdadeira até que os dados mostrem o contrário, geralmente dizendo que "não há efeito" ou "não há diferença".

Por exemplo:

- Hipótese: "Estudar 1 hora por dia melhora as notas."
- Hipótese nula ($H_0$​): "Estudar 1 hora por dia não faz diferença nas notas."

Testamos os dados para decidir se rejeitamos ou não a hipótese nula.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Variáveis discretas.md
### Última modificação: 2025-01-04 00:09:10

---
tags:
  - DataAnalyst
data: 2024-09-03
nivel:
---
Podem assumir apenas valores inteiros. 
Exemplos: número de filhos, número de carros em uma garagem.
Se da para pegar a média

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Variáveis ​​Contínuas.md
### Última modificação: 2024-12-31 01:30:38

---
tags:
  - DataAnalyst
data: 2024-09-03
nivel:
---
Podem assumir qualquer valor dentro de um intervalo. 
Exemplos: altura, peso, temperatura.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Variáveis ​​Nominais.md
### Última modificação: 2024-09-03 22:23:21

---
tags: 
data: 2024-09-03
nivel:
---
Não possuem uma [[Ordem|ordem]] natural. 
Exemplos: cor dos olhos, tipo de sangue.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Variáveis ​​Ordinais.md
### Última modificação: 2024-09-03 22:23:37

---
tags: 
data: 2024-09-03
nivel:
---
Possuem uma [[Ordem|ordem]] natural. 
Exemplos: nível de satisfação (baixo, médio, alto), classificação de filmes (ruim, bom, ótimo).


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Variáveis ​​Qualitativas (ou Categóricas).md
### Última modificação: 2024-09-03 22:21:47

---
tags: 
data: 2024-09-03
nivel:
---
![[Variáveis ​​Nominais]]
![[Variáveis ​​Ordinais]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Variáveis ​​Quantitativas.md
### Última modificação: 2024-12-31 01:30:52

---
tags:
  - DataAnalyst
data: 2024-09-03
nivel:
---
![[Variáveis ​​Contínuas]]
![[Variáveis discretas]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Variância.md
### Última modificação: 2025-01-07 00:03:50

---
tags:
  - Conceito
data: 2025-01-03
Link: https://www.youtube.com/watch?v=ar75_a8cxMk
aliases:
  - Variancia
---
A variância e a media dos [[Desvio médio absoluto|desvios]]. Ela mede o grau de dispersão ou espalhamento dos dados em relação à média.

### Formulas
$$Populacional = \frac{\sum_{i=1}^{n} (x_i - μ)^2}{n - 1}​$$$$Amostral = \frac{\sum_{i=1}^{n} (x_i - \bar{x})^2}{n - 1}​$$**Onde:** 
- $x_i - \bar{x}$: Cada valor do conjunto de dados. 
- $\bar{x}$: Média dos valores. 
- $n$: Número de itens no conjunto.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Visualização de dados.md
### Última modificação: 2024-08-25 19:53:00

---
tags:
  - DataAnalyst
data: 2024-08-25
nivel:
---
Essa prática é sobre transformar [[Dados brutos|dados brutos]] complexos em um formato [[Gráficos|gráficos]] que permite uma compreensão mais fácil de grandes conjuntos de [[Dados|dados]], [[Tendências|tendências]], [[Outliers|outliers]] e [[Padrões|padrões]] importantes.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Roadmap\Z-score.md
### Última modificação: 2025-01-06 21:32:34

---
tags: 
data: 2025-01-06
---
![[Pasted image 20250106212815.png|400]]
![[Pasted image 20250106213203.png]]
# Formula
$$z = \frac{z-μ}{σ}$$



### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Scikit-Learn\Comandos.md
### Última modificação: 2024-08-22 20:29:47

---
tags:
  - Programação
data: 2024-08-22
nivel:
---
### 1. **Pré-processamento de dados**:
#### Comandos
- `StandardScaler`: Normalização dos dados para média zero e desvio padrão unitário.
- `MinMaxScaler`: Escalonamento dos dados para um intervalo específico.
- `LabelEncoder`: Conversão de labels em números inteiros.
- `OneHotEncoder`: Codificação de variáveis categóricas em vetores binários.
- `train_test_split`: Separação de dados em conjuntos de treinamento e teste.
#### Exemplos
##### `StandardScaler`
``` python
from sklearn.preprocessing import Standard

Scaler
import numpy as np

# Criando um array de dados
X = np.array([[1, 2], [2, 3], [3, 4]])

# Instanciando o StandardScaler
scaler = StandardScaler()

# Ajustando e transformando os dados para média zero e desvio padrão unitário
X_scaled = scaler.fit_transform(X)

# Exibindo os dados escalonados
print(X_scaled)
```
```
[[-1.22474487 -1.22474487]
 [ 0.          0.        ]
 [ 1.22474487  1.22474487]]

```
##### `MinMaxScaler`
```python
from sklearn.preprocessing import MinMaxScaler

# Instanciando o MinMaxScaler para transformar os dados entre 0 e 1
scaler = MinMaxScaler()

# Ajustando e transformando os dados
X_scaled = scaler.fit_transform(X)

# Exibindo os dados escalonados
print(X_scaled)
```
```
[[0.  0. ]
 [0.5 0.5]
 [1.  1. ]]
```
##### `LabelEncoder`
```python
from sklearn.preprocessing import LabelEncoder

# Labels categóricas
y = ['dog', 'cat', 'dog', 'fish']

# Instanciando o LabelEncoder
encoder = LabelEncoder()

# Convertendo os labels para números inteiros
y_encoded = encoder.fit_transform(y)

# Exibindo os labels convertidos
print(y_encoded)
```
```
[1 0 1 2]
```
##### `OneHotEncoder`
```python
from sklearn.preprocessing import OneHotEncoder

# Convertendo para um array de colunas categóricas
y = np.array([['dog'], ['cat'], ['fish'], ['dog']])

# Instanciando o OneHotEncoder
encoder = OneHotEncoder(sparse=False)

# Convertendo em vetores binários
y_encoded = encoder.fit_transform(y)

# Exibindo a codificação binária
print(y_encoded)
```
```
[[0. 1. 0.]
 [1. 0. 0.]
 [0. 0. 1.]
 [0. 1. 0.]]
```
##### `train_test_split`
```python
from sklearn.model_selection import train_test_split

# Dados de exemplo
X = np.array([[1, 2], [2, 3], [3, 4], [4, 5]])
y = np.array([0, 1, 0, 1])

# Dividindo os dados em conjunto de treino e teste (80% treino, 20% teste)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Exibindo os dados de treino e teste
print("X_train:", X_train)
print("X_test:", X_test)
print("y_train:", y_train)
print("y_test:", y_test)
```
``` lua 
X_train: [[3 4]
          [1 2]
          [4 5]]
X_test: [[2 3]]
y_train: [0 0 1]
y_test: [1]

```
### 2. **Modelos de Classificação**:
#### Comandos
- `LogisticRegression`: Regressão logística para classificação binária ou multiclasse.
- `DecisionTreeClassifier`: Árvore de decisão para classificação.
- `RandomForestClassifier`: Conjunto de árvores de decisão para classificação.
- `SVC` (Support Vector Classifier): Máquina de vetores de suporte para classificação.
- `KNeighborsClassifier`: Classificador baseado em K-vizinhos mais próximos.
#### Exemplos
##### `LogisticRegression`


### 3. **Modelos de Regressão**:
#### Comandos
- `LinearRegression`: Regressão linear.
- `Ridge` e `Lasso`: Regressão linear com regularização (L2 e L1).
- `DecisionTreeRegressor`: Árvore de decisão para regressão.
- `RandomForestRegressor`: Conjunto de árvores de decisão para regressão.

### 4. **Validação e Otimização**:
#### Comandos
- `cross_val_score`: Validação cruzada para avaliar o desempenho do modelo.
- `GridSearchCV`: Busca de hiperparâmetros utilizando grade.
- `RandomizedSearchCV`: Busca aleatória de hiperparâmetros.
#### Exemplos

### 5. **Métricas de Avaliação**:
#### Comandos
- `accuracy_score`: Acurácia para classificação.
- `mean_squared_error`: Erro quadrático médio para regressão.
- `precision_score`, `recall_score`, `f1_score`: Métricas de precisão, recall e F1 para classificação.
- `roc_auc_score`: AUC-ROC para avaliar modelos binários.
#### Exemplos

### 6. **Algoritmos de Agrupamento (Clustering)**:
#### Comandos
- `KMeans`: Agrupamento baseado em centroides.
- `DBSCAN`: Agrupamento baseado em densidade.
#### Exemplos

### 7. **Pipeline**:
#### Comandos
- `Pipeline`: Combinação de várias etapas (pré-processamento e modelagem) em um fluxo contínuo.
#### Exemplos

### 8. **Redução de Dimensionalidade**:
#### Comandos
- `PCA` (Principal Component Analysis): Análise de componentes principais para redução de dimensionalidade.
#### Exemplos


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\'backticks'.md
### Última modificação: 2024-10-09 23:56:50

---
tags:
  - DataAnalyst
  - Datascience
data: 2024-10-09
---
Na declaração SQL, as aspas simples invertidas (backticks ` `` `) são usadas em torno dos nomes de _schemas_, tabelas ou colunas para evitar problemas com **nomes reservados** ou **caracteres especiais**. Aqui está o porquê de usá-las:

```mysql
CREATE TABLE `SELECT` (id INT);  -- SELECT é uma palavra reservada, então usamos backticks
```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Campos.md
### Última modificação: 2024-09-16 00:40:14

---
tags:
  - DataAnalyst
data: 2024-09-16
nivel:
---
Campos = colunas. É nos campos onde se define os [[Tipos de dados SQL|tipos dos dados no SQL]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Dados caracteres e strings.md
### Última modificação: 2024-09-13 20:35:08

---
tags:
  - DataAnalyst
data: 2024-09-12
nivel:
---
Tipos de dados de caracteres e [[String|strings]], como: `CHAR`, `VARCHAR`, `TEXT`, etc.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Dados Diversos.md
### Última modificação: 2024-12-31 01:27:56

---
tags:
  - DataAnalyst
data: 2024-09-11
nivel:
---
1. [[CLOB]] 
2. [[BLOB]]
3. [[XML]] 
4. [[CURSOR]]
5. [[TABLE]]
6. [[ARRAY]]

Esses tipos de [[Dados|dados]] proporcionam flexibilidade na forma como os dados são armazenados e manipulados, permitindo o gerenciamento eficiente de informações em diversas formas e tamanhos.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Dados sequência de Unicode.md
### Última modificação: 2024-12-31 01:28:00

---
tags:
  - DataAnalyst
data: 2024-09-11
nivel:
---
Os tipos de [[Dados|dados]] de sequência de caracteres [[Unicode]] são usados para armazenar texto em diversos idiomas e símbolos, garantindo que qualquer caractere possível em um conjunto de [[Caracter|caracteres]] Unicode possa ser representado. Aqui estão os principais tipos de dados de sequência de caracteres Unicode e suas características:

1. [[CHAR]] 
2. [[VARCHAR]] 
3. [[TEXT]]
4. [[NCHAR]]
5. [[NVARCHAR]]
6. [[NTEXT]]
7. [[TIMESTAMP]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Diferenças DML,DDL e DCL.md
### Última modificação: 2024-09-12 17:56:04

---
tags:
  - DataAnalyst
data: 2024-09-11
nivel:
---
Resumidamente, **[[Linguagem de Definição de Dados (DDL)|DDL]]** define a estrutura do banco, **[[Linguagem de Manipulação de Dados (DML)|DML]]** manipula os dados, e **[[Linguagem de Controle de Dados (DCL)|DCL]]** controla os acessos e permissões.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Different Types.md
### Última modificação: 2024-09-21 21:25:42

---
tags:
  - DataAnalyst
data: 2024-09-21
---
Table: Tabela em si
	Column: As colunas das tabelas
	Row: As linhas das tabelas
		Scalar: A célula em si.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Erro code 1175.md
### Última modificação: 2024-09-16 14:26:31

---
tags:
  - Erro
  - DataAnalyst
data: 2024-09-15
nivel:
---
O erro `Error Code: 1175. You are using safe update mode and you tried to update a table without a WHERE that uses a KEY column.` ocorre no [[MySQL]] quando o modo de atualização segura (`safe update mode`) está ativado. Esse modo impede a execução de comandos [[UPDATE]] ou [[DELETE]] sem uma condição que inclua uma chave de índice (como uma [[PRIMARY KEY]] ou [[UNIQUE]]), a fim de evitar atualizações ou exclusões acidentais em um grande número de registros.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Geral.md
### Última modificação: 2024-12-31 01:28:16

---
tags:
  - DataAnalyst
data: 2024-09-11
nivel:
---
![[SQL#^0bc9f7]]
[[Queries]]
[[Linguagem de Definição de Dados (DDL)]]
[[Linguagem de Manipulação de Dados (DML)]]
[[Linguagem de Controle de Dados (DCL)]]
	[[Diferenças DML,DDL e DCL]]


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Linguagem de Controle de Dados (DCL).md
### Última modificação: 2024-12-31 01:28:51

---
tags:
  - DataAnalyst
data: 2024-09-11
nivel:
---
A **Linguagem de Controle de Dados (DCL)** é um subconjunto do [[SQL]] utilizado para controlar os níveis de acesso e as permissões dos usuários em um [[Banco de dados|banco de dados]]. As principais operações da DCL são: [[GRANT]]; [[REVOKE]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Linguagem de Definição de Dados (DDL).md
### Última modificação: 2024-12-31 01:28:56

---
tags:
  - DataAnalyst
data: 2024-09-11
nivel:
---
A **Linguagem de Definição de Dados (DDL)** é um subconjunto de comandos do [[SQL]] utilizado para definir e gerenciar a estrutura de bancos de dados. Ela inclui comandos que permitem **criar, modificar e excluir [[Objetos SQL|objetos]]** no [[Banco de dados| banco de dados]], como tabelas, índices e esquemas. Os principais comandos DDL são: [[CREATE]]; [[ALTER]]; [[DROP]]; [[TRUNCATE]]...

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Linguagem de Manipulação de Dados (DML).md
### Última modificação: 2024-12-31 01:29:01

---
tags:
  - DataAnalyst
data: 2024-09-11
nivel:
---
A Linguagem de Manipulação de Dados (DML - Data Manipulation Language) é um subconjunto da [[SQL]] usado para **inserir, atualizar, deletar e recuperar** [[Dados|dados]] em um [[Banco de dados|banco de dados]] [[Banco de Dados Relacional|relacional]]. Comandos DML permitem interagir diretamente com os dados nas tabelas, sem alterar a estrutura do banco de dados. Os principais comandos DML são:[[INSERT INTO]]; [[UPDATE]]; [[DELETE]]; [[SELECT]]...

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Otimizar as consultas SQL.md
### Última modificação: 2024-09-26 23:09:10

---
tags:
  - DataAnalyst
data: 2024-09-26
---
### Escolher Tipos de Dados Adequados
Escolher tipos de dados apropriados para suas colunas pode reduzir o tamanho da tabela e melhorar a performance das consultas. Use sempre o menor tipo de dado que possa armazenar os valores esperados.

Por exemplo, se uma coluna só vai armazenar idades, use [[TINYINT]] ou [[SMALLINT]] em vez de [[INT]].
Para strings de tamanho limitado, use [[VARCHAR(50)]] em vez de [[TEXT]], pois o SQL terá menos trabalho para armazenar e manipular esses dados.
### Evitar `SELECT *`
Usar [[SELECT]] [[asterisco|*]] pode carregar mais dados do que o necessário, prejudicando a performance. Sempre selecione apenas as colunas necessárias:
```mysql
SELECT nome, salario FROM funcionarios WHERE salario > 10000;
```
Isso reduz a quantidade de dados que o SQL precisa processar, transferir e armazenar temporariamente.
### Filtragem e Limitação
Usar o comando [[WHERE]] para filtrar as linhas é essencial para evitar carregar mais dados do que o necessário. Além disso, o uso do [[LIMIT]] pode ser útil em casos em que você só precisa de um subconjunto dos resultados.
```mysql
SELECT nome FROM funcionarios WHERE salario > 10000 LIMIT 10;
```
Isso limita o número de linhas retornadas, evitando que o banco de dados tenha que processar toda a tabela.

### Usar JOINs com Critério de Filtragem Adequado
Quando utilizar JOINs, certifique-se de que eles sejam realizados com base em colunas que façam sentido. Um uso incorreto de [[JOIN]] pode levar a resultados muito grandes e desnecessários. Por exemplo:
```mysql
SELECT f.nome, d.departamento 
FROM funcionarios f 
JOIN departamentos d ON f.departamento_id = d.id 
WHERE d.nome = 'Financeiro';`
```
Aqui, estamos filtrando diretamente no JOIN com a cláusula WHERE, reduzindo o número de linhas processadas.

### Uso de Particionamento
Dividir grandes tabelas em partes menores pode ajudar a melhorar o desempenho. O particionamento divide fisicamente a tabela em várias partes menores, baseadas em um critério como datas, regiões ou outro valor relevante. O particionamento é especialmente útil para consultas que lidam com grandes volumes de dados.

Por exemplo, se você tiver uma tabela com vendas por ano, pode particioná-la por data, assim as consultas que buscam por um intervalo de anos específico serão mais rápidas.

### Normalização do Banco de Dados
Normalizar o banco de dados pode melhorar a eficiência, garantindo que não haja dados duplicados ou desnecessários. Uma boa prática de normalização divide dados em várias tabelas relacionadas, evitando redundâncias. Menos dados duplicados significa menos linhas para o SQL examinar durante uma consulta.

Por exemplo, ao invés de ter um campo de nome de departamento em cada linha da tabela funcionarios, você pode ter uma tabela separada para departamentos e referenciá-la usando JOIN, mantendo o banco de dados mais enxuto.
### Uso de Tabelas Temporárias
Tabelas temporárias podem ser usadas para armazenar dados intermediários durante a execução de consultas complexas, o que pode evitar o retrabalho de consultar várias vezes a mesma tabela.[[CREATE TEMPORARY TABLE]]
```mysql
CREATE TEMPORARY TABLE temp_vendas AS
SELECT * FROM vendas WHERE data_venda BETWEEN '2023-01-01' AND '2023-12-31';
```
A partir daí, você pode consultar a tabela temporária, que é mais rápida e evita o processamento repetido.


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Projetos.md
### Última modificação: 2024-08-31 01:14:26

---
tags:
  - Programação
  - Datascience
data: 2024-08-19
nivel:
---
# Mapeando as habilidades
As habilidades técnicas principais que serão analisadas em você são àquelas
relacionadas as diferentes etapas de um projeto de Ciência de Dados:
1. Entendimento do problema e do contexto de negócio
2. Aquisição dos dados
3. Limpeza dos dados
4. Análise Exploratória dos Dados
5. Manipulação dos dados: seleção, criação, formatação, agregação
6. Modelagem dos dados
7. Avaliação
8. Produção: DeDlov. relatório automático. manutenção e monitoramento.

# Exemplo de projetos

| Projeto                                                          | Habilidades Principais                                                     |
| ---------------------------------------------------------------- | -------------------------------------------------------------------------- |
| Previsão de vendas em varejo                                     | Modelagem dos dados, Avaliação                                             |
| Análise de sentimentos em redes sociais                          | Aquisição dos dados, Limpeza dos dados, Análise Exploratória dos Dados     |
| Detecção de fraudes em transações financeiras                    | Modelagem dos dados, Avaliação, Produção                                   |
| Classificação de imagens com redes neurais convolucionais        | Manipulação dos dados, Modelagem dos dados                                 |
| Previsão de séries temporais para preços de ações                | Análise Exploratória dos Dados, Modelagem dos dados                        |
| Análise de churn de clientes                                     | Entendimento do problema, Modelagem dos dados, Avaliação                   |
| Recomendações de produtos para e-commerce                        | Modelagem dos dados, Avaliação                                             |
| Clusterização de clientes para campanhas de marketing            | Manipulação dos dados, Análise Exploratória dos Dados, Modelagem dos dados |
| [[Previsão de demanda para cadeias de suprimentos]]              | Entendimento do problema, Modelagem dos dados                              |
| Sistema de recomendação de filmes                                | Modelagem dos dados, Manipulação dos dados                                 |
| Análise de sentimentos de reviews de produtos                    | Limpeza dos dados, Análise Exploratória dos Dados, Modelagem dos dados     |
| Segmentação de mercado com base em dados demográficos            | Análise Exploratória dos Dados, Manipulação dos dados                      |
| Detecção de anomalias em dados de sensores IoT                   | Aquisição dos dados, Modelagem dos dados                                   |
| Previsão de sobrevivência de pacientes com base em dados médicos | Entendimento do problema, Modelagem dos dados, Avaliação                   |
| Classificação de e-mails como spam ou não spam                   | Limpeza dos dados, Modelagem dos dados                                     |
| Sistema de pontuação de crédito para bancos                      | Modelagem dos dados, Avaliação                                             |
| Análise de redes sociais para influenciadores                    | Aquisição dos dados, Análise Exploratória dos Dados                        |
| Detecção de objetos em imagens para carros autônomos             | Modelagem dos dados, Manipulação dos dados                                 |
| Previsão de falhas em máquinas industriais                       | Modelagem dos dados, Avaliação                                             |
| Análise de padrões de compra para detecção de fraudes            | Limpeza dos dados, Modelagem dos dados                                     |
| Desenvolvimento de chatbot para atendimento ao cliente           | Modelagem dos dados, Produção                                              |
| Análise de causas de atrasos em projetos de construção           | Entendimento do problema, Análise Exploratória dos Dados                   |
| Visualização interativa de dados de COVID-19                     | Manipulação dos dados, Análise Exploratória dos Dados                      |
| Automatização de relatórios de desempenho financeiro             | Produção, Manipulação dos dados                                            |
| Previsão de preços de imóveis                                    | Modelagem dos dados, Avaliação                                             |
| Análise de dados de transações de criptomoedas                   | Aquisição dos dados, Análise Exploratória dos Dados                        |
| Detecção de plágio em textos acadêmicos                          | Limpeza dos dados, Modelagem dos dados                                     |
| Previsão de tempo de entrega de pedidos                          | Modelagem dos dados, Avaliação                                             |
| Sistema de recomendação para playlists de música                 | Modelagem dos dados, Manipulação dos dados                                 |
| Análise de dados meteorológicos para previsões climáticas        | Aquisição dos dados, Modelagem dos dados                                   |


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Qualificador de escopo.md
### Última modificação: 2024-10-10 00:04:13

---
tags:
  - DataAnalyst
  - Datascience
data: 2024-10-09
---
O **qualificador de escopo** no SQL é uma maneira de especificar a que objeto um nome se refere em um banco de dados, especialmente quando há múltiplos objetos com nomes iguais. Ele geralmente utiliza o ponto (`.`) para separar os componentes, como _[[SCHEMA|schema]]_ , _tabela_ e _coluna_.

### Estrutura Básica

A estrutura comum de um qualificador de escopo é:

- **schema**.**tabela**.**coluna**

### Exemplos:

1. **Qualificador de schema e tabela:**
    
    - Suponha que você tenha um _schema_ chamado `finance` e uma tabela chamada `Payroll`:
    
    
    ```mysql
    SELECT * FROM finance.Payroll;
    ```
    
    Aqui, `finance` é o _schema_ e `Payroll` é a tabela. O ponto (`.`) indica que você está acessando a tabela `Payroll` dentro do _schema_ `finance`.
    
2. **Qualificador de tabela e coluna:**
    
    - Agora, suponha que você queira selecionar uma coluna específica de uma tabela:

    ```mysql
    SELECT Payroll.EmployeeID FROM finance.Payroll;
    ```
    
    Neste caso, `Payroll` é a tabela e `EmployeeID` é a coluna. O qualificador de escopo é implícito porque você já especificou a tabela.
    
3. **Qualificador de schema, tabela e coluna:**
    
    - Se você quiser ser mais específico e deixar claro de qual _schema_ e tabela está acessando uma coluna:
        
    ```mysql
    SELECT finance.Payroll.EmployeeID FROM finance.Payroll;
    ```
    
    Aqui, você especifica o _schema_ (`finance`), a tabela (`Payroll`) e a coluna (`EmployeeID`).

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Queries.md
### Última modificação: 2024-12-31 01:29:46

---
tags:
  - DataAnalyst
data: 2024-09-11
nivel:
---
 Este é o componente que permite que você recupere [[Dados|dados]] de um[[Banco de dados| banco de dados]]. A instrução [[SELECT]] é mais comumente usada para esse propósito.


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\RDBMS.md
### Última modificação: 2024-12-31 01:29:51

---
tags:
  - DataAnalyst
data: 2024-09-11
nivel:
---
RDBMS (Relational Database Management System, ou Sistema de Gerenciamento de [[Banco de Dados Relacional]]) é um tipo de sistema de [[banco de dados]] que armazena dados em [[Tabelas]] com relacionamentos bem definidos entre elas. 
# Benefícios e limitações

### Benefícios de usar um RDBMS:

1. **Estruturação de Dados**:  
    O RDBMS armazena dados de forma estruturada, organizando-os em tabelas compostas por linhas e colunas. Isso facilita o armazenamento, recuperação e manipulação dos dados de maneira eficiente, utilizando a linguagem [[SQL]] (Structured Query Language). Essa organização também promove uma melhor compreensão e modelagem das informações.
    
2. **Propriedades [[ACID]]**:  
    ACID (Atomicidade, Consistência, Isolamento e Durabilidade) são propriedades fundamentais que garantem que as transações realizadas em um RDBMS sejam confiáveis e seguras. Essas propriedades são essenciais para aplicações que exigem alta integridade de dados, como sistemas bancários ou de e-commerce, onde falhas não podem ocorrer.
    
3. **Normalização**:  
    A normalização é uma prática que organiza os dados em tabelas de modo a reduzir a redundância e dependências. O RDBMS facilita esse processo, garantindo uma melhor integridade dos [[Dados|dados]] e otimização do espaço de armazenamento, além de reduzir inconsistências ao evitar duplicação de dados.
    
4. **Escalabilidade Vertical**:  
    RDBMSs geralmente oferecem boa escalabilidade vertical, permitindo adicionar mais recursos computacionais (como [[CPU]] e [[Memória|memória]]) ao sistema para lidar com o aumento de volume de dados e transações. Essa característica é valiosa para crescimento progressivo e consistente do sistema.
    
5. **Integridade dos Dados**:  
    Com mecanismos como chaves primárias, chaves estrangeiras, índices e restrições, o RDBMS assegura que os dados sejam precisos e coerentes. Esses mecanismos mantêm a integridade referencial e evitam erros como duplicações ou dados inválidos.
    
6. **Segurança**:  
    Os RDBMSs oferecem robustos mecanismos de segurança, como controle de acesso baseado em papéis, autenticação de usuários, [[Criptografia|criptografia]] de dados em repouso e em trânsito, e auditorias. Isso torna o RDBMS ideal para aplicações que lidam com informações sensíveis, como sistemas financeiros e de saúde.
    

### Limitações de usar um RDBMS:

1. **Complexidade de Gestão**:  
    Configurar, gerenciar e otimizar um RDBMS pode ser complexo, especialmente para grandes bases de dados. Requer habilidades especializadas em administração de banco de dados (DBA) e otimização de desempenho, o que pode aumentar os custos operacionais e a complexidade do projeto.
    
2. **Custo Alto**:  
    Além do custo de licenciamento, RDBMSs podem demandar altos investimentos em infraestrutura e equipe especializada. Soluções corporativas como [[Oracle]] e [[SQL Server]] são caras, especialmente à medida que o volume de dados e a necessidade de desempenho aumentam.
    
3. **Esquema Rígido**:  
    RDBMSs seguem um esquema de dados rígido, onde a estrutura das tabelas deve ser definida antecipadamente. Alterar o esquema pode ser um processo demorado e arriscado, especialmente em sistemas com grande quantidade de dados ou transações em tempo real.
    
4. **Inadequado para Dados Não Estruturados**:  
    RDBMSs não são a melhor escolha para lidar com dados não estruturados, como imagens, vídeos, documentos e grandes volumes de dados gerados por sensores IoT ou mídias sociais. Para esses casos, bancos de dados [[NoSQL]], que são mais flexíveis e otimizados para diferentes tipos de dados, são uma escolha mais apropriada.
    
5. **[[Escalabilidade Horizontal]] Limitada**:  
    RDBMSs não escalam facilmente de forma horizontal (adicionando mais servidores ao invés de aumentar os recursos de um único [[Servidor|servidor]]). Escalar horizontalmente pode ser complexo e caro, além de exigir arquiteturas mais sofisticadas e configurações avançadas para lidar com dados distribuídos.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\SCHEMA.md
### Última modificação: 2024-10-09 23:49:15

---
tags:
  - DataAnalyst
  - Datascience
data: 2024-10-09
---
Um _Schema_ em [[banco de dados]] é basicamente um **esqueleto ou estrutura organizacional** que define como os dados são organizados e como as tabelas, colunas, índices, visualizações, e outros elementos de um banco de dados estão inter-relacionados. Ele é como uma "camada de organização" que agrupa objetos de banco de dados sob um único nome.

### Principais conceitos sobre _Schema_:

1. **Organização de objetos do banco de dados:** Um _Schema_ agrupa elementos como:
    
    - [[Tabela]]
    - [[View]] (Visões)
    - Índices
    - Stored Procedures
    - [[Funções avançadas]]
    - Triggers
    
    Esses objetos são armazenados e organizados dentro do _Schema_.
    
2. **Separação lógica:** O _Schema_ permite que você divida logicamente objetos relacionados em um banco de dados. Isso é útil, por exemplo, para separar dados de diferentes aplicações ou ambientes (ex.: `public`, `finance`, `hr`).
    
3. **Segurança:** O _Schema_ também pode ser usado para gerenciar **permissões**. Por exemplo, diferentes usuários podem ter acesso a diferentes _Schemas_ dentro do mesmo banco de dados, garantindo que cada grupo de usuários acesse apenas o que precisa.

## Exemplo
```mysql
CREATE SCHEMA `new_schema` DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
```
#### Criar esquema

A declaração acima pode ser dividida em três partes para facilitar a compreensão:

1. O primeiro componente é o mais simples; ele cria um esquema e lhe dá um nome.
```mysql
CREATE SCHEMA `new_schema`
```

Defina a codificação de caracteres porque os símbolos usados ​​para a **linguagem humana são muito diversos**. Por exemplo, japonês e árabe terão sistemas de símbolos diferentes, então o software correspondente também tem muitos métodos de codificação de caracteres; definimos uma série [de codificação Unicode UTF-8](https://datatracker.ietf.org/doc/html/rfc3629) de 4 bytes de caracteres comuns aqui.

```mysql
DEFAULT CHARACTER SET utf8mb4
```

Terceiro ponto, na codificação de caracteres, também haverá alguns derivados. O exemplo aqui usa `utf8mb4_unicode_ci`, que é um derivado que pode usar símbolos relacionados a emojis. Isso é mostrado apenas como um exemplo aqui.
```mysql
COLLATE utf8mb4_unicode_ci;
```


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Sintaxe SQL.md
### Última modificação: 2024-12-31 01:30:02

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-11
nivel:
---
A sintaxe [[SQL]] básica consiste em comandos diretos que permitem que os usuários interajam com um [[Banco de Dados Relacional|banco de dados relacional]]. Os comandos principais :
[[SELECT]]
[[INSERT INTO]]
[[UPDATE]]
[[DELETE]]
[[WHERE]]
[[ORDER BY]]
[[JOIN]]. 
Esses comandos formam a base do [[SQL]] , permitindo manipulação e recuperação eficientes de dados em um [[Banco de dados|banco de dados]].

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\SQL vx NoSQL.md
### Última modificação: 2024-12-31 01:30:10

---
tags:
  - DataAnalyst
data: 2024-09-11
nivel:
---
[[Oracle]] [[MySQL]] [[SQL]] [[Dados]] [[Tabelas]] [[ACID]] [[MongoDB]] [[JSON]] [[Escalabilidade Horizontal]] [[IoT]]
<div style="display: flex;">
  <div style="flex: 1; padding: 10px; background-color: black; color: white;">
    <h3>Bancos de Dados NoSQL:</h3>
    <ul>
      <li><strong>Exemplos</strong>: MongoDB.</li>
      <li><strong>Linguagem</strong>: Não usam SQL; dados são armazenados em formatos flexíveis, como documentos JSON.</li>
      <li><strong>Estrutura de Dados</strong>: Adequado para dados não estruturados e semiestruturados.</li>
      <li><strong>Adequação</strong>: Ideal para aplicativos que exigem grande escalabilidade horizontal, como mídias sociais, IoT e grandes volumes de dados.</li>
      <li><strong>Vantagens</strong>:
        <ul>
          <li>Flexibilidade no armazenamento e manipulação de dados.</li>
          <li>Escalabilidade horizontal, facilitando a adição de mais servidores para lidar com grandes volumes de dados.</li>
        </ul>
      </li>
      <li><strong>Limitações</strong>:
        <ul>
          <li>Pode não oferecer suporte a transações ACID completas.</li>
          <li>Menor adequação para transações financeiras e outras aplicações que exigem alta consistência.</li>
        </ul>
      </li>
    </ul>
  </div>
  
  <div style="flex: 1; padding: 10px; background-color: black; color: white;">
    <h3>Bancos de Dados SQL:</h3>
    <ul>
      <li><strong>Exemplos</strong>: Oracle, MySQL.</li>
      <li><strong>Linguagem</strong>: Utilizam SQL (Structured Query Language) para gerenciar dados.</li>
      <li><strong>Estrutura de Dados</strong>: Dados estruturados são armazenados em tabelas relacionais (linhas e colunas).</li>
      <li><strong>Adequação</strong>: Ideal para transações complexas e aplicações que exigem conformidade regulatória.</li>
      <li><strong>Vantagens</strong>:
        <ul>
          <li>Suporte a transações ACID (Atomicidade, Consistência, Isolamento, Durabilidade).</li>
          <li>Estrutura rígida, garantindo a integridade e consistência dos dados.</li>
        </ul>
      </li>
      <li><strong>Limitações</strong>:
        <ul>
          <li>Menos flexíveis para mudanças no esquema de dados.</li>
          <li>Escalabilidade horizontal limitada (mais difícil de distribuir em múltiplos servidores).</li>
        </ul>
        
      </li>
      
    </ul>
  </div>
</div>


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\SQL.md
### Última modificação: 2024-12-31 01:30:06

---
tags:
  - DataAnalyst
data: 2024-09-11
nivel:
---
O SQL(linguagem de Consulta Estruturada ou Structured Query Language)  é uma linguagem de programação usada para: [[Consultar dados]], [[Inserir dados]], [[Atualizar dados]], [[Excluir dados]]  em sistemas de gerenciamento de [[Banco de Dados Relacional|banco de dados relacionais]] ([[RDBMS]]). ^0bc9f7

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\SSMS.md
### Última modificação: 2024-09-28 20:42:46

---
tags:
  - DataAnalyst
data: 2024-09-28
---
O **SQL Server Management Studio (SSMS)** é uma ferramenta de gerenciamento para SQL Server, desenvolvida pela Microsoft. Ele fornece uma interface gráfica (GUI) que permite gerenciar bancos de dados SQL Server, escrever consultas SQL, gerenciar a segurança, realizar backups, criar e modificar tabelas, armazenar procedimentos e realizar muitas outras tarefas de administração e desenvolvimento de banco de dados.
Uma [[IDE]] para servers de [[SQL]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Subquereies Aninhadas.md
### Última modificação: 2024-09-21 21:26:08

---
tags:
  - DataAnalyst
data: 2024-09-21
---
Uma subquery aninhada é uma consulta SQL **dentro** de outra consulta SQL. Ela funciona como um subconjunto de dados que é utilizado para filtrar, agrupar ou calcular valores na consulta principal.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Subquereies Correlacionadas.md
### Última modificação: 2024-09-21 21:25:12

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-21
---
Uma subquery correlacionada é uma subquery que se refere a uma tabela **externa** (a tabela da consulta principal) em sua cláusula WHERE. A subquery é executada para cada linha da tabela externa.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Subqueries.md
### Última modificação: 2024-09-21 21:25:51

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-21
---
No [[SQL]] é possível fazer consultas de outras consultas. Como em uma consulta achar todos que começam com A e depois todos que ganham mais que 3k.
![[Subquereies Correlacionadas]]
![[Subquereies Aninhadas]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Tipos de dados SQL.md
### Última modificação: 2024-12-31 01:30:29

---
tags:
  - DataAnalyst
data: 2024-09-11
nivel:
---
Os tipos de [[Dados|dados]] [[SQL]] definem o tipo de valor que pode ser armazenado em uma coluna de tabela
Se dividem em:
[[Dados numéricos]]
[[Dados data e hora]]
[[Dados caracteres e strings]]
[[Dados sequência de Unicode]]
[[Dados Binário]]
[[Dados Diversos]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Unicode.md
### Última modificação: 2024-12-31 01:30:34

---
tags:
  - DataAnalyst
data: 2024-09-11
nivel:
---
**Unicode** é um padrão internacional de codificação de [[Caracter|caracteres]] que visa fornecer uma representação única para cada caractere de todos os sistemas de escrita do mundo.
ex: UTF-8, UTF-16 e UTF-32.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Árvore balanceada.md
### Última modificação: 2024-09-26 20:59:11

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-26
---
Os índices no [[SQL]] funcionam de maneira semelhante ao índice de um livro. Eles permitem que o banco de dados localize rapidamente os dados sem precisar percorrer todas as linhas de uma tabela. Quando você cria um índice, ele é estruturado em algo parecido com uma **árvore balanceada** (geralmente uma árvore B).

|ID|Nome|Salário|
|---|---|---|
|1|João|8.000,00|
|2|Maria|12.000,00|
|3|Carlos|6.000,00|
|4|Fernanda|18.000,00|
|5|Gustavo|9.500,00|
 ```css
       [9.000]
     /        \
[6.000]      [12.000]
 /   \        /     \
...  ...    ...    [18.000]

```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\00\Coisas para juntar.md
### Última modificação: 2024-10-23 22:36:39

[[HAVING]] [[SUM()]][[Função de agregação]][[Normalização]][[UNION]][[UNION ALL]][[Expressão literal]] [[Operador de concatenação]] [[OFFSET]][[Discretização]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\ABS.md
### Última modificação: 2024-10-23 01:06:45

---
tags:
  - Comando
  - DataAnalyst
data: 2024-09-23
---
A função `ABS` (abreviação de "absolute") no SQL é utilizada para **calcular o valor absoluto** de um número. É o [[Módulo]] no SQL

| id_transacao | valor_transacao |
| ------------ | --------------- |
| 1            | -150.00         |
| 2            | 200.00          |
| 3            | -75.50          |

```sql
SELECT 
    id_transacao, 
    ABS(valor_transacao) AS valor_absoluto
FROM 
    transacoes;
```

| id_transacao | valor_absoluto |
| ------------ | -------------- |
| 1            | 150.00         |
| 2            | 200.00         |
| 3            | 75.50          |

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\ADD.md
### Última modificação: 2024-09-15 23:34:25

---
tags:
  - Comando
  - DataAnalyst
data: 2024-09-15
nivel:
---
O comando `ADD` no SQL é usado em conjunto com o comando `ALTER TABLE` para **adicionar uma nova coluna**, **chave** ou **restrição** a uma tabela já existente. Ele permite que você modifique a estrutura de uma tabela sem precisar recriá-la.

notas: [[ALTER]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\ALTER.md
### Última modificação: 2024-09-13 20:44:35

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-13
nivel:
---
O comando `ALTER` altera algo por exemplo: `ALTER TABLE` altera uma tabela.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\AND.md
### Última modificação: 2024-09-17 19:04:11

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-17
nivel:
---
O operador **`AND`** em SQL é usado para combinar múltiplas condições em uma consulta. Ele retorna os registros que satisfazem **todas** as condições especificadas.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\AS.md
### Última modificação: 2024-09-19 20:17:36

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-16
nivel:
---
O comando `AS` em SQL é usado para **atribuir um alias** a uma coluna ou tabela, facilitando a leitura e a compreensão dos resultados de uma consulta. O alias é um nome alternativo temporário que pode ser usado para tornar as consultas mais claras e os resultados mais intuitivos.
vem junto do [[SELECT]]

```sql
SELECT CustomerID AS ID, CustomerName AS [Customer name]  
FROM Customers;
```
Selecione o ID do Cliente (CustomerID) como ID, e o Nome do Cliente (CustomerName) como Nome do Cliente ([Customer name]), a partir da tabela Clientes (Customers).

```sql
SELECT CustomerName, Address + ', ' + PostalCode + ' ' + City + ', ' + Country AS Address
FROM Customers;
```
Selecione o Nome do Cliente (CustomerName) e concatene o Endereço (Address), seguido por uma vírgula, o Código Postal (PostalCode), um espaço, a Cidade (City), uma vírgula e o País (Country) como Endereço (Address), a partir da tabela Clientes (Customers).

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\ASC.md
### Última modificação: 2024-09-16 21:20:02

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-16
nivel:
---
Ordena em ordem crescente (essa é a ordem padrão, então você pode deixar de escrever `ASC`).

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\asterisco.md
### Última modificação: 2024-09-13 20:50:45

---
tags:
  - Comando
  - DataAnalyst
data: 2024-09-13
nivel:
---
O `*` serve para referenciar todos.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\BETWEEN.md
### Última modificação: 2024-09-19 19:50:49

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-16
nivel:
---
```sql
SELECT * FROM brinquedos 
WHERE preco BETWEEN 20 AND 50;
```
Aqui, ele busca todos os brinquedos que custam **entre 20 e 50**.

```sql
SELECT * FROM Products  
WHERE ProductName BETWEEN 'Carnarvon Tigers' AND 'Mozzarella di Giovanni'  
ORDER BY ProductName;
```
A seguinte instrução SQL seleciona todos os produtos com um ProductName em ordem alfabética entre Carnarvon Tigers e Mozzarella di Giovanni

```sql
SELECT * FROM Orders  
WHERE OrderDate BETWEEN #07/01/1996# AND #07/31/1996#;
```
também funciona com datas e com [[NOT]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\CASE.md
### Última modificação: 2024-10-23 00:33:54

---
tags:
  - Comando
  - DataAnalyst
data: 2024-09-23
---
A expressão `CASE` no SQL é uma estrutura de controle que permite realizar **condições lógicas** dentro de consultas. [[SE]] do excel

## Forma simples

```mysql
CASE campo
    WHEN valor1 THEN resultado1
    WHEN valor2 THEN resultado2
    ...
    ELSE resultado_padrao
END
```
### EX
|id_produto|nome_produto|categoria_id|
|---|---|---|
|1|Camisa|1|
|2|Calça|2|
|3|Boné|1|

```SQL
SELECT 
    nome_produto,
    CASE categoria_id
        WHEN 1 THEN 'Vestuário'
        WHEN 2 THEN 'Acessórios'
        ELSE 'Outra Categoria'
    END AS categoria
FROM 
    produtos;
```

|nome_produto|categoria|
|---|---|
|Camisa|Vestuário|
|Calça|Acessórios|
|Boné|Vestuário|
## Forma de busca
```mysql
CASE 
    WHEN condição1 THEN resultado1
    WHEN condição2 THEN resultado2
    ...
    ELSE resultado_padrao
END
```
### EX
|id_funcionario|nome|salario|
|---|---|---|
|1|Ana|5000|
|2|Bruno|3000|
|3|Carlos|7000|
```mysql
SELECT 
    nome,
    salario,
    CASE 
        WHEN salario < 3000 THEN 'Baixo'
        WHEN salario BETWEEN 3000 AND 6000 THEN 'Médio'
        ELSE 'Alto'
    END AS classificacao
FROM 
    funcionarios;
```
| nome   | salario | classificacao |
| ------ | ------- | ------------- |
| Ana    | 5000    | Médio         |
| Bruno  | 3000    | Médio         |
| Carlos | 7000    | Alto          |

![[Pasted image 20241023003353.png]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\CEILING.md
### Última modificação: 2024-09-23 21:17:08

---
tags:
  - Comando
  - DataAnalyst
data: 2024-09-23
---
Essa função é usada em SQL para arredondar um número para cima, retornando o menor inteiro que é maior ou igual ao número especificado.

|id_produto|preco|
|---|---|
|1|10.50|
|2|20.75|
|3|15.99|

```sql
SELECT 
    preco,
    CEIL(preco) AS preco_arredondado
FROM 
    produtos;
```

|preco|preco_arredondado|
|---|---|
|10.50|11|
|20.75|21|
|15.99|16|

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\CHECK.md
### Última modificação: 2024-09-20 23:08:25

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-20
---
Define condições que os valores de uma coluna devem atender.
```sql
CREATE TABLE produtos (
    id INT PRIMARY KEY,
    nome VARCHAR(100) NOT NULL,
    preco DECIMAL(10, 2) CHECK (preco >= 0),
    quantidade INT CHECK (quantidade >= 0)
);
```
Comandos: [[INT]], [[CREATE]], [[TABLE]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\COALESCE.md
### Última modificação: 2024-09-25 14:24:11

---
tags:
  - Comando
  - DataAnalyst
data: 2024-09-24
---
O `COALESCE` é uma função no SQL que retorna o primeiro valor **não nulo** em uma lista de argumentos.
```mysql
COALESCE(valor1, valor2, valor3, ...)
```

| id_funci | nome        | telefone_comerc | telefone_residencial | telefone_celular |
| -------- | ----------- | --------------- | -------------------- | ---------------- |
| 1        | João Silva  |                 | NULL                 | (21) 99999-1234  |
| 2        | Maria Souza | (21) 3456-7890  | NULL                 | NULL             |
| 3        | Ana Lima    | NULL            | (21) 2345-6789       | (21) 98765-4321  |
| 4        | Pedro Alves | NULL            | NULL                 | NULL             |
```mysql
SELECT nome, 
       COALESCE(telefone_comercial, telefone_residencial, telefone_celular) AS telefone_contato
FROM funcionarios;
```
| nome        | telefone_contato |
| ----------- | ---------------- |
| João Silva  | (21) 99999-1234  |
| Maria Souza | (21) 3456-7890   |
| Ana Lima    | (21) 2345-6789   |
| Pedro Alves | NULL             |

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\CONCAT.md
### Última modificação: 2024-10-12 20:54:55

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-21
---
# Exemplo de Uso do CONCAT no SQL

## Tabelas

`clientes`

| id_cliente | nome       | sobrenome   |
|------------|------------|-------------|
| 1          | João       | Silva       |
| 2          | Maria      | Oliveira     |
| 3          | Pedro      | Santos      |
`pedidos`

| id_pedido | id_cliente | produto     |
|-----------|------------|-------------|
| 101       | 1          | Produto A   |
| 102       | 2          | Produto B   |
| 103       | 1          | Produto C   |

## Consulta SQL

Para concatenar o nome e o sobrenome dos clientes, você pode usar a função `CONCAT`:

```mysql
SELECT 
    id_cliente,
    CONCAT(nome, ' ', sobrenome) AS nome_completo
FROM 
    clientes;
```

|id_cliente|nome_completo|
|---|---|
|1|João Silva|
|2|Maria Oliveira|
|3|Pedro Santos|

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\Consultas Agregadas.md
### Última modificação: 2024-09-20 23:10:42



### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\COUNT().md
### Última modificação: 2024-09-18 21:00:02

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-18
nivel:
---
conta quantas celulas existem:
`COUNT(*)` nula ou não nula. 
`COUNT(NameColumn)` não nulo.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\COUNT.md
### Última modificação: 2024-09-16 01:25:55

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-16
nivel:
---
O comando `COUNT` em SQL é uma função agregada que retorna o número de linhas que correspondem a uma condição específica. Ele é usado para contar o número de registros em uma tabela, ou o número de valores não nulos em uma coluna específica.

aqui usando o [[DISTINCT]] ele retorna quantas vezes apareceram valores distintos.
``` sql
SELECT COUNT(DISTINCT salario)
FROM funcionarios;
```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\CREATE INDEX.md
### Última modificação: 2024-09-21 00:35:49

---
tags:
  - DataAnalyst
  - Comando
  - Perfomace
  - Optmização
data: 2024-09-21
Link: https://www.youtube.com/watch?v=fsG1XaZEa78
---
O comando `CREATE INDEX` em SQL é usado para criar um índice em uma ou mais colunas de uma tabela. Um índice melhora a **performance** das consultas, permitindo que o banco de dados localize dados mais rapidamente sem precisar varrer toda a tabela.

### O que é um Índice?

Um índice funciona como um **índice em um livro**. Em vez de percorrer todas as páginas para encontrar um assunto específico, você consulta o índice do livro, que te direciona diretamente à página certa. Em SQL, o índice faz a mesma coisa, facilitando a busca por dados em uma tabela.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\CREATE TEMPORARY TABLE.md
### Última modificação: 2024-10-03 00:33:20

---
tags:
  - Comando
  - DataAnalyst
data: 2024-09-26
---
CREATE TEMPORARY TABLE é um comando SQL usado para criar uma tabela temporária que existe apenas durante a sessão atual do seu banco de dados. Quando a sessão termina (você se desconecta do banco de dados), a tabela temporária é automaticamente excluída.

```mysql
CREATE TEMPORARY TABLE nome_da_tabela (
    coluna1 tipo_de_dado [restrições],
    coluna2 tipo_de_dado [restrições],
    ...
);
```

| id  | nome_bike   | preco | ... |
| --- | ----------- | ----- | --- |
| 1   | Bicicleta A | 1000  | ... |
| 2   | Bicicleta B | 1500  | ... |
| 3   | Bicicleta C | 800   | ... |


| id  | produto_id | quantidade | ... |
| --- | ---------- | ---------- | --- |
| 1   | 1          | 2          | ... |
| 2   | 2          | 1          | ... |
| 3   | 1          | 3          | ... |
| 4   | 3          | 2          | ... |

```mysql
CREATE TEMPORARY TABLE temp_total_vendas (
  produto_id INT,
  total_vendas DECIMAL(10,2)
);
INSERT INTO temp_total_vendas (produto_id, total_vendas)
SELECT produto_id, SUM(quantidade) * p.preco  -- Calculando o total de vendas
FROM vendas v
JOIN produtos p ON v.produto_id = p.id       -- Juntando as tabelas 'vendas' e 'produtos'
GROUP BY produto_id;                        -- Agrupando por 'produto_id'
```

| produto_id | total_vendas |
| ---------- | ------------ |
| 1          | 5000         |
| 2          | 1500         |
| 3          | 1600         |


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\CREATE VIEW.md
### Última modificação: 2024-09-28 21:42:21

---
tags:
  - Comando
  - DataAnalyst
data: 2024-09-24
---
O comando `CREATE VIEW` no [[SQL]] é utilizado para criar uma "visão" ou uma "tabela virtual" a partir de uma consulta específica. Uma _view_ não armazena os dados fisicamente, mas exibe resultados de uma consulta que pode combinar, filtrar, ou calcular dados de uma ou mais tabelas.

```mysql
CREATE VIEW nome_da_view AS
SELECT colunas
FROM tabela
WHERE condição;
```

|id_funcionario|nome|departamento|salario|
|---|---|---|---|
|1|Ana|RH|5000.00|
|2|Carlos|TI|7000.00|
|3|Maria|Financeiro|6000.00|
```mysql
CREATE VIEW view_alta_renda AS
SELECT nome, departamento, salario
FROM funcionarios
WHERE salario > 6000;
SELECT * FROM view_alta_renda;
```
|nome|departamento|salario|
|---|---|---|
|Carlos|TI|7000.00|


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\CREATE.md
### Última modificação: 2024-09-21 20:37:39

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-12
nivel:
---
O `CREATE` cria coisas no [[Banco de dados]] inclusive um banco de dados.
[[CREATE TEMPORARY TABLE]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\CROSS JOIN.md
### Última modificação: 2024-09-21 20:13:39

---
tags:
  - Comando
  - DataAnalyst
data: 2024-09-21
---
multiplicar tabelas

|ID_A|Nome|
|---|---|
|1|Ana|
|2|Bruno|
|3|Carla|

|ID_B|Produto|
|---|---|
|1|Maçã|
|2|Banana|
|3|Laranja|
|4|Abacaxi|
```sql
SELECT * FROM TabelaA CROSS JOIN TabelaB;
```
|ID_A|Nome|ID_B|Produto|
|---|---|---|---|
|1|Ana|1|Maçã|
|1|Ana|2|Banana|
|1|Ana|3|Laranja|
|1|Ana|4|Abacaxi|
|2|Bruno|1|Maçã|
|2|Bruno|2|Banana|
|2|Bruno|3|Laranja|
|2|Bruno|4|Abacaxi|
|3|Carla|1|Maçã|
|3|Carla|2|Banana|
|3|Carla|3|Laranja|
|3|Carla|4|Abacaxi|

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\CRUD.md
### Última modificação: 2024-09-16 21:18:04

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-13
nivel:
---
| Operação | Sgnficado  | Descrição              | Comando SQL |
| -------- | ---------- | ---------------------- | ----------- |
| **C**    | **C**reate | **Criar** uma tabela   | [[INSERT INTO]]  |
| **R**    | **R**ead   | **Ler** uma tabela     | [[SELECT]]  |
| **U**    | **U**ptate | **Atualizar** a tabela | [[UPDATE]]  |
| **D**    | **D**elete | **Deletar** uma tabela | [[DELETE]]  |


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\DATE.md
### Última modificação: 2024-09-24 19:38:28

---
tags:
  - Comando
  - DataAnalyst
data: 2024-09-15
nivel:
---
O comando `DATE` no [[SQL]] é usado para trabalhar com valores do tipo **data**. Ele permite representar e manipular datas em formatos padronizados. O tipo de dados `DATE` armazena informações como ano, mês e dia (geralmente no formato `YYYY-MM-DD`).
``` SQL
CREATE TABLE pessoas (
	id INT primary KEY auto_increment NOT NULL,
    nome VARCHAR(100),
    salario int,
    data_nascimento DATE
)
```

|id_pedido|data_hora_pedido|cliente|valor_total|
|---|---|---|---|
|1|2023-09-01 14:30:00|João|150.00|
|2|2023-09-02 16:15:00|Maria|200.00|
|3|2023-09-03 11:00:00|Pedro|175.00|
|4|2023-09-04 18:45:00|Ana|300.00|

```mysql
SELECT id_pedido, DATE(data_hora_pedido) AS data_pedido, cliente, valor_total
FROM pedidos;
```

|id_pedido|data_pedido|cliente|valor_total|
|---|---|---|---|
|1|2023-09-01|João|150.00|
|2|2023-09-02|Maria|200.00|
|3|2023-09-03|Pedro|175.00|
|4|2023-09-04|Ana|300.00|

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\DATEADD.md
### Última modificação: 2024-09-23 21:13:37

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-23
---
A função `DATEADD` no SQL é usada para **adicionar um intervalo de tempo a uma data**.
 ```sql
 DATEADD(intervalo, valor, data)
```
**intervalo**: A parte da data que você deseja modificar (por exemplo, `YEAR`, `MONTH`, `DAY`, `HOUR`, `MINUTE`, `SECOND`).

# Ex

|id_encomenda|data_pedido|
|---|---|
|1|2024-09-23|
|2|2024-09-30|
|3|2024-10-05|

```sql
SELECT 
    id_encomenda,
    data_pedido,
    DATEADD(DAY, 7, data_pedido) AS data_entrega
FROM 
    encomendas;
```

|id_encomenda|data_pedido|data_entrega|
|---|---|---|
|1|2024-09-23|2024-09-30|
|2|2024-09-30|2024-10-07|
|3|2024-10-05|2024-10-12|


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\DATEPART.md
### Última modificação: 2024-09-23 21:11:24

---
tags:
  - Comando
  - DataAnalyst
data: 2024-09-23
---
A função `DATEPART` no SQL é utilizada para **extrair partes específicas de uma data**, como ano, mês, dia, hora, minuto, segundo, etc. `YEAR`, `MONTH`, `DAY`, `HOUR`, `MINUTE`, `SECOND`

```sql
DATEPART(part, campo_data)
```

|id_venda|data_venda|
|---|---|
|1|2023-09-23 14:35:20|
|2|2024-01-15 09:12:45|
|3|2022-06-30 18:00:00|

```sql
SELECT 
    id_venda, 
    DATEPART(YEAR, data_venda) AS ano_venda
FROM 
    vendas;
```

|id_venda|ano_venda|
|---|---|
|1|2023|
|2|2024|
|3|2022|

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\DEFAULT.md
### Última modificação: 2024-09-21 00:03:30

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-21
---
A cláusula `DEFAULT` em SQL é usada para definir um valor padrão para uma coluna em uma tabela.

```SQL
CREATE TABLE clientes (
    id INT PRIMARY KEY,
    nome VARCHAR(100) NOT NULL,
    cidade VARCHAR(100),
    status VARCHAR(20) DEFAULT 'ativo'
);
```


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\DELETE ou DROP VIEW.md
### Última modificação: 2024-09-25 21:26:12

---
tags:
  - Comando
  - DataAnalyst
data: 2024-09-25
---
A instrução [[DROP VIEW]] é usada para remover completamente uma visualização, incluindo sua definição e permissões associadas. Por outro lado, a instrução [[DELETE]] pode ser usada para remover registros específicos de uma visualização, refletindo essas alterações na tabela base correspondente. É importante notar que ao deletar registros de uma visualização, os registros correspondentes na tabela base também são afetados.



### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\DELETE.md
### Última modificação: 2024-10-20 00:56:29

---
tags:
  - Comando
  - DataAnalyst
data: 2024-09-15
nivel:
---
```mysql
DELETE FROM clientes
WHERE cidade = 'São Paulo';
```
**Nunca** usar sem [[WHERE]].

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\DESC.md
### Última modificação: 2024-09-16 21:20:21

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-16
nivel:
---
 Ordena em ordem decrescente.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\DISTINCT.md
### Última modificação: 2024-10-10 23:59:36

---
tags:
  - DataAnalyst
  - Comando
data: 2024-04-28
nivel: 
Link:
---
O comando `DISTINCT` em SQL é usado para remover duplicatas dos resultados de uma consulta. Ele garante que os valores retornados em uma coluna ou conjunto de colunas sejam únicos, ou seja, não contenham repetições.

```mysql
SELECT DISTINCT Cidade FROM Clientes;
```
O `DISTINCT` pode ser aplicado a uma ou mais colunas na cláusula [[SELECT]] para garantir que apenas linhas distintas sejam retornadas.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\DOD.md
### Última modificação: 2024-10-02 15:30:26

---
tags:
  - DataAnalyst
  - Comando
  - Datascience
data: 2024-10-02
---
### Tipos de DOD

- **DOD Tipo 1** : Os dados são um suporte para as decisões, mas a intuição humana ainda tem grande influência.
- **DOD Tipo 2** : Os dados são o fator determinante nas decisões, muitas vezes usando métodos automatizados ou complexos para analisar as informações e gerar decisões de forma quase autônoma.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\DROP VIEW.md
### Última modificação: 2024-09-25 21:21:55

---
tags:
  - Comando
  - DataAnalyst
data: 2024-09-25
---
O comando `DROP VIEW`é utilizado para remover uma _visualização_ existente no banco de dados.

| id_funcional | nome   | salário | departamento |
| ------------ | ------ | ------- | ------------ |
| 1            | Carlos | 5000,00 | TI           |
| 2            | Ana    | 6000,00 | Vendas       |
| 3            | Pedro  | 5500,00 | TI           |
| 4            | Sófia  | 7000,00 | Marketing    |
| 5            | João   | 4000,00 | Vendas       |
```mysql
CREATE VIEW view_alta_renda AS
SELECT id_funcionario, nome, salario
FROM funcionarios
WHERE salario > 5000;
```
|id_funcional|nome|salário|
|---|---|---|
|2|Ana|6000,00|
|4|Sófia|7000,00|
```mysql
DROP VIEW view_alta_renda;
```
deletando o view


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\DROP.md
### Última modificação: 2024-09-13 20:42:37

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-12
nivel:
---
O `DROP` exclui coisas no [[Banco de dados]] inclusive um banco de dados.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\FLOOR.md
### Última modificação: 2024-09-23 22:29:47

---
tags:
  - Comando
  - DataAnalyst
data: 2024-09-23
---
A função `FLOOR` no SQL é utilizada para **arredondar um número para baixo** até o inteiro mais próximo. É o [[CEILING]] ao contrario 

|id_produto|preco|
|---|---|
|1|10.99|
|2|5.50|
|3|20.75|

```sql
SELECT 
    preco, 
    FLOOR(preco) AS preco_arredondado
FROM 
    precos;
```

|preco|preco_arredondado|
|---|---|
|10.99|10|
|5.50|5|
|20.75|20|

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\FOREIGN KEY.md
### Última modificação: 2024-10-12 23:34:26

---
tags:
  - Comando
  - DataAnalyst
data: 2024-09-16
nivel:
---
A `FOREIGN KEY` (chave estrangeira) no SQL é uma **restrição** que estabelece um relacionamento entre duas tabelas. Ela é usada para garantir a **integridade referencial** dos dados, ou seja, assegurar que os valores em uma coluna (ou conjunto de colunas) correspondam a valores existentes em outra tabela.

tabela clientes                                   tabela data

| cliente_id | nome           | \|  | pedido_id | cliente_id | data_pedido |
| ---------- | -------------- | :-: | --------- | ---------- | ----------- |
| 1          | Carlos Silva   | \|  | 1001      | 1          | 2024-09-15  |
| 2          | Maria Oliveira | \|  | 1002      | 2          | 2024-09-16  |
| 3          | João Santos    | \|  | 1003      | 1          | 2024-09-17  |
vem junto com: [[CREATE]][[TABLE]]
# ex
```mysql
SELECT Pedidos.pedido_id, Pedidos.data_pedido, Pedidos.valor, Clientes.nome
FROM Pedidos
JOIN Clientes ON Pedidos.cliente_id = Clientes.cliente_id;
```

|pedido_id|data_pedido|valor|nome|
|---|---|---|---|
|101|2024-01-10|100.50|João|
|102|2024-01-11|200.75|Maria|

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\FULL (OUTER) JOIN.md
### Última modificação: 2024-09-20 19:10:59

---
tags:
  - Comando
  - DataAnalyst
data: 2024-09-19
nivel:
---
## Tabelas
Tabela `Customers` (Clientes)

|CustomerID|CustomerName|City|
|---|---|---|
|1|Alice Smith|New York|
|2|Bob Johnson|Chicago|
|3|Charlie Brown|San Francisco|
|4|David Lee|Miami|

Tabela `Orders` (Pedidos)

|OrderID|OrderDate|CustomerID|ProductName|
|---|---|---|---|
|1001|2024-09-10|1|Laptop|
|1002|2024-09-12|2|Phone|
|1003|2024-09-13|1|Mouse|
|1004|2024-09-14|5|Keyboard|
## Comando
```sql
SELECT Customers.CustomerID, Customers.CustomerName, Orders.OrderID, Orders.ProductName
FROM Customers
FULL JOIN Orders ON Customers.CustomerID = Orders.CustomerID;
```
Selecione as tabelas.colunas: `Customers.CustomerID, Customers.CustomerName, Orders.OrderID, Orders.ProductName` de uma junção completa nas tabelas `Customers` e `Orders`, levando a coluna `CustomerID` como base de referência.

| CustomerID | CustomerName  | OrderID | ProductName |
| ---------- | ------------- | ------- | ----------- |
| 1          | Alice Smith   | 1001    | Laptop      |
| 1          | Alice Smith   | 1003    | Mouse       |
| 2          | Bob Johnson   | 1002    | Phone       |
| 3          | Charlie Brown | NULL    | NULL        |
| 4          | David Lee     | NULL    | NULL        |
| NULL       | NULL          | 1004    | Keyboard    |

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\Funções avançadas.md
### Última modificação: 2024-10-15 21:07:58

---
tags:
  - Comando
  - DataAnalyst
  - Resumo
data: 2024-09-21
aliases:
  - Funções
  - funções
---
[[SQL]]
## Função para strings
As funções para strings em SQL são úteis para manipulação de textos. O comando [[CONCAT]] permite **combinar** várias strings em uma única, enquanto [[SUBSTRING]] extrai uma parte **específica** de uma string com base na posição e no tamanho. O comando [[UPPER]] transforma todas as letras em **maiúsculas**, enquanto [[LOWER]] faz o oposto, convertendo-as para **minúsculas**. O [[LENGTH]] retorna o **número de caracteres** em uma string, e o [[REPLACE]] **substitui** parte de uma string por outro valor especificado.
## Função para  data e tempo.
As funções para data e tempo ajudam a manipular e extrair informações de datas e horários. O comando [[DATE]] retorna apenas a **parte da data** de um valor de data e hora completo, enquanto o [[TIME]] retorna apenas o **horário**. O [[TIMESTAMP]] armazena ambos, **data e hora**, no mesmo campo. A função [[DATEPART]] permite extrair uma parte **específica** de uma data, como ano, mês ou dia, e o [[DATEADD]] é usado para **adicionar** ou **subtrair** uma quantidade de tempo específica a uma data.
## Funções numéricas
As funções numéricas permitem realizar operações matemáticas e arredondamentos. O comando [[CEILING]] retorna o menor número inteiro **maior** ou igual a um valor específico, enquanto [[FLOOR]] retorna o maior número inteiro **menor** ou igual ao valor. O [[ROUND]] **arredonda** um número para o número de casas decimais especificado. O comando [[ABS]] retorna o valor absoluto(**módulo**[[Módulo|]]) de um número, removendo o sinal negativo se existir, e o [[MOD]] retorna o **resto** de uma divisão entre dois números.
## Funções Condicionais.
As funções condicionais ajudam a lidar com lógica em consultas. O comando [[CASE]] permite criar instruções **condicionais** que retornam diferentes valores com base em certas condições. O [[NULLIF]] compara dois valores e retorna [[NULL]] se eles forem **iguais**. O [[COALESCE]] retorna o **primeiro valor** não nulo de uma lista de valores, sendo útil para tratar valores ausentes.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\Funções de agregação SQL.md
### Última modificação: 2024-09-18 20:29:24

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-18
nivel:
---
Funções agregadas são frequentemente usadas com a [[GROUP BY]] cláusula da [[SELECT]] declaração. A `GROUP BY`cláusula divide o conjunto de resultados em grupos de valores e a função agregada pode ser usada para retornar um único valor para cada grupo.

As funções de agregação SQL mais comumente usadas são:

- [[MIN()]]- retorna o menor valor dentro da coluna selecionada
- [[MAX()]]- retorna o maior valor dentro da coluna selecionada
- [[COUNT()]]- retorna o número de linhas em um conjunto
- [[SUM()]]- retorna a soma total de uma coluna numérica
- [[AVG()]]- retorna o valor médio de uma coluna numérica

Funções de agregação ignoram valores nulos (exceto para `COUNT()`).

O [[AS]] se encaixa aqui:
```sql
SELECT MIN(Price) AS SmallestPrice
FROM Products;
```

|SmallestPrice|
|:--|
|2.5|
renomeou o nome da coluna.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\GROUP BY.md
### Última modificação: 2024-10-14 23:42:10

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-18
nivel:
---
O comando `GROUP BY` em SQL é utilizado para agrupar linhas que têm valores iguais em colunas específicas. Ele é geralmente combinado com [[Função de agregação]], como [[COUNT()]], [[SUM()]], [[AVG()]], [[MIN()]], [[MAX()]],


ex:

|ProductID|Price|CategoryID|
|---|---|---|
|1|10.0|1|
|2|4.5|1|
|3|15.0|2|
|4|10.0|2|
|5|9.2|3|
|6|12.0|3|
|7|2.5|4|
|8|3.0|4|
|9|7.0|5|
|10|8.0|5|
|11|7.45|6|
|12|8.5|6|
|13|10.0|7|
|14|12.0|7|
|15|6.0|8|
|16|7.0|8|

```sql
SELECT MIN(Price) AS SmallestPrice, CategoryID  
FROM Products  
GROUP BY CategoryID;
```

| SmallestPrice | CategoryID |
| :------------ | :--------- |
| 4.5           | 1          |
| 10            | 2          |
| 9.2           | 3          |
| 2.5           | 4          |
| 7             | 5          |
| 7.45          | 6          |
| 10            | 7          |
| 6             | 8          |


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\HAVING.md
### Última modificação: 2024-10-14 23:37:25

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-20
---
filtra os grupos que atendem a uma condição específica

```mysql
SELECT colunas, função_agregação()
FROM tabela
WHERE filtro
GROUP BY colunas
```
# HAVING SUM()
| id_do_pedido | item     | quantia | ID do cliente |
| ------------ | -------- | ------- | ------------- |
| 1            | Teclado  | 400     | 4             |
| 2            | Rato     | 300     | 4             |
| 3            | Monitor  | 12000   | 3             |
| 4            | Teclado  | 400     | 1             |
| 5            | Mousepad | 250     | 2             |
```sql
SELECT customer_id, SUM(amount) AS total
FROM Orders
GROUP BY customer_id
HAVING SUM(amount) < 500;
```
Este comando somou todas as ocorrencias dos clientes (`ID do cliente`) na ordem em que os clientes aparecem, e se a soma der + de 500 ele não aparece na tabela.

|ID do cliente|total|
|---|---|
|1|400|
|2|250|
dai so mostrou o cliente 1 e 2
# HAVING COUNT()
|ID do cliente|primeiro nome|sobrenome|idade|país|
|---|---|---|---|---|
|1|John|Corça|31|EUA|
|2|Roberto|Lua|22|EUA|
|3|Davi|Robson|22|Reino Unido|
|4|John|Reinhardt|25|Reino Unido|
|5|Betty|Corça|28|Emirados Árabes Unidos|
```sql
SELECT COUNT(customer_id), country
FROM Customers
GROUP BY country
HAVING COUNT(customer_id) > 1;
```
Diz soma as ocorrências repetida dos países e apenas mostra os que se repetem mais de 1 vez. 

|COUNT(id_cliente)|país|
|---|---|
|2|Reino Unido|
|2|EUA|

usa os comandos: [[COUNT]], [[GROUP BY]], [[FROM]], [[SELECT]], [[SUM()]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\IN.md
### Última modificação: 2024-09-16 21:03:51

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-16
nivel:
---
``` sql
SELECT * FROM brinquedos
WHERE nome IN ('Carrinho', 'Boneca', 'Bola');
```
Esse comando busca todos os brinquedos que são **Carrinho, Boneca ou Bola**.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\INSERT INTO.md
### Última modificação: 2024-09-17 20:09:18

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-17
nivel:
---
```sql
INSERT INTO _table_name_ (_column1_, _column2_, _column3_, ...)  
VALUES (_value1_, _value2_, _value3_, ...);
```

Se você estiver adicionando valores para todas as colunas da tabela, não precisa especificar os nomes das colunas na consulta SQL. No entanto, certifique-se de que a ordem dos valores esteja na mesma ordem das colunas na tabela. Aqui, a `INSERT INTO`sintaxe seria a seguinte:
```sql
INSERT INTO _table_name_  
VALUES (_value1_, _value2_, _value3_, ...);
```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\INTO.md
### Última modificação: 2024-09-16 21:18:04

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-15
nivel:
---
O `INTO` serve por exemplo: `INSERT INTO` coloca **em**.

nota:[[INSERT INTO]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\IS NULL.md
### Última modificação: 2024-09-18 00:00:20

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-17
nivel:
---
- **`IS NULL`**: Verifica se um valor é **nulo** (ausente).
- **`IS NOT NULL`**: Verifica se um valor **[[NOT|não]] é nulo**.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\JOIN.md
### Última modificação: 2024-09-21 20:26:33

---
tags:
  - Comando
  - DataAnalyst
data: 2024-09-19
nivel:
---
![[Pasted image 20240919213727.png|300]]
## (INNER) JOIN
Tabela `Customers` (Clientes)

| CustomerID | CustomerName  | ContactName  | City          |
| ---------- | ------------- | ------------ | ------------- |
| 1          | Alice Smith   | John Smith   | New York      |
| 2          | Bob Johnson   | Mary Johnson | Chicago       |
| 3          | Charlie Brown | Charlie B.   | San Francisco |
Tabela `Orders` (Pedidos)

|OrderID|OrderDate|CustomerID|ProductName|
|---|---|---|---|
|1001|2024-09-10|1|Laptop|
|1002|2024-09-12|2|Phone|
|1003|2024-09-13|1|Mouse|
|1004|2024-09-14|3|Keyboard|

```sql
SELECT Customers.CustomerName, Orders.OrderID, Orders.OrderDate, Orders.ProductName
FROM Customers
INNER JOIN Orders ON Customers.CustomerID = Orders.CustomerID;
```

|CustomerName|OrderID|OrderDate|ProductName|
|---|---|---|---|
|Alice Smith|1001|2024-09-10|Laptop|
|Alice Smith|1003|2024-09-13|Mouse|
|Bob Johnson|1002|2024-09-12|Phone|
|Charlie Brown|1004|2024-09-14|Keyboard|
## Outros
- [[LEFT (OUTER) JOIN]]: Retorna todos os registros da tabela da esquerda e os registros correspondentes da tabela da direita
- [[RIGHT (OUTER) JOIN]]: Retorna todos os registros da tabela da direita e os registros correspondentes da tabela da esquerda
- [[FULL (OUTER) JOIN]]: Retorna todos os registros quando há uma correspondência na tabela esquerda ou direita
- [[SELF JOIN]]: é uma junção de uma tabela com ela mesma.
- [[CROSS JOIN]]: Retorna todas as combinações possíveis entre as linhas das duas tabelas, combinando cada linha da tabela da esquerda com todas as linhas da tabela da direita.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\LEFT (OUTER) JOIN.md
### Última modificação: 2024-09-19 23:23:19

---
tags:
  - Comando
  - DataAnalyst
data: 2024-09-19
nivel:
---
## Tabelas
Tabela `Customers` (Clientes)

|CustomerID|CustomerName|City|
|---|---|---|
|1|Alice Smith|New York|
|2|Bob Johnson|Chicago|
|3|Charlie Brown|San Francisco|
|4|David Lee|Miami|

Tabela `Orders` (Pedidos)

|OrderID|OrderDate|CustomerID|ProductName|
|---|---|---|---|
|1001|2024-09-10|1|Laptop|
|1002|2024-09-12|2|Phone|
|1003|2024-09-13|1|Mouse|
|1004|2024-09-14|5|Keyboard|
## Comando
``` sql
SELECT Customers.CustomerID, Customers.CustomerName, Orders.OrderID, Orders.ProductName
FROM Customers
LEFT JOIN Orders ON Customers.CustomerID = Orders.CustomerID;
```
Selecione as tabelas.colunas :  `Customers.CustomerID, Customers.CustomerName, Orders.OrderID, Orders.ProductName`
do Tabela 1 `Custumeres` e `...JOIN Orders` na tabela 2
de uma junção a esquerda nas tabelas `customers` e `Orderes`. Levando a coluna `CustumerID` como base de referencia.

|CustomerID|CustomerName|OrderID|ProductName|
|---|---|---|---|
|1|Alice Smith|1001|Laptop|
|1|Alice Smith|1003|Mouse|
|2|Bob Johnson|1002|Phone|
|3|Charlie Brown|NULL|NULL|
|4|David Lee|NULL|NULL|

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\LENGTH.md
### Última modificação: 2024-09-23 20:26:07

---
tags:
  - Comando
  - DataAnalyst
data: 2024-09-23
---
A função `LENGTH` no SQL é usada para contar o número de caracteres em uma string.

```sql
LENGTH(campo_ou_string)
```
# EX

|id_cliente|nome|
|---|---|
|1|João|
|2|Maria|
|3|Pedro|

```sql
SELECT 
    nome, 
    LENGTH(nome) AS comprimento_nome
FROM 
    clientes;
```

|nome|comprimento_nome|
|---|---|
|João|4|
|Maria|5|
|Pedro|5|

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\LIKE.md
### Última modificação: 2024-09-18 22:31:35

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-16
nivel:
---
```sql
SELECT * FROM brinquedos
WHERE nome LIKE 'C%';
```
Aqui, ele encontra todos os brinquedos cujo nome começa com a letra **C**, como **Carrinho**.
%s% palavras que contenham s no meio

![[Operadores do LIKE]]


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\LIMIT.md
### Última modificação: 2024-09-18 20:20:30

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-18
nivel:
---
O comando **`LIMIT`** em SQL é utilizado para **limitar o número de linhas** retornadas por uma consulta. Ele é muito útil quando você deseja obter apenas uma parte dos resultados, em vez de todos os registros da tabela.
Basicamente é o [[SELECT TOP]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\LOWER.md
### Última modificação: 2024-09-23 20:30:21

---
tags:
  - Comando
  - DataAnalyst
data: 2024-09-23
---
A função `LOWER` no SQL é usada para converter todos os caracteres de uma string em **letras minúsculas**.

```sql
LOWER(campo_ou_string)
```

|id_cliente|nome|
|---|---|
|1|João|
|2|MARIA|
|3|pedro|

```sql
SELECT 
    LOWER(nome) AS nome_minusculo
FROM 
    clientes;
```

|nome_minusculo|
|---|
|joão|
|maria|
|pedro|

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\MAX().md
### Última modificação: 2024-10-19 01:35:24



### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\MOD.md
### Última modificação: 2024-09-23 22:38:01

---
tags:
  - Comando
  - DataAnalyst
data: 2024-09-23
---
A função `MOD` no SQL é usada para calcular o **resto** da divisão de um número por outro.

```sql
MOD(numero, divisor)
```

|id_numero|valor|
|---|---|
|1|4|
|2|7|
|3|10|

```sql
SELECT 
    valor,
    MOD(valor, 2) AS resto
FROM 
    numeros
WHERE 
    MOD(valor, 2) = 0;
```

|valor|resto|
|---|---|
|4|0|
|10|0|

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\Nomal x temporary x view x Select.md
### Última modificação: 2024-10-09 01:37:21

---
tags:
  - DataAnalyst
  - Datascience
  - Comando
data: 2024-10-05
---

| Característica     | Tabela Regular                        | Tabela Temporária                                 | SELECT                           | View                                           |
| ------------------ | ------------------------------------- | ------------------------------------------------- | -------------------------------- | ---------------------------------------------- |
| **Armazenamento**  | Sim (disco)                           | Sim (geralmente disco)                            | Não                              | Não (exceto Views materializadas)              |
| **Persistência**   | Permanente                            | Temporária (sessão/transação)                     | Temporária (execução)            | Permanente (consulta armazenada)               |
| **Finalidade**     | Armazenar dados                       | Armazenar dados temporariamente                   | Recuperar dados                  | Consultar dados de forma virtual               |
| **Criação**        | `CREATE TABLE`                        | `CREATE TEMPORARY TABLE`                          | `SELECT`                         | `CREATE VIEW`                                  |
| **Remoção**        | `DROP TABLE`                          | Automática após sessão                            | Não aplicável                    | `DROP VIEW`                                    |
| **Exemplo de uso** | Tabelas de clientes, produtos, vendas | Tabelas de cálculos intermediários ou temporários | Consultar clientes, somar vendas | Relatórios complexos, visualizações frequentes |
|                    |                                       |                                                   |                                  |                                                |
### 1. **Tabela Regular**

- **Definição:** Uma tabela regular é um objeto permanente dentro de um [[Banco de dados|banco de dados]] que armazena dados de forma estruturada em linhas e colunas.
- **Persistência:** As tabelas regulares continuam existindo no banco de dados até que sejam explicitamente deletadas com um comando [[DROP|DROP TABLE]].
- **Armazenamento:** Os dados são armazenados fisicamente no [[Memória|disco]].
- **Exemplo de Criação:**
```mysql
CREATE TABLE bike (
    bike_id INT PRIMARY KEY,
    model_name VARCHAR(50),
    price DECIMAL(10, 2)
);
```
### 2. **Tabela Temporária**

- **Definição:** Uma tabela temporária é semelhante a uma tabela regular, mas sua existência é limitada a uma sessão ou transação de banco de dados.
- **Persistência:** Ela é criada e usada durante uma sessão específica de um usuário e será automaticamente removida assim que a sessão for encerrada ou a transação for concluída (dependendo do tipo de tabela temporária).
- **Armazenamento:** Os dados são armazenados temporariamente, e, como uma tabela regular, ocupam espaço em disco (embora alguns sistemas possam otimizar para armazená-los em memória).
- **Exemplo de Criação:** [[CREATE TEMPORARY TABLE|]]

```mysql
CREATE TEMPORARY TABLE temp_bike (
    bike_id INT,
    model_name VARCHAR(50)
);
```
### 3. **[[SELECT]] (Consulta)**

- **Definição:** Um `SELECT` é uma consulta SQL usada para recuperar dados de uma ou mais tabelas. Ele não cria um objeto no banco de dados, mas apenas retorna um conjunto de dados resultante da consulta.
- **Persistência:** O resultado do [[SELECT]] é temporário, existindo apenas enquanto a consulta é processada. Após a execução, o resultado não é armazenado no banco, a menos que você opte por salvá-lo (por exemplo, inserindo os dados em uma tabela).
- **Exemplo de Uso:**
```mysql
SELECT bike_id, model_name FROM bike;
```
### 4. **[[View]] (Visão)**

- **Definição:** Uma **View** é uma consulta armazenada no banco de dados. Ela é como uma tabela virtual que não armazena os dados diretamente, mas sim uma consulta que é executada toda vez que a View é chamada. A View pode ser utilizada como uma tabela regular em consultas, mas os dados subjacentes vêm das tabelas referenciadas na consulta da View.
- **Persistência:** As Views são persistentes (até serem excluídas com `DROP VIEW`), mas os dados não são armazenados na View. Toda vez que a View é consultada, a consulta subjacente é executada.
- **Armazenamento:** Uma View não armazena dados, ela armazena apenas a definição da consulta.
- **Exemplo de Criação:**
```mysql
CREATE VIEW bike_prices AS
SELECT model_name, price FROM bike;
```


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\NOT NULL.md
### Última modificação: 2024-09-20 23:06:15

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-20
---
Garante que a coluna sempre terá um valor.
```sql
CREATE TABLE clientes (
    id INT PRIMARY KEY,
    nome VARCHAR(100) NOT NULL,
    email VARCHAR(100) NOT NULL,
    telefone VARCHAR(15)
);
```
comandos: [[CREATE]] [[TABLE]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\NOT.md
### Última modificação: 2024-09-19 19:44:35

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-19
nivel:
---
```sql
SELECT * FROM Customers
WHERE CustomerID NOT IN (SELECT CustomerID FROM Orders);
```
Selecione todas as colunas da tabela **Clientes** (_Customers_), onde o **ID do Cliente** (_CustomerID_) **não está** presente na lista de IDs de clientes obtida a partir da tabela **Pedidos** (_Orders_).

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\NULLIF.md
### Última modificação: 2024-09-24 19:06:09

---
tags:
  - Comando
  - DataAnalyst
data: 2024-09-23
---
A função `NULLIF` no SQL é utilizada para **comparar dois valores** e retornar `NULL` se eles forem iguais.

```mysql
NULLIF(valor1, valor2)
```

| produto  | total_vendas | num_pedidos |
| -------- | ------------ | ----------- |
| Camiseta | 1000         | 50          |
| Calça    | 2000         | 0           |
| Jaqueta  | 1500         | 30          |

```mysql
SELECT 
    produto, 
    total_vendas / NULLIF(num_pedidos, 0) AS vendas_por_pedido
FROM 
    vendas;
```

| produto  | vendas_por_pedido |
| -------- | ----------------- |
| Camiseta | 20.0              |
| Calça    | NULO              |
| Jaqueta  | 50,0              |

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\Operadores do LIKE.md
### Última modificação: 2024-09-19 19:41:35

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-18
nivel:
---

| Símbolo  | Descrição                                               |
|----------|---------------------------------------------------------|
| %        | Representa zero ou mais caracteres                      |
| _        | Representa um único caractere                           |
| []       | Representa qualquer caractere único dentro dos colchetes*|
| ^        | Representa qualquer caractere que não esteja nos colchetes*|
| -        | Representa qualquer caractere único dentro do intervalo especificado*|
| {}       | Representa qualquer caractere escapado**               |


`'L_nd__'` London e Lander se encaixam.
`'_r%'` Que tenham "r" na segunda posição.
`'[bsp]%'` Retorna todos os clientes que começam com "b", "s" ou "p"
`'[a-f]%'` Retorna todos os clientes que começam com "a", "b", "c", "d", "e" ou "f"(de a até f)


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\Operadores no SQL.md
### Última modificação: 2024-09-19 19:51:17

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-13
nivel:
---

| Operador    | Descrição                                                                           |
| ----------- | ----------------------------------------------------------------------------------- |
| =           | Igual                                                                               |
| >           | Maior que                                                                           |
| <           | Menor que                                                                           |
| >=          | Maior ou igual                                                                      |
| <=          | Menor ou igual                                                                      |
| <>          | Diferente (Nota: em algumas versões de SQL, esse operador pode ser escrito como !=) |
| [[BETWEEN]] | **Entre** um certo intervalo                                                        |
| [[LIKE]]    | Procurar um padrão                                                                  |
| [[IN]]      | Especificar múltiplos valores possíveis para uma coluna                             |
| [[AND]]     | condição1 e condição2 ...                                                           |
| [[OR]]      | condição1 ou condição2 ...                                                          |
| [[NOT]]     | Oposto                                                                              |
| [[IS NULL]] | é nulo                                                                              |
|             |                                                                                     |
|             |                                                                                     |


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\OR.md
### Última modificação: 2024-09-17 19:11:25

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-17
nivel:
---
O operador **`OR`** em SQL é utilizado para combinar múltiplas condições, mas ao contrário do `AND`, ele retorna resultados que atendem a **pelo menos uma** das condições.
```sql
SELECT * FROM Customers  
WHERE Country = 'Spain' AND (CustomerName LIKE 'G%' OR CustomerName LIKE 'R%');
```
encontre o pais espanha que tenha os nome das pessoas que comessem com G ou R.


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\ORDER BY.md
### Última modificação: 2024-09-16 21:28:55

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-16
nivel:
---
O comando `ORDER BY` em SQL é usado para **ordenar** os resultados de uma consulta. Você pode organizar os dados em **ordem crescente** (do menor para o maior) ou **ordem decrescente** (do maior para o menor).

### Como Funciona o `ORDER BY`

![[ASC]]
![[DESC]]

```sql
SELECT * FROM Customers  
ORDER BY Country ASC, CustomerName DESC;
```
seleciona a tabela costumeres e ordenaem ordem alfabetica o pais e desalfabetica os nomes assim toda vez que repetir o pais os nomes serão mostrados de forma desalfabetica. 

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\Parênteses.md
### Última modificação: 2024-09-17 19:55:27

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-17
nivel:
---
Os parênteses servem para isolar uma parte da operação dos [[Operadores no SQL]]. 
exemplo sem parênteses:
```sql
SELECT * 
FROM clientes
WHERE cidade = 'São Paulo' OR cidade = 'Rio de Janeiro' AND salario > 5000;
```

|Nome|Cidade|Salário|
|---|---|---|
|Ana|São Paulo|5000|
|Carla|São Paulo|6000|
|Eva|São Paulo|5500|
|Bruno|Rio de Janeiro|6000|
Exemplo com parênteses:

```sql
SELECT * 
FROM clientes
WHERE (cidade = 'São Paulo' OR cidade = 'Rio de Janeiro') AND salario > 5000;

```

|Nome|Cidade|Salário|
|---|---|---|
|Carla|São Paulo|6000|
|Eva|São Paulo|5500|
|Bruno|Rio de Janeiro|6000|



### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\Prefixos SQL.md
### Última modificação: 2024-09-19 20:33:54



### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\PRIMARY KEY.md
### Última modificação: 2024-09-15 21:38:10

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-15
nivel:
---
O comando `PRIMARY KEY` é utilizado para definir uma **chave primária** em uma tabela. A chave primária é um campo (ou combinação de campos) que **identifica unicamente** cada registro da tabela.

no caso o comando: `id INT primary KEY auto_increment NOT NULL`  inteiro será a chave primaria e auto incrementara numero não nulo.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\REFERENCES.md
### Última modificação: 2024-09-16 00:16:42

---
tags:
  - Comando
  - DataAnalyst
data: 2024-09-16
nivel:
---
No SQL, o termo `REFERENCES` é usado em conjunto com a definição de uma **chave estrangeira** (`FOREIGN KEY`[[FOREIGN KEY|.]]) para estabelecer uma relação entre duas tabelas.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\REPLACE VIEW.md
### Última modificação: 2024-09-25 21:19:07

---
tags:
  - Comando
  - DataAnalyst
data: 2024-09-25
---
O comando `REPLACE VIEW`é usado para atualizar uma _visualização_ existente no banco de dados sem precisar excluí-la primeiro.

```mysql
REPLACE VIEW nome_da_view AS
SELECT colunas
FROM tabela
WHERE condição;
```

| id_funcional | nome   | salário | departamento |
| ------------ | ------ | ------- | ------------ |
| 1            | Carlos | 5000,00 | TI           |
| 2            | Ana    | 6000,00 | Vendas       |
| 3            | Pedro  | 5500,00 | TI           |
| 4            | Sófia  | 7000,00 | Marketing    |
| 5            | João   | 4000,00 | Vendas       |

```mysql
CREATE VIEW view_ti AS
SELECT id_funcionario, nome, salario
FROM funcionarios
WHERE departamento = 'TI';
```

|id_funcional|nome|salário|
|---|---|---|
|1|Carlos|5000,00|
|3|Pedro|5500,00|

```mysql
REPLACE VIEW view_ti AS
SELECT id_funcionario, nome, salario, departamento
FROM funcionarios
WHERE departamento IN ('TI', 'Vendas');
```

|id_funcional|nome|salário|departamento|
|---|---|---|---|
|1|Carlos|5000,00|TI|
|3|Pedro|5500,00|TI|
|2|Ana|6000,00|Vendas|
|5|João|4000,00|Vendas|

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\REPLACE.md
### Última modificação: 2024-09-23 20:28:53

---
tags:
  - Comando
  - DataAnalyst
data: 2024-09-23
---
A função `REPLACE` no SQL é usada para **substituir** parte de uma string por outra string.

```sql
REPLACE(campo_ou_string, 'texto_a_substituir', 'novo_texto')
```

|id_cliente|nome|
|---|---|
|1|João|
|2|Maria|
|3|Joana|

```sql
SELECT 
    nome,
    REPLACE(nome, 'Jo', 'João') AS nome_substituido
FROM 
    clientes;
```

|nome|nome_substituido|
|---|---|
|João|Joãoão|
|Maria|Maria|
|Joana|Joãoana|

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\Restrições SQL.md
### Última modificação: 2024-09-20 23:57:06

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-20
---
Restrições SQL são usadas para especificar regras para os dados em uma tabela. São usadas para limitar o tipo de dados que podem entrar em uma tabela. 
As restrições podem ser de nível de coluna ou de nível de tabela. Restrições de nível de coluna se aplicam a uma coluna, e restrições de nível de tabela se aplicam à tabela inteira.

As seguintes restrições são comumente usadas em SQL:

- [[NOT NULL]]- Garante que uma coluna não pode ter um valor NULL
- [[UNIQUE]]- Garante que todos os valores em uma coluna sejam diferentes
- [[PRIMARY KEY]]- Uma combinação de a `NOT NULL`e `UNIQUE`. Identifica exclusivamente cada linha em uma tabela
- [[FOREIGN KEY]]- Evita ações que destruiriam links entre tabelas
- [[CHECK]]- Garante que os valores em uma coluna satisfaçam uma condição específica
- [[DEFAULT]]- Define um valor padrão para uma coluna se nenhum valor for especificado
- [[CREATE INDEX]]- Usado para criar e recuperar dados do banco de dados muito rapidamente

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\RIGHT (OUTER) JOIN.md
### Última modificação: 2024-09-19 23:23:40

---
tags:
  - Comando
  - DataAnalyst
data: 2024-09-19
nivel:
---
## Tabelas
Tabela `Customers` (Clientes)

|CustomerID|CustomerName|City|
|---|---|---|
|1|Alice Smith|New York|
|2|Bob Johnson|Chicago|
|3|Charlie Brown|San Francisco|
|4|David Lee|Miami|

Tabela `Orders` (Pedidos)

|OrderID|OrderDate|CustomerID|ProductName|
|---|---|---|---|
|1001|2024-09-10|1|Laptop|
|1002|2024-09-12|2|Phone|
|1003|2024-09-13|1|Mouse|
|1004|2024-09-14|5|Keyboard|
## Comando
```sql
SELECT Customers.CustomerID, Customers.CustomerName, Orders.OrderID, Orders.ProductName
FROM Customers
RIGHT JOIN Orders ON Customers.CustomerID = Orders.CustomerID;
```
Selecione as tabelas.colunas: `Customers.CustomerID, Customers.CustomerName, Orders.OrderID, Orders.ProductName`  de uma junção à direita nas tabelas `Customers` e `Orders`, levando a coluna `CustomerID` como base de referência.

|CustomerID|CustomerName|OrderID|ProductName|
|---|---|---|---|
|1|Alice Smith|1001|Laptop|
|1|Alice Smith|1003|Mouse|
|2|Bob Johnson|1002|Phone|
|NULL|NULL|1004|Keyboard|

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\ROUND.md
### Última modificação: 2024-10-11 00:30:05

---
tags:
  - Comando
  - DataAnalyst
data: 2024-09-23
---
A função `ROUND` no SQL é usada para **arredondar valores numéricos** para um número específico de casas decimais.

```sql
ROUND(numero, [casas_decimais])
```

|id_venda|valor_venda|
|---|---|
|1|15.75|
|2|23.49|
|3|8.10|

```sql
SELECT 
    valor_venda, 
    ROUND(valor_venda) AS valor_arredondado
FROM 
    vendas;
```

| valor_venda | valor_arredondado |
| ----------- | ----------------- |
| 15.75       | 16                |
| 23.49       | 23                |
| 8.10        | 8                 |

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\SELECT TOP.md
### Última modificação: 2024-09-18 00:08:13

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-18
nivel:
---
```sql
SELECT TOP 5 * FROM Customers;
```
So mostrara os 5 primeiros. 

| CustomerID | CustomerName                        | ContactName         | Address                     | City        | PostalCode | Country  |
|------------|-------------------------------------|---------------------|-----------------------------|-------------|------------|----------|
| 1          | Alfreds Futterkiste                 | Maria Anders        | Obere Str. 57               | Berlin      | 12209      | Germany  |
| 2          | Ana Trujillo Emparedados y helados  | Ana Trujillo        | Avda. de la Constitución 2222| México D.F. | 05021      | Mexico   |
| 3          | Antonio Moreno Taquería             | Antonio Moreno      | Mataderos 2312              | México D.F. | 05023      | Mexico   |
| 4          | Around the Horn                    | Thomas Hardy        | 120 Hanover Sq.             | London      | WA1 1DP    | UK       |
| 5          | Berglunds snabbköp                 | Christina Berglund  | Berguvsvägen 8              | Luleå       | S-958 22   | Sweden   |



### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\SELECT.md
### Última modificação: 2024-09-20 23:00:24

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-18
nivel:
---
## Opedadores do select
[[SELECT TOP]]
[[ORDER BY]]
[[DESC]]
[[LIMIT]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\SELF JOIN.md
### Última modificação: 2024-09-20 19:27:48

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-20
nivel:
---
O **SELF JOIN** no SQL é uma junção de uma tabela com ela mesma. Isso pode ser útil quando você precisa comparar ou relacionar os dados dentro de uma única tabela, como em casos de hierarquia (por exemplo, empregados e seus supervisores) ou quando precisa buscar relações entre os registros da mesma tabela.

|EmployeeID|EmployeeName|ManagerID|
|---|---|---|
|1|Alice|NULL|
|2|Bob|1|
|3|Charlie|1|
|4|David|2|
|5|Eve|3|
```sql
SELECT e1.EmployeeName AS Employee, e2.EmployeeName AS Manager FROM Employees e1 LEFT JOIN Employees e2 ON e1.ManagerID = e2.EmployeeID;
```

|Employee|Manager|
|---|---|
|Bob|Alice|
|Charlie|Alice|
|David|Bob|
|Eve|Charlie|
|Alice|NULL|
Ou seja o chefe de Bob é Alice, de Charlie é Alice....

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\Sem título.md
### Última modificação: 2024-09-15 23:32:15



### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\SET.md
### Última modificação: 2024-09-15 20:56:03

---
tags:
  - Comando
  - DataAnalyst
data: 2024-09-13
nivel:
---
O comando `SET` no SQL é usado para definir [[variáveis]] ou modificar opções de configuração durante a sessão atual. Ele permite atribuir valores a variáveis que podem ser utilizadas posteriormente em consultas ou para configurar parâmetros do [[Servidor|servidor]] ou da sessão.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\SUBSTRING.md
### Última modificação: 2024-09-23 20:21:51

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-23
---
A função `SUBSTRING` no SQL é usada para extrair uma parte de uma string, com base em uma posição inicial e, opcionalmente, no comprimento da parte que você deseja extrair.

``` SQL
SUBSTRING(campo, posição_inicial, comprimento)
```
EX:

|id_produto|codigo_produto|
|---|---|
|1|PROD1234|
|2|PROD5678|
|3|PROD9012|

```sql
SELECT 
    SUBSTRING(codigo_produto, 5, 4) AS codigo_numerico
FROM 
    produtos;
```

|codigo_numerico|
|---|
|1234|
|5678|
|9012|

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\TIME.md
### Última modificação: 2024-09-23 21:04:29

---
tags:
  - Comando
  - DataAnalyst
data: 2024-09-23
---

A função `TIME` no SQL é usada para **extrair a parte de tempo (hora, minuto, segundo)** de uma data ou para manipular e armazenar valores de tempo

```sql
TIME(campo_data_hora)
```

|id_evento|data_hora|
|---|---|
|1|2024-09-23 14:35:20|
|2|2024-09-23 09:12:45|
|3|2024-09-23 18:00:00|

```sql
SELECT 
    TIME(data_hora) AS horario
FROM 
    eventos;
```

| horario  |
| -------- |
| 14:35:20 |
| 09:12:45 |
| 18:00:00 |


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\TIMESTAMP.md
### Última modificação: 2024-09-23 21:07:45

---
tags:
  - Comando
  - DataAnalyst
data: 2024-09-23
---
 A função `TIMESTAMP` no SQL é usada para armazenar tanto **data quanto hora** em um único campo. Ela representa um momento específico no tempo, geralmente no formato `YYYY-MM-DD HH:MM:SS` (Ano-Mês-Dia Hora:Minuto)

```sql
CREATE TABLE pedidos (
    id_pedido INT PRIMARY KEY,
    produto VARCHAR(50),
    quantidade INT,
    data_hora TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\UNION.md
### Última modificação: 2024-10-16 23:59:16

---
tags:
  - Comando
  - DataAnalyst
data: 2024-09-20
---
O `UNION`operador é usado para combinar o conjunto de resultados de duas ou mais `SELECT` instruções.
[[UNION ALL]]

- Cada `SELECT`declaração `UNION`deve ter o mesmo número de colunas
- As colunas também devem ter tipos de dados semelhantes
- As colunas em cada `SELECT`declaração também devem estar na mesma ordem
```mySQL
SELECT _column_name(s)_ FROM _table1_  
UNION  
SELECT _column_name(s)_ FROM _table2_;
```

`ClientesBrasil`

|ID|Nome|Cidade|
|---|---|---|
|1|João Silva|São Paulo|
|2|Maria Costa|Rio de Janeiro|
|3|Lucas Lima|Salvador|
 `ClientesArgentina`

|ID|Nombre|Ciudad|
|---|---|---|
|4|Juan Pérez|Buenos Aires|
|5|María González|Córdoba|
|6|Lucas García|Rosario|

```mysql
SELECT ID, Nome, Cidade FROM ClientesBrasil 
UNION 
SELECT ID, Nombre AS Nome, Ciudad AS Cidade FROM ClientesArgentina;
```

|ID|Nome|Cidade|
|---|---|---|
|1|João Silva|São Paulo|
|2|Maria Costa|Rio de Janeiro|
|3|Lucas Lima|Salvador|
|4|Juan Pérez|Buenos Aires|
|5|María González|Córdoba|
|6|Lucas García|Rosario|

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\UNIQUE.md
### Última modificação: 2024-09-21 00:01:48

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-20
---
A restrição `UNIQUE` em SQL é usada para garantir que todos os valores em uma coluna ou em um conjunto de colunas sejam **únicos**, ou seja, que não existam valores duplicados. Ela é frequentemente aplicada a campos que precisam ter valores distintos, como e-mails, CPF, ou números de identidade.

```sql
CREATE TABLE usuarios (
    id INT PRIMARY KEY,
    nome VARCHAR(100),
    email VARCHAR(100) UNIQUE
);
```
```sql
CREATE TABLE produtos (
    id INT PRIMARY KEY,
    nome VARCHAR(100),
    categoria VARCHAR(50),
    UNIQUE(nome, categoria)
);
```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\UPDATE.md
### Última modificação: 2024-09-15 21:25:51

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-15
nivel:
---
O UPDATE serve para **atualizar**, como o nome diz, algo na tabela ou na coluna. 
**Nunca** usar sem [[WHERE]].

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\UPPER.md
### Última modificação: 2024-10-11 00:29:43

---
tags:
  - Comando
  - DataAnalyst
data: 2024-09-23
---
A função `UPPER` no SQL é usada para converter todos os caracteres de uma string para **letras maiúsculas**.

```sql
UPPER(campo_ou_string)
```
# EX
| id_cliente | nome  |
| ---------- | ----- |
| 1          | João  |
| 2          | Maria |
| 3          | Pedro |

```sql
SELECT 
    nome
FROM 
    clientes
WHERE 
    UPPER(nome) = 'MARIA';
```

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\USE.md
### Última modificação: 2024-09-15 20:52:44

---
tags:
  - Comando
  - DataAnalyst
data: 2024-09-15
nivel:
---
Serve para focar em um [[Banco de dados]]. `USE banco_de_dados`

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\VARCHAR.md
### Última modificação: 2024-09-16 00:05:19

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-16
nivel:
---
É o comando que caracteriza string(texto), e o numero colocado é o numero máximo de caracteres que aquela variável vai suportar. 

precisa da [[CREATE]][[TABLE]]
Ex:
``` sql
numero VARCHAR(10)
```


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\VIEW.md
### Última modificação: 2024-09-25 21:10:25

---
tags:
  - Comando
  - DataAnalyst
data: 2024-09-24
---
A view é uma forma de salvar temporariamente tabelas de consultas feitas pelo [[SELECT]], [[WHERE]], [[JOIN]], [[LIMIT]].... em uma variável, sendo assim apenas chamando a consulta personalizada para que a tabela seja mostrada. Cria-se com [[CREATE VIEW]], Para modificar há 2 formas, uma modificando: usando [[CREATE VIEW]] OU [[REPLACE VIEW]]; e outra recriando: usando [[DROP VIEW]] e após criando uma nova com [[CREATE VIEW]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\WHERE.md
### Última modificação: 2024-09-16 21:02:53

---
tags:
  - DataAnalyst
  - Comando
data: 2024-09-13
nivel:
---
Vem junto com o [[SELECT]], [[DELETE]] e [[UPDATE]] e serve para filtrar **onde** estão algo mediante um filtro usando ![[Operadores no SQL]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\Comandos\ÍNDICES.md
### Última modificação: 2024-09-26 21:12:17

---
tags: 
data: 2024-09-26
---
Índices em SQL são objetos de banco de dados que melhoram a velocidade das operações de recuperação de dados em tabelas de banco de dados. [[Árvore balanceada]]
Acelerando [[SELECT]] as consultas, os índices podem desacelerar as operações [[INSERT]], [[UPDATE]], e [[DELETE]]

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\PROJETO\Planejamento.md
### Última modificação: 2024-10-02 23:58:42

---
tags:
  - DataAnalyst
data: 2024-09-28
---
- **Planejamento do Sistema:** Determine as tabelas e campos necessários, como `produtos`, `fornecedores`, `entradas_estoque`, `saídas_estoque`, etc. Planeje as relações entre essas tabelas.
- **Criação de Tabelas:** Use o comando `CREATE TABLE`[[CREATE|]] para criar tabelas que armazenarão os dados do estoque. Cada tabela deve conter colunas adequadas para seus atributos (ex: nome, quantidade, preço, data de entrada).
- **Inserção de Dados:** Utilize o comando `INSERT INTO` para adicionar os registros iniciais de produtos, fornecedores e entradas de estoque.
- **Consultas e Relatórios:** Crie consultas SQL (SELECT) para visualizar o estoque atual, produtos com baixa quantidade, histórico de entradas e saídas, etc. Use [[Funções de agregação|funções de agregação]] para sumarizar dados.
- **Triggers para Atualizações Automáticas:** Configure [[TRIGGERS|triggers]] para automatizar a atualização de quantidades no estoque quando houver entradas ou saídas de produtos.
- **Procedimentos Armazenados:** Crie procedimentos armazenados para automatizar processos comuns, como adição de novos produtos ou movimentação de estoque.
- **Auditoria:** Crie tabelas e consultas para rastrear alterações no sistema, como movimentações e histórico de transações.
- **Manutenção do Sistema:** Monitore o sistema periodicamente para verificar inconsistências, adicionar novas funcionalidades ou adaptar às necessidades da empresa.
 
# passos
- [ ] Criar todas o banco de dados, e todas as informações em 1 tabela.(10)

| nome_func | data_admissão | idade_func | cargo_func | ID_func |
| --------- | ------------- | ---------- | ---------- | ------- |
|           |               |            |            |         |


| nome_bike | tipo | marca | Id_bike |
| --------- | ---- | ----- | ------- |
|           |      |       |         |


| com_capacete | preço_bike | data_compra | ID_func | ID_bike |
| ------------ | ---------- | ----------- | ------- | ------- |
|              |            |             |         |         |

- [x] Criar um metodo para separar as tabelas(vendedor, produto)
- [x] Decidir de ante-mão quais serão os resultados finais.
	- Analise da venda dos funcionarios
	- Analise da venda por cargo dos funcionários
	- Analise da venda das marcas
	- Analise da venda das modalidades
	- Analise de sazonalidade
- [x] Colocar todos os itens
- [x] Separar as tabelas
- [ ] Fazer triggers para a automatizar a inserção nas tabelas(vendedor, produto)
- [x] Colocar muitos itens nas tabelas
- [ ] Responder a essas perguntas:
- [ ] Top 10 mais vendidos e menos vendidos
- [ ] Top 3 vendedores
- [ ] 80/20
- [ ] [[Media]]
- [ ] [[Moda]]
- [ ] [[Mediana]]
- [ ] Soma 
- [ ] Minimo
- [ ] maximo 


Crie um código em Python que gere uma tabela de vendas simulada, levando em consideração as seguintes regras:

Estrutura de Funcionários:

A empresa possui exatamente 10 funcionários fixos.  
Cada funcionário tem apenas um cargo entre: estagiário, vendedor ou vendedor chefe.  
Os cargos seguem uma hierarquia de tempo de admissão:  
Estagiários: Devem ter sido admitidos recentemente, entre 2022 e 2024.  
Vendedores: Devem ter sido admitidos anteriormente aos estagiários, entre 2015 e 2021.  
Vendedor chefe: Deve ser o funcionário mais antigo, admitido antes de 2015.  
O nome dos funcionários deve ser um único nome (nome + sobrenome juntos, sem espaços).  
A data de admissão de cada funcionário deve ser única e fixada conforme o cargo. Vendas não podem ocorrer antes da data de admissão do funcionário.  
Estrutura das Bicicletas:

Cada bicicleta tem um nome, marca e modalidade específicos que devem estar relacionados.  
Exemplo de correspondências corretas:  
Marca: "Caloi", Nome: "Caloi Strada", Modalidade: "Speed".  
Marca: "Sense", Nome: "Sense Impulse", Modalidade: "Mountain".  
O preço das bicicletas deve aumentar gradativamente ao longo do tempo, considerando uma inflação de 4% ao ano, a partir de um preço base.  
O preço final deve incluir um ajuste adicional (podendo ser zero) baseado na performance do vendedor.  
Regras de Vendas:

O vendedor chefe deve realizar mais vendas ou vender produtos com valores maiores em comparação aos vendedores, e os vendedores devem superar os estagiários nas vendas.  
As datas de venda devem estar sutilmente inclinadas para datas comemorativas e períodos de férias, como Natal, Ano Novo, Carnaval, etc.  
Cada venda deve ser associada a um funcionário que estava empregado na época da venda.  
Dados Financeiros:

Os preços das bicicletas devem ser calculados com precisão de duas casas decimais.  
Cada venda pode incluir ou não a compra de capacetes, e o valor das vendas deve refletir essa diferença.  
Formato de Saída:

O código deve gerar uma tabela de vendas com as seguintes colunas:  
id: identificador único da venda.  
nome_func: nome do funcionário.  
data_admissao: data de admissão do funcionário.  
ano_nascimento: ano de nascimento do funcionário (4 dígitos).  
cargo_func: cargo do funcionário (estagiário, vendedor, vendedor chefe).  
nome_bike: nome da bicicleta.  
modalidade: modalidade da bicicleta.  
marca: marca da bicicleta.  
tamanho: tamanho da bicicleta (P, M, G).  
com_capacete: booleano indicando se foi vendido um capacete.  
preco_bike: preço final da bicicleta.  
data_compra: data da compra.  
Os dados devem ser consistentes com as regras mencionadas.

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\SQL\PROJETO\Sem título.md
### Última modificação: 2025-01-17 21:50:17

---
Titulo: 
tags: 
data: 2024-04-28
Link: https://www.youtube.com/watch?v=ci3ldv3zd_I
nivel:
---
projeto será do site [https://www.kaggle.com/datasets/kuchh...](https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqbGNwcTlPZ3liZm5ldTVkajc1ckx4NkFRUDRlQXxBQ3Jtc0trbVlQQm1BSWxDeFpyTnc4NXdfdGsteGZSb245TUM4c3VQdTl3bFZhMjh4RGF6S3hNRnBLdFVHcTk1STBFMC1qUjhEdUtCLUxCa1N6RGlocWljS2NhNHpyRWJOTExGb0VJa3RRZjVWbGJ4S2JXNE1yQQ&q=https%3A%2F%2Fwww.kaggle.com%2Fdatasets%2Fkuchhbhi%2Flatest-laptop-price-list&v=ci3ldv3zd_I)
em uma analize 


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Tripleten\Career Content.md
### Última modificação: 2025-01-11 23:58:38

---
tags: 
data: 2024-11-24
---
# ao vivo
RDP
# Career Content4 
mentorias tecnicas
seja cara de pau
# Career Content5
Tipos de auto sabotagem:
- Vritimismo
- vingança
- procrastinação
- comparação
- necessidade de validação
Organizar os links quando começar a crescer muito
Se conheça(horarios, cor, cheiros)
tipos de atenção?
Luiza é engenheira agrônoma

Aproveite seu passado.

# Career Content7
calendario editorial n
fraze com - 30 palavras bom
1 artigo por mês
3 posts no likedln por semana
**Focar no obj**
pensar no lado do cliente.
mostre as tentativas
contato fiel interessante e não interesseiro com headrunter

# Career Content 8
Analizar espectativas
# Career Content 9
Matrix de exforço impacto
# Career Content 9
5 porques para fazer perguntas
# Career Content 12
22

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Tripleten\Perguntas.md
### Última modificação: 2025-01-03 19:21:06

# Quem Sou Eu

Objetivos Pessoais

- Busco independência financeira e geográfica, e tenho o desejo de visitar e, quem sabe, morar com amigas que tenho fora do meu estado.
- Quero fundar uma empresa com baixa rotatividade, onde as pessoas se sintam motivadas a permanecer e contribuir de forma duradoura.

Comunicação e Habilidade Didática

- Tenho uma comunicação fluida e consigo me adaptar a diferentes públicos, embora não me comunique com frequência.
- Consigo explicar conceitos complexos de forma acessível, como a profundidade de páginas HTML para meu avô de 85 anos ou o funcionamento de um ábaco antigo.

Afinidade com Dados

- Desde a adolescência, tenho afinidade com dados, especialmente com tabelas. Mantenho até hoje tabelas de organização e investimentos daquela época.
- Sou formado em Logística, e durante o curso escolhi uma disciplina de Estatística, o que me despertou o interesse pela área de análise de dados.

Desafios com Escrita e Leitura

- Tenho dificuldades com escrita, cometendo muitos erros de português, e uma leve dificuldade com leitura. Estou buscando melhorias, mas acredito que possa ser uma condição patológica, ainda sem solução clara.
- Apesar disso, sempre li muito, especialmente sobre temas didáticos como Física, Geologia e Divulgação Científica.

Curiosidade e Aprendizado Contínuo

- Desde a infância, tenho milhares de horas assistindo a vídeos sobre diversos temas, como Ciência, Antropologia, Filosofia e Tecnologia.
- Esse interesse contínuo por aprender sobre várias áreas me acompanha há muito tempo e é uma parte essencial de quem sou.

Experiência com Jogos e Trabalho em Equipe

- Jogo videogames desde os 15 anos, sempre buscando jogos que trouxessem algum tipo de aprendizado ou desafio.
- Montei e organizei um time amador para participar de campeonatos, com treinos regulares e uma divisão feminina. Esse período, em que consegui unir jovens em torno de um objetivo comum, me trouxe muito orgulho.

Arte com Origami

- Sou artista de origami desde os 8 anos. Uma memória importante dessa época foi um fichário grande que minha professora fez para ajudar a acalmar minha alma agitada, o que funcionou. Hoje sou uma pessoa controlada e paciente.

Relações na Vida Virtual

- Na vida virtual, onde passo a maior parte do meu tempo, fiz muitos amigos fora do meu estado. Atualmente, vejo apenas um amigo “regularmente” e mantenho contato com mais de mil pessoas pela internet, embora sinta que essa dependência do mundo virtual não é totalmente positiva.
# Carreira 4
Deveria focar em freela, como?
Como ser visto/provar competências pelas futuras empresas e clientes
Posso aplicar para vaga?
Quanto eu deveria ter mentorias tecnicas?
Como fazer uma rede de apoio profissional
Deveria deixar meu git hub interiamente em inglês? 
Sobre minhas analizes de dados controversas, politicas...
Quais são meus potenciais clientes para freelaa
## alanize com carreia
ferramentas q tem facilidade
quais cursos. 
estudante de analize de dados
## como me vender
Apresentar a necessidade da pessoa.
não passar insegurança
venda ativa e passiva.
## linkedln
Colocar sobre excel no sobre.
direcionado  
# Técnicas
![[Pasted image 20241229225807.png]]
![[Pasted image 20241231004716.png]]
Eu consigo transformar em os objetive das ultimas 2 colunas em data time com essa formatação. 
[[Densidade de frequência]]
![[Pasted image 20250103192105.png]]


uowork
Horario 9 a 10 horas
vagas mais novas
 



### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Tripleten\progeto 3.md
### Última modificação: 2024-12-15 16:29:00

# Conheça o segundo projeto

Você explorou o grande e maravilhoso mundo da manipulação de dados 🎉, aprendeu muita coisa e agora está com tudo pronto para iniciar o seu segundo projeto neste programa.

Desta vez, você vai realizar uma tarefa que poderia receber em um trabalho real de especialista de dados. Você vai precisar passar por todas as etapas do processo: estudar os dados, limpá-los tratando com cuidado valores ausentes e duplicados, responder a perguntas analíticas e visualizar suas conclusões.

> 💡 Como de costume, ao terminar o projeto, entregue-o para ser revisado. Você vai receber comentários em até 24 horas. Faça mudanças conforme indicado pelo revisor e entregue uma versão atualizada. Talvez você receba novos comentários, e é normal ter várias versões de mudanças antes que o projeto seja aceito. Quando o revisor aceitar o seu projeto, ele será considerado concluído.

Antes de você iniciar, temos mais algumas **dicas**:

1. **Leia as instruções com atenção:** você está apenas começando sua jornada no mundo de dados, então fornecemos instruções detalhadas sobre o que fazer. Leia tudo atentamente para evitar os erros mais comuns e alcançar os melhores resultados;
2. **Use os materiais do sprint:** lembre-se de que este é um projeto "com consulta", o que significa que você pode usar livremente todos os materiais do sprint, principalmente a parte prática. OBS: preste atenção especial ao estudo de caso;
3. **Faça perguntas:** é normal não saber algo. Se tiver dificuldades com uma determinada parte do projeto, sinta-se à vontade para pedir ajuda aos tutores ou aos colegas no Discord.

Boa sorte no seu caminho para se tornar mestre da manipulação de dados!

Avaliar

Avançar
Sprint 3: Manipulação de dados[](https://tripleten.com/trainer/data-analyst/lesson/63d13752-141e-425e-92e9-2382b11b8277/)

[](https://discord.gg/SA8nvpfPfX)

# Descrição do projeto

**DATASETS**

- [instacart_orders.csv](https://practicum-content.s3.us-west-1.amazonaws.com/new-markets/Data_Refactored_2_sprint/datasets/instacart_orders.csv)
    
- [products.csv](https://practicum-content.s3.us-west-1.amazonaws.com/new-markets/Data_Refactored_2_sprint/datasets/products.csv)
    
- [order_products.csv](https://practicum-content.s3.us-west-1.amazonaws.com/new-markets/Data_Refactored_2_sprint/order_products.csv.zip)
    
- [aisles.csv](https://practicum-content.s3.us-west-1.amazonaws.com/new-markets/Data_Refactored_2_sprint/datasets/aisles.csv)
    
- [departments.csv](https://practicum-content.s3.us-west-1.amazonaws.com/new-markets/Data_Refactored_2_sprint/datasets/departments.csv)
    

Parabéns por concluir o sprint sobre AED! É hora de aplicar o conhecimento e as habilidades que você adquiriu a um estudo de caso analítico.

Quando terminar o projeto, envie seu trabalho ao revisor na plataforma para avaliação. Você vai receber feedback em até 48 horas. Use o feedback para fazer alterações e, em seguida, envie a nova versão de volta ao revisor do projeto.

Você talvez receba mais feedback referente à nova versão. Isso é completamente normal. Não é incomum passar por vários ciclos de feedback e revisão.

Seu projeto será considerado concluído assim que o revisor do projeto o aprovar.

## Descrição do projeto

Neste projeto, você vai trabalhar com dados da Instacart.

A Instacart é uma plataforma de entrega de supermercado onde os clientes podem fazer um pedido de supermercado e receber a compra em casa, semelhante ao funcionamento do Uber Eats e do iFood. Esse conjunto de dados específico foi [lançado publicamente](https://tech.instacart.com/3-million-instacart-orders-open-sourced-d40d29ead6f2) *(os materiais estão em inglês) pela Instacart em 2017 para uma [competição Kaggle](https://www.kaggle.com/c/instacart-market-basket-analysis/overview) _(os materiais estão em inglês)_. Os dados reais podem ser baixados na página da Kaggle.

O conjunto de dados que fornecemos foi modificado a partir do original. Reduzimos o tamanho dele para que seus cálculos sejam executados mais rapidamente e incluímos valores ausentes e duplicados. Também tivemos o cuidado de preservar as distribuições dos dados originais quando fizemos as alterações.

Sua missão é limpar os dados e preparar um relatório que forneça informações sobre os hábitos de compra dos clientes da Instacart. Após responder a cada pergunta, escreva uma breve explicação dos seus resultados em uma célula Markdown no seu notebook Jupyter.

Neste projeto, você vai precisar criar gráficos para apresentar seus resultados. Certifique-se de que todos os gráficos que você criar têm um título, eixos rotulados e uma legenda, se necessário; e inclua `plt.show()` no final de cada célula com um gráfico.

Assista a este vídeo para mais dicas sobre o projeto:

## Dicionário de dados

Há cinco tabelas no conjunto de dados, e você vai precisar usar todas elas para pré-processar os dados e fazer a AED. Abaixo está um dicionário que lista as colunas de cada tabela e descreve os dados contidos nelas.

- `instacart_orders.csv`: cada linha corresponde a um pedido no aplicativo da Instacart
    - `'order_id'`: é o número de identificação exclusivo de cada pedido
    - `'user_id'`: é o número de identificação exclusivo da conta de cada cliente
    - `'order_number'`: é o número de vezes que o cliente fez um pedido
    - `'order_dow'`: é o dia da semana em que o pedido foi feito (0 é domingo)
    - `'order_hour_of_day'`: é a hora do dia em que o pedido foi feito
    - `'days_since_prior_order'`: é o número de dias desde que o cliente fez seu pedido anterior
- `products.csv`: cada linha corresponde a um produto exclusivo que os clientes podem comprar
    - `'product_id'`: é o número de identificação exclusivo de cada produto
    - `'product_name'`: é o nome do produto
    - `'aisle_id'`: é o número de identificação exclusivo de cada categoria de corredor do supermercado
    - `'department_id'`: é o número de identificação exclusivo de cada categoria de departamento do supermercado
- `order_products.csv`: cada linha corresponde a um item incluído em um pedido
    - `'order_id'`: é o número de identificação exclusivo de cada pedido
    - `'product_id'`: é o número de identificação exclusivo de cada produto
    - `'add_to_cart_order'`: é a ordem sequencial em que cada item foi colocado no carrinho
    - `'reordered'`: 0 se o cliente nunca comprou o produto antes, 1 se já o comprou
- `aisles.csv`
    - `'aisle_id'`: é o número de identificação exclusivo de cada categoria de corredor do supermercado
    - `'aisle'`: é o nome do corredor
- `departments.csv`
    - `'department_id'`: é o número de identificação exclusivo de cada categoria de departamento do supermercado
    - `'department'`: é o nome do departamento

## Instruções para concluir o projeto

**Etapa 1:** abra os arquivos de dados (`/datasets/instacart_orders.csv`, `/datasets/products.csv`, `/datasets/aisles.csv`, `/datasets/departments.csv` e `/datasets/order_products.csv`) e dê uma olhada no conteúdo geral de cada tabela.

Observe que os arquivos têm formatação fora do padrão, então você vai precisar definir certos argumentos em `pd.read_csv()` para ler os dados corretamente. Dê uma olhada nos arquivos CSV para ter uma ideia de quais deveriam ser esses argumentos.

Observe que `order_products.csv` contém _muitas_ linhas de dados. Quando um DataFrame tem muitas linhas, `info()` não imprime as contagens de valores não nulos por padrão. Se quiser imprimi-las, inclua `show_counts=True` quando chamar `info()`.

**Etapa 2:** faça o pré-processamento dos dados da seguinte maneira:

- Verifique e corrija os tipos de dados (por exemplo, certifique-se de que as colunas de ID sejam números inteiros)
- Identifique e preencha valores ausentes
- Identifique e remova valores duplicados

Certifique-se de explicar que tipos de valores ausentes e duplicados você encontrou, como você os preencheu ou removeu, por que escolheu esses métodos e por que você acha que esses valores ausentes e duplicados estavam presentes no conjunto de dados.

**Etapa 3:** quando os dados estiverem processados e prontos, execute a seguinte análise:

**[A] (é necessário concluir tudo para passar)**

1. Verifique se os valores nas colunas `'order_hour_of_day'` e `'order_dow'` na tabela `orders` fazem sentido (ou seja, os valores da coluna `'order_hour_of_day'` variam de 0 a 23 e os da `'order_dow'` variam de 0 a 6).
2. Crie um gráfico que mostre quantas pessoas fazem pedidos a cada hora do dia.
3. Crie um gráfico que mostre em que dia da semana as pessoas fazem compras.
4. Crie um gráfico que mostre quanto tempo as pessoas esperam até fazer seu próximo pedido e comente sobre os valores mínimo e máximo.

**[B] (é necessário concluir tudo para passar)**

1. Há diferenças entre as distribuições de `'order_hour_of_day'` na quarta-feira e no sábado? Construa histogramas para ambos os dias no mesmo gráfico e descreva as diferenças que você notou.
2. Construa um gráfico de distribuição para o número de pedidos que os clientes fazem (ou seja, quantos clientes fizeram apenas 1 pedido, quantos fizeram apenas 2, quantos apenas 3, etc.)
3. Quais são os 20 produtos comprados com mais frequência? Exiba os números de identificação (ID) e nomes.

**[C] (é necessário concluir pelo menos duas perguntas para passar)**

1. Quantos itens as pessoas normalmente compram em um pedido? Como fica a distribuição?
2. Quais são os 20 principais itens incluídos mais frequentemente em pedidos repetidos? Exiba os números de identificação (ID) e nomes.
3. Para cada produto, que proporção de pedidos em que ele aparece são pedidos repetidos? Crie uma tabela com colunas para ID do produto, nome do produto e a proporção de pedidos repetidos.
4. Para cada cliente, que proporção dos produtos comprados são pedidos repetidos?
5. Quais são os 20 principais itens que as pessoas colocam nos carrinhos antes de todos os outros? Exiba o ID do produto, nome e o número de vezes que ele foi o primeiro a ser adicionado a um carrinho.

Vamos lá!

Ou faça o projeto em seu computador e faça upload de seu trabalho quando finalizar.

Fazer upload e enviar

[Avançar](https://tripleten.com/trainer/data-analyst/lesson/63d13752-141e-425e-92e9-2382b11b8277/)

O que você achou do projeto?


# Vamos encher o carrinho![](https://jupyterhub.tripleten-services.com/user/user-3-f213ea5c-94ca-4f29-9c46-4771fbdad1ea/notebooks/078eb029-d762-4f21-8c07-bfb555d6a3e9.ipynb#Vamos-encher-o-carrinho!)

# Introdução[](https://jupyterhub.tripleten-services.com/user/user-3-f213ea5c-94ca-4f29-9c46-4771fbdad1ea/notebooks/078eb029-d762-4f21-8c07-bfb555d6a3e9.ipynb#Introdu%C3%A7%C3%A3o)

O Instacart é uma plataforma de entrega de supermercado onde os clientes podem fazer um pedido no supermercado e depois receber sua compra, semelhante ao funcionamento do Uber Eats e do iFood. O conjunto de dados que fornecemos foi modificado a partir do original. Reduzimos o tamanho dele para que seus cálculos sejam executados mais rapidamente e incluímos valores ausentes e duplicados. Também tivemos o cuidado de preservar as distribuições dos dados originais quando fizemos as alterações.

Você precisa completar três etapas. Para cada uma delas, escreva uma breve introdução descrevendo como você pretende concluir a etapa e justifique suas decisões em parágrafos explicativos a medida que você avança na solução. Escreva também uma conclusão para resumir suas conclusões e escolhas.

## 1  Dicionário de dados[](https://jupyterhub.tripleten-services.com/user/user-3-f213ea5c-94ca-4f29-9c46-4771fbdad1ea/notebooks/078eb029-d762-4f21-8c07-bfb555d6a3e9.ipynb#Dicion%C3%A1rio-de-dados)

Há cinco tabelas no conjunto de dados, e você vai precisar usar todas elas para pré-processar seus dados e fazer AED. Abaixo está um dicionário que lista as colunas de cada tabela e descreve os dados contidos nelas.

- `instacart_orders.csv`: cada linha corresponde a um pedido no aplicativo da Instacart
    - `'order_id'`: é o número que identifica cada pedido de forma exclusiva
    - `'user_id'`: é o número de identificação exclusivo da conta de cada cliente
    - `'order_number'`: é o número de vezes que o cliente fez um pedido
    - `'order_dow'`: é o dia da semana em que o pedido foi feito (0 é domingo)
    - `'order_hour_of_day'`: é a hora do dia em que o pedido foi feito
    - `'days_since_prior_order'`: é o número de dias desde que o cliente fez seu pedido anterior

- `products.csv`: cada linha corresponde a um produto exclusivo que os clientes podem comprar
    - `'product_id'`: é o número de identificação unívoco de cada produto
    - `'product_name'`: é o nome do produto
    - `'aisle_id'`: é o número de identificação exclusivo de cada categoria de corredor do supermercado
    - `'department_id'`: é o número de identificação exclusivo de cada categoria de departamento do supermercado

- `order_products.csv`: cada linha corresponde a um item incluído em um pedido
    - `'order_id'`: é o número que identifica cada pedido de forma exclusiva
    - `'product_id'`: é o número de identificação exclusivo de cada produto
    - `'add_to_cart_order'`: é a ordem sequencial em que cada item foi colocado no carrinho
    - `'reordered'`: 0 se o cliente nunca comprou o produto antes, 1 se já o comprou

- `aisles.csv`
    - `'aisle_id'`: é o número de identificação exclusivo de cada categoria de corredor do supermercado
    - `'aisle'`: é o nome do corredor

- `departments.csv`
    - `'department_id'`: é o número de identificação exclusivo de cada categoria de departamento do supermercado
    - `'department'`: é o nome do departamento

# Etapa 1. Visão geral dos dados[](https://jupyterhub.tripleten-services.com/user/user-3-f213ea5c-94ca-4f29-9c46-4771fbdad1ea/notebooks/078eb029-d762-4f21-8c07-bfb555d6a3e9.ipynb#Etapa-1.-Vis%C3%A3o-geral-dos-dados)

Leia os arquivos de dados (/datasets/instacart_orders.csv, /datasets/products.csv, /datasets/aisles.csv, /datasets/departments.csv e /datasets/order_products.csv) com `pd.read_csv()` usando os parâmetros apropriados para fazer isso corretamente. Verifique as informações para cada DataFrame criado.

## 2  Plano de solução[](https://jupyterhub.tripleten-services.com/user/user-3-f213ea5c-94ca-4f29-9c46-4771fbdad1ea/notebooks/078eb029-d762-4f21-8c07-bfb555d6a3e9.ipynb#Plano-de-solu%C3%A7%C3%A3o)

Escreva aqui seu plano para a Etapa 2. Visão geral dos dados

In [ ]:

# Importe as bibliotecas

In [ ]:

# leia os conjuntos de dados em DataFrames

In [ ]:

# imprima as informações sobre o DataFrame

In [ ]:

# imprima as informações sobre o DataFrame

In [ ]:

# imprima as informações sobre o DataFrame

In [ ]:

# imprima as informações sobre o DataFrame

In [ ]:

# imprima as informações sobre o DataFrame

## 3  Conclusões[](https://jupyterhub.tripleten-services.com/user/user-3-f213ea5c-94ca-4f29-9c46-4771fbdad1ea/notebooks/078eb029-d762-4f21-8c07-bfb555d6a3e9.ipynb#Conclus%C3%B5es)

Escreva aqui suas conclusões intermediárias da Etapa 1. Visão geral dos dados

# Etapa 2. Preparação de dados[](https://jupyterhub.tripleten-services.com/user/user-3-f213ea5c-94ca-4f29-9c46-4771fbdad1ea/notebooks/078eb029-d762-4f21-8c07-bfb555d6a3e9.ipynb#Etapa-2.-Prepara%C3%A7%C3%A3o-de-dados)

Faça o pré-processamento dos dados da seguinte maneira:

- Verifique e corrija os tipos de dados (por exemplo, certifique-se de que as colunas de ID sejam números inteiros)
- Identifique e preencha valores ausentes
- Identifique e remova valores duplicados

Certifique-se de explicar que tipos de valores ausentes e duplicados você encontrou, como você os preencheu ou removeu, por que escolheu esses métodos e por que você acha que esses valores ausentes e duplicados estavam presentes no conjunto de dados.

## 4  Plano de solução[](https://jupyterhub.tripleten-services.com/user/user-3-f213ea5c-94ca-4f29-9c46-4771fbdad1ea/notebooks/078eb029-d762-4f21-8c07-bfb555d6a3e9.ipynb#Plano-de-solu%C3%A7%C3%A3o)

Escreva aqui seu plano para a Etapa 2. Preparação de dados

## 5  Encontre e remova valores duplicados (e descreva por que você está fazendo suas escolhas)[](https://jupyterhub.tripleten-services.com/user/user-3-f213ea5c-94ca-4f29-9c46-4771fbdad1ea/notebooks/078eb029-d762-4f21-8c07-bfb555d6a3e9.ipynb#Encontre-e-remova-valores-duplicados-(e-descreva-por-que-voc%C3%AA-est%C3%A1-fazendo-suas-escolhas))

### 5.1  DataFrame `instacart_orders`[](https://jupyterhub.tripleten-services.com/user/user-3-f213ea5c-94ca-4f29-9c46-4771fbdad1ea/notebooks/078eb029-d762-4f21-8c07-bfb555d6a3e9.ipynb#DataFrame-instacart_orders)

In [ ]:

# Verificar se há pedidos duplicados

Há linhas duplicadas? Se sim, o que elas têm em comum?

In [ ]:

# Com base nas suas conclusões,

​

# verifique todos os pedidos feitos às 2h da manhã nas quartas-feiras

O que esse resultado quer dizer?

In [ ]:

# Remova pedidos duplicados

In [ ]:

# Verifique as linhas duplicadas mais uma vez

In [ ]:

# Verifique novamente apenas os IDs de pedidos duplicados

Descreva brevemente suas conclusões e o que você fez com elas.

### 5.2  DataFrame `products`[](https://jupyterhub.tripleten-services.com/user/user-3-f213ea5c-94ca-4f29-9c46-4771fbdad1ea/notebooks/078eb029-d762-4f21-8c07-bfb555d6a3e9.ipynb#DataFrame-products)

In [ ]:

# Verifique se há linhas completamente duplicadas

In [ ]:

# Verifique apenas IDs dos produtos duplicados

In [ ]:

# Verifique apenas nomes de produtos duplicados (converta os nomes para minúsculas para uma comparação melhor)

In [ ]:

# Verifique os nomes de produtos duplicados que não estão faltando

Descreva brevemente suas conclusões e o que você fez com elas.

### 5.3  DataFrame `departments`[](https://jupyterhub.tripleten-services.com/user/user-3-f213ea5c-94ca-4f29-9c46-4771fbdad1ea/notebooks/078eb029-d762-4f21-8c07-bfb555d6a3e9.ipynb#DataFrame-departments)

In [ ]:

# Verifique se há linhas completamente duplicadas

In [ ]:

# Verifique apenas se há IDs dos produtos duplicados

Descreva brevemente suas conclusões e o que você fez com elas.

### 5.4  DataFrame `aisles`[](https://jupyterhub.tripleten-services.com/user/user-3-f213ea5c-94ca-4f29-9c46-4771fbdad1ea/notebooks/078eb029-d762-4f21-8c07-bfb555d6a3e9.ipynb#DataFrame-aisles)

In [ ]:

# Verifique se há linhas completamente duplicadas

In [ ]:

# Verifique apenas se há IDs dos produtos duplicados

Descreva brevemente suas conclusões e o que você fez com elas.

### 5.5  DataFrame `order_products`[](https://jupyterhub.tripleten-services.com/user/user-3-f213ea5c-94ca-4f29-9c46-4771fbdad1ea/notebooks/078eb029-d762-4f21-8c07-bfb555d6a3e9.ipynb#DataFrame-order_products)

In [ ]:

# Verifique se há linhas completamente duplicadas

In [ ]:

# Verifique mais uma vez se há outros casos complicados de duplicados

Descreva brevemente suas conclusões e o que você fez com elas.

## 6  Encontre e remova valores ausentes[](https://jupyterhub.tripleten-services.com/user/user-3-f213ea5c-94ca-4f29-9c46-4771fbdad1ea/notebooks/078eb029-d762-4f21-8c07-bfb555d6a3e9.ipynb#Encontre-e-remova-valores-ausentes)

Ao processarmos valores duplicados, observamos que também temos valores ausentes que precisamos investigar nas seguintes colunas:

- A coluna `'product_name'` da tabela products.
- A coluna `'days_since_prior_order'` da tabela orders.
- A coluna `'add_to_cart_order'` da tabela order_products.

### 6.1  DataFrame `products`[](https://jupyterhub.tripleten-services.com/user/user-3-f213ea5c-94ca-4f29-9c46-4771fbdad1ea/notebooks/078eb029-d762-4f21-8c07-bfb555d6a3e9.ipynb#DataFrame-products)

In [ ]:

# Encontre valores ausentes na coluna 'product_name'

Descreva brevemente suas conclusões.

In [ ]:

# Todos os nomes de produtos ausentes estão associados com o corredor de ID 100?

Descreva brevemente suas conclusões.

In [ ]:

# Todos os nomes de produtos ausentes estão associados com o departamento de ID 21?

Descreva brevemente suas conclusões.

In [ ]:

# Use as tabelas department e aisle para verificar os dados do corredor com ID 100 e do departamento com ID 21.

Descreva brevemente suas conclusões.

In [ ]:

# Preencha nomes de produtos ausentes com 'Unknown'

Descreva brevemente suas conclusões e o que você fez com elas.

### 6.2  DataFrame `orders`[](https://jupyterhub.tripleten-services.com/user/user-3-f213ea5c-94ca-4f29-9c46-4771fbdad1ea/notebooks/078eb029-d762-4f21-8c07-bfb555d6a3e9.ipynb#DataFrame-orders)

In [ ]:

# Encontre os valores ausentes

In [ ]:

# Há valores ausentes para os clientes que não estão fazendo o primeiro pedido?

Descreva brevemente suas conclusões e o que você fez com elas.

### 6.3  DataFrame `order_products`[](https://jupyterhub.tripleten-services.com/user/user-3-f213ea5c-94ca-4f29-9c46-4771fbdad1ea/notebooks/078eb029-d762-4f21-8c07-bfb555d6a3e9.ipynb#DataFrame-order_products)

In [ ]:

# Encontre os valores ausentes

In [ ]:

# Quais são os valores mínimo e máximo dessa coluna?

Descreva brevemente suas conclusões.

In [ ]:

# Salve todos os IDs dos pedidos com pelo menos um valor ausente em 'add_to_cart_order'

In [ ]:

# Todos os pedidos com valores ausentes contêm mais de 64 produtos?

# Agrupe os pedidos com dados ausentes por ID de pedido

# Conte o número de 'product_id' em cada pedido e verifique o valor mínimo da contagem

​

Descreva brevemente suas conclusões.

In [ ]:

# Substitua valores ausentes na coluna 'add_to_cart_order' por 999 e converta a coluna para o tipo integer

Descreva brevemente suas conclusões e o que você fez com elas.

## 7  Conclusões[](https://jupyterhub.tripleten-services.com/user/user-3-f213ea5c-94ca-4f29-9c46-4771fbdad1ea/notebooks/078eb029-d762-4f21-8c07-bfb555d6a3e9.ipynb#Conclus%C3%B5es)

Escreva aqui suas conclusões intermediárias da Etapa 2. Preparação de dados

# Etapa 3. Análise de dados[](https://jupyterhub.tripleten-services.com/user/user-3-f213ea5c-94ca-4f29-9c46-4771fbdad1ea/notebooks/078eb029-d762-4f21-8c07-bfb555d6a3e9.ipynb#Etapa-3.-An%C3%A1lise-de-dados)

Quando os dados estiverem processados ​​e prontos, execute a seguinte análise:

# [A] Fácil (é necessário concluir tudo para passar)[](https://jupyterhub.tripleten-services.com/user/user-3-f213ea5c-94ca-4f29-9c46-4771fbdad1ea/notebooks/078eb029-d762-4f21-8c07-bfb555d6a3e9.ipynb#[A]-F%C3%A1cil-(%C3%A9-necess%C3%A1rio-concluir-tudo-para-passar))

1. Verifique se os valores nas colunas `'order_hour_of_day'` e `'order_dow'` na tabela `orders` fazem sentido (ou seja, os valores da coluna `'order_hour_of_day'` variam de 0 a 23 e os da `'order_dow'` variam de 0 a 6).
2. Crie um gráfico que mostre quantas pessoas fazem pedidos a cada hora do dia.
3. Crie um gráfico que mostre em que dia da semana as pessoas fazem compras.
4. Crie um gráfico que mostre quanto tempo as pessoas esperam até fazer seu próximo pedido e comente sobre os valores mínimo e máximo.

### 7.1  [A1] Verifique se os valores fazem sentido[](https://jupyterhub.tripleten-services.com/user/user-3-f213ea5c-94ca-4f29-9c46-4771fbdad1ea/notebooks/078eb029-d762-4f21-8c07-bfb555d6a3e9.ipynb#[A1]-Verifique-se-os-valores-fazem-sentido)

In [ ]:

​

In [ ]:

​

Escreva suas conclusões aqui

### 7.2  [A2] Quantas pessoas fazem pedidos a cada hora do dia?[](https://jupyterhub.tripleten-services.com/user/user-3-f213ea5c-94ca-4f29-9c46-4771fbdad1ea/notebooks/078eb029-d762-4f21-8c07-bfb555d6a3e9.ipynb#[A2]-Quantas-pessoas-fazem-pedidos-a-cada-hora-do-dia?)

In [ ]:

​

Escreva suas conclusões aqui

### 7.3  [A3] Em que dia da semana as pessoas compram produtos alimentícios?[](https://jupyterhub.tripleten-services.com/user/user-3-f213ea5c-94ca-4f29-9c46-4771fbdad1ea/notebooks/078eb029-d762-4f21-8c07-bfb555d6a3e9.ipynb#[A3]-Em-que-dia-da-semana-as-pessoas-compram-produtos-aliment%C3%ADcios?)

In [ ]:

​

Escreva suas conclusões aqui

### 7.4  [A4] Quanto tempo as pessoas esperam até fazer outro pedido?[](https://jupyterhub.tripleten-services.com/user/user-3-f213ea5c-94ca-4f29-9c46-4771fbdad1ea/notebooks/078eb029-d762-4f21-8c07-bfb555d6a3e9.ipynb#[A4]-Quanto-tempo-as-pessoas-esperam-at%C3%A9-fazer-outro-pedido?)

Escreva suas conclusões aqui

In [ ]:

​

# [B] Médio (é necessário concluir tudo para passar)[](https://jupyterhub.tripleten-services.com/user/user-3-f213ea5c-94ca-4f29-9c46-4771fbdad1ea/notebooks/078eb029-d762-4f21-8c07-bfb555d6a3e9.ipynb#[B]-M%C3%A9dio-(%C3%A9-necess%C3%A1rio-concluir-tudo-para-passar))

1. Há alguma diferença nas distribuições de `'order_hour_of_day'` nas quartas e sábados? Construa gráficos de barras para ambos os dias no mesmo gráfico e descreva as diferenças que você notou.
2. Construa um gráfico de distribuição para o número de pedidos que os clientes fazem (ou seja, quantos clientes fizeram apenas 1 pedido, quantos fizeram apenas 2, quantos apenas 3, etc.)
3. Quais são os 20 produtos comprados com mais frequência? Exiba os IDs e nomes.

### 7.5  [B1] Diferenças nas quartas e sábados em `'order_hour_of_day'`. Crie gráficos de barras para ambos os dias e descreva as diferenças.[](https://jupyterhub.tripleten-services.com/user/user-3-f213ea5c-94ca-4f29-9c46-4771fbdad1ea/notebooks/078eb029-d762-4f21-8c07-bfb555d6a3e9.ipynb#[B1]-Diferen%C3%A7as-nas-quartas-e-s%C3%A1bados-em-'order_hour_of_day'.-Crie-gr%C3%A1ficos-de-barras-para-ambos-os-dias-e-descreva-as-diferen%C3%A7as.)

In [ ]:

​

In [ ]:

​

In [ ]:

​

In [ ]:

​

Escreva suas conclusões aqui

### 7.6  [B2] Qual é a distribuição do número de pedidos por cliente?[](https://jupyterhub.tripleten-services.com/user/user-3-f213ea5c-94ca-4f29-9c46-4771fbdad1ea/notebooks/078eb029-d762-4f21-8c07-bfb555d6a3e9.ipynb#[B2]-Qual-%C3%A9-a-distribui%C3%A7%C3%A3o-do-n%C3%BAmero-de-pedidos-por-cliente?)

In [ ]:

​

In [ ]:

​

Escreva suas conclusões aqui

### 7.7  [B3] Quais são os 20 produtos mais populares? Exiba os IDs e nomes.[](https://jupyterhub.tripleten-services.com/user/user-3-f213ea5c-94ca-4f29-9c46-4771fbdad1ea/notebooks/078eb029-d762-4f21-8c07-bfb555d6a3e9.ipynb#[B3]-Quais-s%C3%A3o-os-20-produtos-mais-populares?-Exiba-os-IDs-e-nomes.)

In [ ]:

​

In [ ]:

​

In [ ]:

​

Escreva suas conclusões aqui

# [C] Difícil (é necessário concluir pelo menos duas perguntas para passar)[](https://jupyterhub.tripleten-services.com/user/user-3-f213ea5c-94ca-4f29-9c46-4771fbdad1ea/notebooks/078eb029-d762-4f21-8c07-bfb555d6a3e9.ipynb#[C]-Dif%C3%ADcil-(%C3%A9-necess%C3%A1rio-concluir-pelo-menos-duas-perguntas-para-passar))

1. Quantos itens as pessoas normalmente compram em um pedido? Como fica a distribuição?
2. Quais são os 20 principais itens incluídos mais frequentemente em pedidos repetidos? Exiba os IDs e nomes.
3. Para cada produto, qual parcela de seus pedidos são repetidos? Crie uma tabela com colunas de ID e nome do produto e a proporção de pedidos repetidos.
4. Para cada cliente, qual proporção de todos os seus pedidos são repetidos?
5. Quais são os 20 principais itens que as pessoas colocam nos carrinhos antes de todos os outros? Exiba o ID do produto, nome e o número de vezes que ele foi o primeiro a ser adicionado a um carrinho.

### 7.8  [C1] Quantos itens as pessoas normalmente compram em um pedido? Como fica a distribuição?[](https://jupyterhub.tripleten-services.com/user/user-3-f213ea5c-94ca-4f29-9c46-4771fbdad1ea/notebooks/078eb029-d762-4f21-8c07-bfb555d6a3e9.ipynb#[C1]-Quantos-itens-as-pessoas-normalmente-compram-em-um-pedido?-Como-fica-a-distribui%C3%A7%C3%A3o?)

In [ ]:

​

In [ ]:

​

In [ ]:

​

Escreva suas conclusões aqui

### 7.9  [C2] Quais são os 20 principais itens incluídos com mais frequência em pedidos repetidos? Exiba os IDs e nomes.[](https://jupyterhub.tripleten-services.com/user/user-3-f213ea5c-94ca-4f29-9c46-4771fbdad1ea/notebooks/078eb029-d762-4f21-8c07-bfb555d6a3e9.ipynb#[C2]-Quais-s%C3%A3o-os-20-principais-itens-inclu%C3%ADdos-com-mais-frequ%C3%AAncia-em-pedidos-repetidos?-Exiba-os-IDs-e-nomes.)

In [ ]:

​

In [ ]:

​

In [ ]:

​

In [ ]:

​

Escreva suas conclusões aqui

### 7.10  [C3] Para cada produto, qual parcela de todos os pedidos dele são repetidos?[](https://jupyterhub.tripleten-services.com/user/user-3-f213ea5c-94ca-4f29-9c46-4771fbdad1ea/notebooks/078eb029-d762-4f21-8c07-bfb555d6a3e9.ipynb#[C3]-Para-cada-produto,-qual-parcela-de-todos-os-pedidos-dele-s%C3%A3o-repetidos?)

In [ ]:

​

In [ ]:

​

In [ ]:

​

Escreva suas conclusões aqui

### 7.11  [C4] Para cada cliente, qual proporção de todos os seus pedidos são repetidos?[](https://jupyterhub.tripleten-services.com/user/user-3-f213ea5c-94ca-4f29-9c46-4771fbdad1ea/notebooks/078eb029-d762-4f21-8c07-bfb555d6a3e9.ipynb#[C4]-Para-cada-cliente,-qual-propor%C3%A7%C3%A3o-de-todos-os-seus-pedidos-s%C3%A3o-repetidos?)

In [ ]:

​

In [ ]:

​

Escreva suas conclusões aqui

### 7.12  [C5] Quais são os 20 principais itens que as pessoas colocam nos carrinhos antes de todos os outros?[](https://jupyterhub.tripleten-services.com/user/user-3-f213ea5c-94ca-4f29-9c46-4771fbdad1ea/notebooks/078eb029-d762-4f21-8c07-bfb555d6a3e9.ipynb#[C5]-Quais-s%C3%A3o-os-20-principais-itens-que-as-pessoas-colocam-nos-carrinhos-antes-de-todos-os-outros?)

In [ ]:

​

In [ ]:

​

In [ ]:

​

Escreva suas conclusões aqui

# Conclusão geral do projeto:[](https://jupyterhub.tripleten-services.com/user/user-3-f213ea5c-94ca-4f29-9c46-4771fbdad1ea/notebooks/078eb029-d762-4f21-8c07-bfb555d6a3e9.ipynb#Conclus%C3%A3o-geral-do-projeto:)

In [ ]:

​

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Tripleten\Sem título.md
### Última modificação: 2024-12-12 19:32:33

[[Variável dependente]]
[[Variável independente]]
groupby 
mean
count
logical_and
crosstab
read_csv
head
merge
plot
	kind
[[Rotatividade]]
SGBDs
drag-and-drop
snapshots
[[Pipeline de dados]]
[[Hípotese]]
object
datetime64
[[Correlação]]
corr
[[R-quadrado]]
score
intercepto
coeficiente
`LinearRegression` tem um método `fit`
predict
`DecisionTreeClassifier`
fit
crosstab
vetor
[[Letras latinas]]
[[AutoCalculate]]
_pasta de trabalho_
referência de coluna completa
UNIQUE
Ctrl+h 
[[Drop-down lists]]
[[F4]]
[[ctrl+d]]
[[ctrl+/]]
PEMDAS
[[Caracteres de escape]]
[[Indexação negativa]]
/t 
extend
[[Ordenação lexicográfica]]
metodo 
função
isdigit()
CTR
CPC
tabela hash
macrodados
programação funcional
MapReduce
Power BI
Google Data Studio
Tableau
Talend
MySQL
PostgreSQL
Python
Jupyter Notebook
Databricks
Miro
convulução
GIGO
Snake_case
crosstab
[[,groupby]] agg{}
![[Pasted image 20241129195347.png]]

Sites:
freecodecamp é uma boa
workd data tambem
e kaggler
world data
tudo na comujnidade tb!!
mulheres de dados


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Tripleten\Sprint 4.md
### Última modificação: 2025-01-15 18:58:24

---
tags: 
data: 2025-01-12
---
1. Compare a duração média das chamadas de cada plano para cada mês. Crie um gráfico de barras para visualizar o resultado.
2. Compare o número de minutos que os usuários de cada plano necessitam a cada mês. Construa um histograma.
3. Calcule a média e a variância da duração mensal das chamadas
4. Faça um diagrama de caixa para visualizar a distribuição da duração mensal das chamadas
![[Pasted image 20250112213307.png]]
![[Pasted image 20250112200911.png]]


### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Tripleten\Aulas\Introdução á EDA e DATAVIZ.md
### Última modificação: 2024-12-03 20:18:58

---
tags: 
data: 2024-12-03
---
CRISP-DM
![[Pasted image 20241203191738.png|300]]
EDA(análise exploratória de dados)[[EDA]]
DataViz - apresentação para leigos

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Tripleten\tecnicas\slide 2.md
### Última modificação: 2025-01-16 20:51:13

# 1  
Técnicas de Estudo  
# 2  
Quem Sou Eu  

Eu sou um ciclista, autista, com dificuldades de interpretação e leitura. Gosto de aprender sobre tudo e sou aluno da Tripleten.

Github: [https://github.com/JhonAI13](https://www.google.com/url?sa=E&q=https%3A%2F%2Fgithub.com%2FJhonAI13)  
LinkedIn: [https://www.linkedin.com/in/jonathas-rocha/](https://www.google.com/url?sa=E&q=https%3A%2F%2Fwww.linkedin.com%2Fin%2Fjonathas-rocha%2F)  
Discord: jonathas_martins

#### notas

# 3

Acordos

Se você quiser falar algo, levante a mão. Para comunicar-se sem falar, utilize o chat. Agradeceria se pudessem ligar as câmeras.

Tem algum neurocientista, pedagogo ou professor presente?

Os artigos serão fornecidos separadamente em PDF.

#### notas

Explique que existe a possibilidade de ter profissionais da área presentes, que podem validar as informações que você apresentará. Ligar as câmeras ajuda a criar uma conexão e evita a sensação de estar falando sozinho.

# 4 Como Aprendemos

![[Imagem que demostra como os caminhos do celebro ficam mais faceis quanto amis se expõe no que se quer aprender..gif]]
O esforço mental (estudo ativo) é crucial. Aprender tem que ser cansativo.

#### notas

Assim como no GIF, inicialmente o cérebro reorganiza-se para criar caminhos para o aprendizado. Durante o sono, esses caminhos se dissipam. Se o conhecimento é revisitado nos dias seguintes, o cérebro reorganiza e fortalece esses caminhos.

# 5

Como Esquecemos

O esquecimento é o oposto do aprendizado.

#### notas

Se uma memória não é usada/revisitada, ela tende a ser apagada gradualmente. Nosso cérebro é eficiente e não gasta energia mantendo caminhos desnecessários.

# 6

Técnicas de Aprendizado

Toda técnica de aprendizado gira em torno da simplificação, exposição, conexão (relação) ou esforço cognitivo.

#### notas

Vamos explorar cada um desses pontos em detalhes nos próximos slides.

# 7

Alguém Lembra o que Estava Escrito no Slide Anterior?

#### notas

Demonstre que o conteúdo complexo exige tempo para processamento. Volte ao slide e explique melhor os pontos.

# 8


![[Gif que mostra como funciona um flashcard..gif]]  
Flashcards são uma técnica onde um lado da carta contém uma pergunta e o outro a resposta.

#### notas

A ideia principal é a rapidez e brevidade: perguntas simples e respostas curtas. A habilidade de "quebrar o problema" (como em programação) é fundamental para aplicar esta técnica ao conhecimento.

# 9

Repetição Espaçada  
![[Grafico que mostra a curva de esquecimento mediante a nenhuma, 1, 2 ou 3 repetições e como impacta na curva..png|300]] ![[Foto de Hermann Ebbigahus.png|300]]  
Hermann Ebbinghaus.  
Exemplos: "DAX", "LEF", "BOK"

#### notas

Ebbinghaus, em seus estudos do século XIX, criou listas de sílabas sem sentido para investigar o esquecimento. O gráfico mostra como a lembrança diminui sem revisões e como a repetição espaçada (em intervalos específicos) melhora a retenção. É importante ressaltar que o experimento foi feito com sílabas sem sentido, e um tamanho de amostra mais amplo seria necessário para generalizar as conclusões. Também é importante mencionar que o sentimento pelo conteúdo pode influenciar na retenção.

# 10

Mnemônicos  
![[é uma imagem que mostra um minemonico das datas e quais dos meses tem 28 30 e 31..png|300]]![[é um imagem d eum minemonimo para gravar os planetas do sistema solar por meio da inicial de todas as palavra da fraze..png|300]]  
Mnemônicos são recursos que facilitam o aprendizado por meio de associações criativas, como palavras, frases, imagens ou acrônimos.

#### notas

Dê exemplos de mnemônicos que vocês conhecem.

# 11

i+1  
i = conhecimento que você já possui  
1 = um conhecimento relacionado com o i, mas ainda desconhecido ou a ser consolidado.  
![[Imagem que demostra como os caminhos do celebro ficam mais faceis quanto amis se expõe no que se quer aprender..gif|300]]
i = "I love..."  
1 = "soroban"  
i+1 = "I love soroban."  
![[print(lista....) ``` ```python print(lista.sorted).png]]
#### notas

Muito útil no estudo de idiomas. Explique a relação do GIF com a construção de novos caminhos no cérebro a partir de conhecimentos prévios.

# 12

Mineração de Palavras ou Sentenças

Anki é um programa de flashcards que utiliza um algoritmo configurável de repetição espaçada e controle de revisão (vida dos cards).

- flashcards
- algoritmo configurável
- repetição espaçada
- controle de revisão (vida dos cards)
#### notas

Muito usado para aprender novas línguas e programação.

# 13

Técnicas de Esquecimento

#### notas

# 14

Não Exposição (Ausência de Revisão)

Silaba átona

#### notas

O que é uma sílaba átona? Explique a importância da revisão para o esquecimento.

# 15

Deixe o Conteúdo Complexo

Função para Movimento Retilíneo Uniformemente Variado (MRUV)  
![[Pasted image 20250115231502.png]]

#### notas

Pergunte se alguém se lembra da fórmula. Mostre que o problema se torna mais simples se você identificar a questão principal (ex.: "qual a função que calcula distância com aceleração").

# 16

Não Se Esforce Demasiado  
![[Foto que mostra varios videos de aprendendo inglês dormindo, que é alguem falando inglês no seu ouvido..png]] 

#### notas

# 17

Anki

#### notas

# 18

Anki

Anki é um programa de flashcards que utiliza um algoritmo configurável de repetição espaçada e controle de revisão (vida dos cards).

#### notas

Relembre a técnica de mineração de palavras. A repetição espaçada e flashcards já foram discutidos.

# 19

Possibilidades dos Cards  
![[Imagem que mostra como funciona a vida dos cards no anki..png]]

#### notas

# 20

Possibilidades dos Baralhos (Configurações)  
![[É uma imagem que mostra como uma configuração diferente no anki pode mudar o quantas vezes se vê um cartão no baralho..png]]

#### notas

# 21

Porque Configurar?  
![[Imagem varios animais e um avaliador que fara um exame de qm sobe melhor a arvore , dentre os aniamis tem um peixe..png]]

#### notas

Explique que muitas pessoas terão dificuldades, algumas nem chegarão à meta e poucas terão uma vantagem significativa.

# 22

Porque o Anki?  
O Anki pode ser adaptado (por meio de configurações e técnicas de estudo) às formas como aprendemos, o que permite um aprendizado mais rápido.

#### notas

Outras tecnologias (Duolingo, Memrise, Duocards) usam repetição espaçada e focam em erros, mas nenhuma é tão configurável quanto o Anki.

# 23

É Trabalhoso

Fazer e revisar dezenas de flashcards todos os dias (dias bons, regulares e ruins) pode ser cansativo e frustrante, mas é muito eficaz.

#### notas

# 24

Vocês Gostariam de Aprender Mais Sobre o Anki?

#### notas

# 25

Sim  
Talvez  
Não

#### notas

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Tripleten\tecnicas\slide.md
### Última modificação: 2025-01-16 00:21:10

---
tags: 
data: 2025-01-15
---
# 1  
Técnicas de estudo
# 2  
Quem sou eu 

Eu sou um ciclista
Autista
Dificuldade com interpretação e leitura
Gosto de aprender sobre tudo
Aluno da tripleten

Github: https://github.com/JhonAI13 
Linkedln: https://www.linkedin.com/in/jonathas-rocha/
Discord: jonathas_martins
#### notas

# 3  
Acordos

Se quiser falar algo basta levantar a mão.
Mas se quiser apenas comunicar basta escrever no chat que eu estarei lendo. 
Se puderem ligar a camera agradesceria
Tem algum neurocientista, pedagogo ou professor?
Os artigos serão dados a parte no pdf
#### notas
Explicar que existe a chanse de ter essas profições, e que eles podem confirmar as coisas que estarei mostrando. 
Ligar a camera para eu n me sentir falando sozinho
# 4  Como aprendemos
![[Imagem que demostra como os caminhos do celebro ficam mais faceis quanto amis se expõe no que se quer aprender..gif]]
É importante o esforço mental(falar sobre o estudo ativo), aprender TEM que cansar.
#### notas
Nos aprendemos como no gif, no primeiro momento nosso cérebro se reorganiza para que o caminho seja pavimentado, a cada dia que passa(no sono) o caminho se dissipa, e se nos próximos dias este conhecimento é utilizado novamente, o cérebro reorganiza novamente e fortalece o pavimento.
# 5  
Como esquecemos

O esquecimento é o oposto.
#### notas
Se uma memoria não esta no longo prazo ela tende a ser dissipada, nosso copo é muito inteligente, não gastaremos energia com a manutenção do caminho e pouco a pouco ele some.
# 6  
Técnicas de aprendizado.

Toda técnica de aprendizado gira em torno de simplificação, exposição, relação ou esforço cognitivo.
#### notas
Iremos ver tudo isso, passe rápido para o próximo slide
# 7  
Alguem lembra oque estava escrito no slide anterior?
#### notas
Demostrar que quando o conteúdo é complexo exige tempo para ser digerido.
olte para o slide e explique melhor. 
# 8  
Flashcard
![[Gif que mostra como funciona um flashcard..gif]]
O flashcard(cartões rapidos) é uma tecnica onde  um lado de um cartão tem uma pergunta e do outro tem a resposta. 
#### notas
A logica principal deles é ser rapido e curtos, ou seja uma pergunta simples e uma resposta rapida, e portanto vale muito uma habilidade da programação "quebrar o problema" mas oque sera quebrado é o conhecimento. 
# 9  
Repetição espaçada
![[Grafico que mostra a curva de esquecimento mediante a nenhuma, 1, 2 ou 3 repetições e como impacta na curva..png|300]] ![[Foto de Hermann Ebbigahus.png|300]]
Hermann Ebbinghaus
ex.: "DAX", "LEF", "BOK"
#### notas
Este alemão de 1800 fez um esperiento:
Ele criou listas de silabas sem sentido, e no dia 0 ele as gravava, e verificava o quanto ele lembrava nos dias seguinetes, e por meio destes dados criou este grafico. 
Então ele criou uma sequencia de dias para a revisão "perfeita"(dia seguinte, 7 dias, 30 dias....) 
adendo importante, o experimento foi feito com silabas sem correlação nenhuma e que isso afetaria na gravação, até um gosto por algo faz nos gravar-mos melhor algo, dia ruim. E seu estudo foi apenas com sigo próprio. Ou seja não tem um n amostral significativo para que o grafico esteja 100% correto até para este caso isolado de gravar silabas sem sentido. 
Relembrar que os artigos estarão no final. 
# 10  
Mnemônicos
![[é uma imagem que mostra um minemonico das datas e quais dos meses tem 28 30 e 31..png|300]]![[é um imagem d eum minemonimo para gravar os planetas do sistema solar por meio da inicial de todas as palavra da fraze..png|300]]
O Mnemônico é toda facilitação de conhecimento por meio associações criativas, como palavras, frases, imagens ou acrônimos,
#### notas
Deem-me exemplo de mnemônicos que vocês conhecem.
# 11  
i+1
i = conhecimento que você ja possui
1 = um conhecimento relacionado com o i porém que é desconhecido, ou que quer firmar.
![[Imagem que demostra como os caminhos do celebro ficam mais faceis quanto amis se expõe no que se quer aprender..gif|300]]
i = I love...
1 = soroban
i+1 = I love soroban. 
![[print(lista....) ``` ```python print(lista.sorted).png]]
#### notas
Muito usado no estudo de idiomas.
Explicar a relação do gif, que um conhecimento i ja está mais firmado nos caminhos do cérebro e que por isso ajuda a chegar no 1. 
# 12  
Mineração de palavras ou sentenças

Anki é um programa de flashcards que usa um algoritmo configurável de repetição espaçada e vida dos cards

- flahscards
- algoritmo configurável
- repetição espaçada
- vida dos cards
#### notas
Muito usado para aprender novas línguas, também muito importante para aprender línguas de programação. 
# 13  
Técnicas de esquecimento
#### notas

# 14  
Não exposição

Silaba átona
#### notas
Alguém sabe oque é ?
Explicar oque é e porque ninguém lembra mesmo tendo estudado. 
# 15  
Deixe complexo
Função para Movimento Retilíneo Uniformemente Variado (MRUV) 
![[Pasted image 20250115231502.png]]

#### notas
Perguntar se alguém lembra qual a formula.
demostrar que se fosse " qual é a função que calcula a distancia pela aceleração, sorvetão."
# 16  
Não se esforce 
![[Foto que mostra varios videos de aprendendo inglês dormindo, que é alguem falando inglês no seu ouvido..png]] 
#### notas
# 17 
Anki
#### notas
# 18  
Anki 

Anki é um programa de flashcards que usa um algoritmo configurável de repetição espaçada e vida dos cards.
#### notas
Relembrar a tecnica da mineração. E que a repetição espaçada e flashcards ja foi explicado.
# 19  
Possibilidades dos cards
![[imagem que mostra como funciona a vida dos cards no anki..png]]
#### notas
# 20  
Possibilidades dos baralhos(configurações)
![[É uma imagem que mostra como uma configuração diferente no anki pode mudar o quantas vezes se vê um cartão no baralho..png]]
#### notas
# 21  
Porque configurar?
![[Imagem varios animais e um avaliador que fara um exame de qm sobe melhor a arvore , dentre os aniamis tem um peixe..png]]

#### notas
Muitos terão dificuldade, alguns se quer conseguirão, e poucos terão uma eximia vantagem. 
# 22  
Porque o Anki?
O anki consegue ser adaptado(mediante a configuração e a técnicas de estudo) as formas que nois aprendemos, e fazendo assim que nos aprendermos mais rapido.
#### notas
Outras tecnologas(duolingo, menrise, Duocards) usam(repetição espaçada, e foco nos conteúdos em erro) porém nenhuma delas é configurável.
# 23  
É trabalhoso.
Fazer e revisar dezenas de flashcards todos os dias(dias bons, dias normais e dias ruins), é muito cansativo, frustrante... Mas muito funcional.
#### notas
# 24  
Vocês gostariam de aprender mais sobre o Anki?
#### notas
# 25  
sim
talvez
não
#### notas

### Caminho: C:\Users\jonat\Dropbox\Obsidian\obsidian\01 - Progetos\zData Analyst\Tripleten\tecnicas\Técnicas de estudo.md
### Última modificação: 2025-01-16 00:03:16

---
tags: 
data: 2024-12-03
---
# Separação da explicação
## Criar acordos com o publico
Gostaria que todos interajam com perguntas, eu também estou aluno da tripleten.
Tem algum neurocientista, pedagogo ou professor?
Mandar o linkedln
## Aprendizado e esquecimento
### Como aprendemos 
![[Imagem que demostra como os caminhos do celebro ficam mais faceis quanto amis se expõe no que se quer aprender..gif]]
Nos aprendemos como no gif, no primeiro momento nosso cérebro se reorganiza para que o caminho seja pavimentado, a cada dia que passa(no sono) o caminho se dissipa, e se nos próximos dias este conhecimento é utilizado novamente, o cérebro reorganiza novamente e fortalece o pavimento.
É importante o esforço mental(falar sobre o estudo ativo), aprender TEM que cansar.
### Como esquecemos
O esquecimento é o oposto, se uma memoria não esta no longo prazo ela tende a ser dissipada, nosso copo é muito inteligente, não gastaremos energia com a manutenção do caminho e pouco a pouco ele some.

## Técnicas de aprendizado.
Toda técnica de aprendizado gira em torno de simplificação, exposição, relação ou esforço cognitivo.
#### Flashcards
![[Gif que mostra como funciona um flashcard..gif]]
O flashcard(cartões rapidos) é uma tecnica onde  um lado de um cartão tem uma pergunta e do outro tem a resposta. A logica principal deles é ser rapido e curtos, ou seja uma pergunta simples e uma resposta rapida, e portanto vale muito uma habilidade da programação "quebrar o problema" mas oque sera quebrado é o conhecimento. 
#### Repetição espaçada
![[Grafico que mostra a curva de esquecimento mediante a nenhuma, 1, 2 ou 3 repetições e como impacta na curva..png|300]]
O Ebbinghaus fez um esperimento com gravar numeros aleatorios, no dia 0 ele gravava numeros aleatorios, e a primeira curba acentuada para baixo é o quanto dos numeros aleatorios ele lembrava no decorrer do dempo.
As outras curvas são revisões, ele relia os números e gravava de alguma forma(reescrevendo ou apenas lendo)
Então ele criou uma sequencia de dias para a revisão "perfeita"(dia seguinte, 7 dias, 30 dias....)
adendo importante, o experimento foi feito com números sem correlação nenhuma, a correlação é importante
#### Mnemônicos
![[é uma imagem que mostra um minemonico das datas e quais dos meses tem 28 30 e 31..png|300]]![[é um imagem d eum minemonimo para gravar os planetas do sistema solar por meio da inicial de todas as palavra da fraze..png|300]]
O mnemônico é toda facilitação de conhecimento por meio de outra coisa.
Deem-me exemplo de mnemônicos que vocês conhecem.
#### i+1
Essa formula significa informação + outra informação que não conheço.
Muito usado no estudo de idiomas.
Se você sabe escrever "I hate..."(I hate Pneumonoultramicroscopicsilicovolcanoconiosis) , usar esta frase para revisar uma palavra nova que aprendeu é perfeito, pois as confecções do cérebro para a frase já estão muito bem pavimentada, e usar parte desta estrada para aprender algo novo é ótimo.
![[Imagem que demostra como os caminhos do celebro ficam mais faceis quanto amis se expõe no que se quer aprender..gif]]
```python
print(lista....)
```
```python
print(lista.sorted)
```

#### Mineração de palavras ou sentenças
A mineração de sentença é pegar conceitos que possuo duvidas de um texto, livro, aula... Muito usado no estudo de idiomas, com a ideia de pegar palavra que não sabe anotar e
"Anki é um programa de flashcards que usa um algoritmo configurável de repetição espaçada e vida dos cards"
- flahscards
- algoritmo configurável
- repetição espaçada
- vida dos cards
#### Palavra-chave
## Técnicas de esquecimento

### Não exposição
Silaba átona
### Deixe complexo
Função para Movimento Retilíneo Uniformemente Variado (MRUV) 
$S = So + Vo.t + 1/2 a.t²$ 
### Não relacione
![[Pasted image 20241204214859.png]]
### Não se esforce 
![[Foto que mostra varios videos de aprendendo inglês dormindo, que é alguem falando inglês no seu ouvido..png]] 
## Anki
### O que é o anki
Anki é um programa de flashcards que usa um algoritmo configurável de repetição espaçada e vida dos cards.
### Como o anki funciona
#### vida dos cards
##### Possibilidades dos cards
- Os cartões tem niveis, sendo eles: aprendendo, reaprendendo, jovem, maduro e suspenso
#### baralho
##### Possibilidades dos baralhos
 - Os baralhos podem ter uma configuração especificas que mudam o quanto as cartas do baralho são mostradas, quanto das respostam tem de peso, se o cartão tem um limite de estudo.....

#### Versões e fan boy.
O anki assim como excel as versões são intercambiaveis, e por isso existem os fan boys de versão. 
A existencia dos fan boys é por que as extenções não são intercambiaveis.
### Porque o anki é tão complexo?
O anki tenta imitar/simular como o conhecimento está na nossa memoria, e nosso cerebro é muito complexo. 
Já adiantando, não ele não consegue imitar, mas com uma manutenção constante, é oque chega mais perto. 
#### Porque configurar?
Pois cada um aprende de uma velocidade diferente, e soma isso com matérias que temos vantagens e desvantagens, até o proprio gosto torna a materia mais facil ou mais dificil, o momento da vida....
### Porque o anki?
O anki consegue se adaptar(mediante a configuração e a técnicas de estudo) as formas que nois aprendemos, e fazendo assim que nos aprendermos mais rapido.
Outras tecnologas(duolingo, menrise, Duocards) usam(repetição espaçada, e foco nos conteúdos em erro) porém nenhuma delas é configurável.
#### Flashcards
![[Imagem mostra como é um card simples no Anki.png]]
#### Repetição espaçada
![[A imagem é um gif que mostra meus cartões em ordem de o quão longe é sua revisão..gif]]
#### Mnemonicos
![[A imagem mostra um minemonico em uma imagem colocada no anki.png]]
#### i+1
![[Desmostra a tecnica i+1 no anki.png]]
#### Mineração de palavras ou sentenças
| Palavra (Inglês) | Tradução (Português)   |
| ---------------- | ---------------------- |
| Query            | Consulta (ou Pesquisa) |
| Report           | Relatório              |
| Insight          | Percepção (ou Insight) |
| Dashboard        | Painel de Controle     |
| Chart            | Gráfico                |
| Column           | Coluna                 |
| Row              | Linha                  |
| Join             | Junção (ou Combinar)   |
| Trend            | Tendência              |
| Sample           | Amostra                |
| Model            | Modelo                 |
| Pattern          | Padrão                 |
| ...              | ...                    |
#### Palavra-chave
#### Dia a dia
![[A imagem mostra os dias de exforço onde eu fiz todos os dias exercicios no anki.png]]
#### Simplificação
Poderia colocar os numeros para eu dizer em si, coloquei as palavras que tenho dificuldade de escrever e em especifico a parte da palavra.
![[Pasted image 20241206234553.png]]
#### É um esforço mental respeitável
Fazer e revisar dezenas de flashcards todos os dias(dias bons, dias normais e dias ruins), é muito cansativo, frustrante... Mas muito funcional.

# Vocês gostariam de aprender mais sobre o Anki?
sim
talvez
não

--- ARQUIVO: OBS-to-TXT\teste.py ---
import os
import re
from datetime import datetime
import csv

def process_markdown_files(pasta_inicial, arquivo_saida):
    """
    Processa arquivos Markdown em uma pasta, extraindo informações como título, tags, data, contagem de palavras, links e caminho,
    e salva os resultados em um arquivo CSV.
    """
    with open(arquivo_saida, 'w', encoding='utf-8', newline='') as arquivo_csv:
        writer = csv.writer(arquivo_csv)
        writer.writerow(['Nome da Nota', 'Data da Última Modificação', 'Data da Nota', 'Tags', 'Contagem de Palavras', 'Links', 'Caminho da Nota'])

        for root, dirs, files in os.walk(pasta_inicial):
            for file in files:
                if file.endswith(".md"):
                    caminho_completo = os.path.join(root, file)
                    
                    try:
                        with open(caminho_completo, 'r', encoding='utf-8') as arquivo_md:
                            conteudo = arquivo_md.read()
                            
                            nome_nota = os.path.splitext(file)[0]
                            
                            # Data da última modificação
                            ultima_modificacao = os.path.getmtime(caminho_completo)
                            data_formatada = datetime.fromtimestamp(ultima_modificacao).strftime('%Y-%m-%d %H:%M:%S')

                            # Data da nota
                            data_match = re.search(r'data:\s*(\d{4}-\d{2}-\d{2})', conteudo, re.IGNORECASE)
                            data_nota = data_match.group(1) if data_match else ""
                            
                            # Tags
                            tags_match = re.findall(r'tags:\s*([^\n]+)', conteudo, re.IGNORECASE)
                            tags = ""
                            if tags_match:
                                all_tags = []
                                for match in tags_match:
                                    tags_lines = match.strip().split('\n')
                                    for line in tags_lines:
                                        tag = re.sub(r'^-\s*', '', line).strip()
                                        if tag:
                                            all_tags.append(tag)

                                tags = ", ".join(all_tags)
                            
                            # Contagem de palavras
                            palavras = re.findall(r'\b\w+\b', conteudo)
                            contagem_palavras = len(palavras)

                            # Contagem de links
                            contagem_links = len(re.findall(r'\[\[.*?\]\]', conteudo))

                            # Caminho da nota
                            caminho_nota = os.path.relpath(caminho_completo, pasta_inicial)  # Usa relpath para obter caminho relativo


                            # Escreve os resultados no CSV
                            writer.writerow([nome_nota, data_formatada, data_nota, tags, contagem_palavras, contagem_links, caminho_nota])


                    except Exception as e:
                        print(f"Erro ao processar {file}: {e}")
                        
    print(f"Arquivo CSV criado: {arquivo_saida}")


# Caminho da pasta onde estão suas notas em .md
pasta_inicial = r"C:\Users\jonat\Dropbox\Obsidian\obsidian" # Substitua pelo caminho correto
# Arquivo onde todas as notas serão concatenadas
arquivo_saida = "notas_organizadas.csv"

process_markdown_files(pasta_inicial, arquivo_saida)

